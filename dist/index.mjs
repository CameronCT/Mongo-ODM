var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/mongodb/lib/error_codes.js
var require_error_codes = __commonJS({
  "node_modules/mongodb/lib/error_codes.js"(exports2, module2) {
    "use strict";
    var MONGODB_ERROR_CODES = Object.freeze({
      HostUnreachable: 6,
      HostNotFound: 7,
      NetworkTimeout: 89,
      ShutdownInProgress: 91,
      PrimarySteppedDown: 189,
      ExceededTimeLimit: 262,
      SocketException: 9001,
      NotMaster: 10107,
      InterruptedAtShutdown: 11600,
      InterruptedDueToReplStateChange: 11602,
      NotMasterNoSlaveOk: 13435,
      NotMasterOrSecondary: 13436,
      StaleShardVersion: 63,
      StaleEpoch: 150,
      StaleConfig: 13388,
      RetryChangeStream: 234,
      FailedToSatisfyReadPreference: 133,
      CursorNotFound: 43,
      LegacyNotPrimary: 10058,
      WriteConcernFailed: 64,
      NamespaceNotFound: 26,
      IllegalOperation: 20,
      MaxTimeMSExpired: 50,
      UnknownReplWriteConcern: 79,
      UnsatisfiableWriteConcern: 100,
      DuplicateKey: 11e3,
      CannotCreateIndex: 67,
      IndexOptionsConflict: 85,
      IndexKeySpecsConflict: 86,
      InvalidIndexSpecificationOption: 197
    });
    module2.exports = Object.freeze({ MONGODB_ERROR_CODES });
  }
});

// node_modules/mongodb/lib/core/error.js
var require_error = __commonJS({
  "node_modules/mongodb/lib/core/error.js"(exports2, module2) {
    "use strict";
    var MONGODB_ERROR_CODES = require_error_codes().MONGODB_ERROR_CODES;
    var kErrorLabels = Symbol("errorLabels");
    var MongoError = class _MongoError extends Error {
      constructor(message) {
        if (message instanceof Error) {
          super(message.message);
          this.stack = message.stack;
        } else {
          if (typeof message === "string") {
            super(message);
          } else {
            super(message.message || message.errmsg || message.$err || "n/a");
            if (message.errorLabels) {
              this[kErrorLabels] = new Set(message.errorLabels);
            }
            for (var name in message) {
              if (name === "errorLabels" || name === "errmsg") {
                continue;
              }
              this[name] = message[name];
            }
          }
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "MongoError";
      }
      /**
       * Legacy name for server error responses
       */
      get errmsg() {
        return this.message;
      }
      /**
       * Creates a new MongoError object
       *
       * @param {Error|string|object} options The options used to create the error.
       * @return {MongoError} A MongoError instance
       * @deprecated Use `new MongoError()` instead.
       */
      static create(options) {
        return new _MongoError(options);
      }
      /**
       * Checks the error to see if it has an error label
       * @param {string} label The error label to check for
       * @returns {boolean} returns true if the error has the provided error label
       */
      hasErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          return false;
        }
        return this[kErrorLabels].has(label);
      }
      addErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          this[kErrorLabels] = /* @__PURE__ */ new Set();
        }
        this[kErrorLabels].add(label);
      }
      get errorLabels() {
        return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];
      }
    };
    var kBeforeHandshake = Symbol("beforeHandshake");
    function isNetworkErrorBeforeHandshake(err) {
      return err[kBeforeHandshake] === true;
    }
    var MongoNetworkError = class extends MongoError {
      constructor(message, options) {
        super(message);
        this.name = "MongoNetworkError";
        if (options && typeof options.beforeHandshake === "boolean") {
          this[kBeforeHandshake] = options.beforeHandshake;
        }
      }
    };
    var MongoNetworkTimeoutError = class extends MongoNetworkError {
      constructor(message, options) {
        super(message, options);
        this.name = "MongoNetworkTimeoutError";
      }
    };
    var MongoParseError = class extends MongoError {
      constructor(message) {
        super(message);
        this.name = "MongoParseError";
      }
    };
    var MongoTimeoutError = class extends MongoError {
      constructor(message, reason) {
        if (reason && reason.error) {
          super(reason.error.message || reason.error);
        } else {
          super(message);
        }
        this.name = "MongoTimeoutError";
        if (reason) {
          this.reason = reason;
        }
      }
    };
    var MongoServerSelectionError = class extends MongoTimeoutError {
      constructor(message, reason) {
        super(message, reason);
        this.name = "MongoServerSelectionError";
      }
    };
    function makeWriteConcernResultObject(input) {
      const output = Object.assign({}, input);
      if (output.ok === 0) {
        output.ok = 1;
        delete output.errmsg;
        delete output.code;
        delete output.codeName;
      }
      return output;
    }
    var MongoWriteConcernError = class extends MongoError {
      constructor(message, result) {
        super(message);
        this.name = "MongoWriteConcernError";
        if (result && Array.isArray(result.errorLabels)) {
          this[kErrorLabels] = new Set(result.errorLabels);
        }
        if (result != null) {
          this.result = makeWriteConcernResultObject(result);
        }
      }
    };
    var RETRYABLE_ERROR_CODES = /* @__PURE__ */ new Set([
      MONGODB_ERROR_CODES.HostUnreachable,
      MONGODB_ERROR_CODES.HostNotFound,
      MONGODB_ERROR_CODES.NetworkTimeout,
      MONGODB_ERROR_CODES.ShutdownInProgress,
      MONGODB_ERROR_CODES.PrimarySteppedDown,
      MONGODB_ERROR_CODES.SocketException,
      MONGODB_ERROR_CODES.NotMaster,
      MONGODB_ERROR_CODES.InterruptedAtShutdown,
      MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      MONGODB_ERROR_CODES.NotMasterNoSlaveOk,
      MONGODB_ERROR_CODES.NotMasterOrSecondary
    ]);
    var RETRYABLE_WRITE_ERROR_CODES = /* @__PURE__ */ new Set([
      MONGODB_ERROR_CODES.InterruptedAtShutdown,
      MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      MONGODB_ERROR_CODES.NotMaster,
      MONGODB_ERROR_CODES.NotMasterNoSlaveOk,
      MONGODB_ERROR_CODES.NotMasterOrSecondary,
      MONGODB_ERROR_CODES.PrimarySteppedDown,
      MONGODB_ERROR_CODES.ShutdownInProgress,
      MONGODB_ERROR_CODES.HostNotFound,
      MONGODB_ERROR_CODES.HostUnreachable,
      MONGODB_ERROR_CODES.NetworkTimeout,
      MONGODB_ERROR_CODES.SocketException,
      MONGODB_ERROR_CODES.ExceededTimeLimit
    ]);
    function isRetryableEndTransactionError(error) {
      return error.hasErrorLabel("RetryableWriteError");
    }
    function isRetryableWriteError(error) {
      if (error instanceof MongoWriteConcernError) {
        return RETRYABLE_WRITE_ERROR_CODES.has(error.code) || RETRYABLE_WRITE_ERROR_CODES.has(error.result.code);
      }
      return RETRYABLE_WRITE_ERROR_CODES.has(error.code);
    }
    function isRetryableError(error) {
      return RETRYABLE_ERROR_CODES.has(error.code) || error instanceof MongoNetworkError || error.message.match(/not master/) || error.message.match(/node is recovering/);
    }
    var SDAM_RECOVERING_CODES = /* @__PURE__ */ new Set([
      MONGODB_ERROR_CODES.ShutdownInProgress,
      MONGODB_ERROR_CODES.PrimarySteppedDown,
      MONGODB_ERROR_CODES.InterruptedAtShutdown,
      MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      MONGODB_ERROR_CODES.NotMasterOrSecondary
    ]);
    var SDAM_NOTMASTER_CODES = /* @__PURE__ */ new Set([
      MONGODB_ERROR_CODES.NotMaster,
      MONGODB_ERROR_CODES.NotMasterNoSlaveOk,
      MONGODB_ERROR_CODES.LegacyNotPrimary
    ]);
    var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = /* @__PURE__ */ new Set([
      MONGODB_ERROR_CODES.InterruptedAtShutdown,
      MONGODB_ERROR_CODES.ShutdownInProgress
    ]);
    function isRecoveringError(err) {
      if (typeof err.code === "number") {
        return SDAM_RECOVERING_CODES.has(err.code);
      }
      return /not master or secondary/.test(err.message) || /node is recovering/.test(err.message);
    }
    function isNotMasterError(err) {
      if (typeof err.code === "number") {
        return SDAM_NOTMASTER_CODES.has(err.code);
      }
      if (isRecoveringError(err)) {
        return false;
      }
      return /not master/.test(err.message);
    }
    function isNodeShuttingDownError(err) {
      return err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code);
    }
    function isSDAMUnrecoverableError(error) {
      if (error instanceof MongoParseError || error == null) {
        return true;
      }
      return isRecoveringError(error) || isNotMasterError(error);
    }
    module2.exports = {
      MongoError,
      MongoNetworkError,
      MongoNetworkTimeoutError,
      MongoParseError,
      MongoTimeoutError,
      MongoServerSelectionError,
      MongoWriteConcernError,
      isRetryableError,
      isSDAMUnrecoverableError,
      isNodeShuttingDownError,
      isRetryableWriteError,
      isNetworkErrorBeforeHandshake,
      isRetryableEndTransactionError
    };
  }
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS({
  "node_modules/mongodb/lib/write_concern.js"(exports2, module2) {
    "use strict";
    var kWriteConcernKeys = /* @__PURE__ */ new Set(["w", "wtimeout", "j", "journal", "fsync"]);
    var utils2;
    var WriteConcern = class _WriteConcern {
      /**
       * Constructs a WriteConcern from the write concern properties.
       * @param {(number|string)} [w] The write concern
       * @param {number} [wtimeout] The write concern timeout
       * @param {boolean} [j] The journal write concern
       * @param {boolean} [fsync] The file sync write concern
       */
      constructor(w, wtimeout, j, fsync) {
        if (w != null) {
          this.w = w;
        }
        if (wtimeout != null) {
          this.wtimeout = wtimeout;
        }
        if (j != null) {
          this.j = j;
        }
        if (fsync != null) {
          this.fsync = fsync;
        }
      }
      /**
       * Construct a WriteConcern given an options object.
       *
       * @param {object} [options] The options object from which to extract the write concern.
       * @param {(number|string)} [options.w] **Deprecated** Use `options.writeConcern` instead
       * @param {number} [options.wtimeout] **Deprecated** Use `options.writeConcern` instead
       * @param {boolean} [options.j] **Deprecated** Use `options.writeConcern` instead
       * @param {boolean} [options.fsync] **Deprecated** Use `options.writeConcern` instead
       * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.
       * @return {WriteConcern}
       */
      static fromOptions(options) {
        if (options == null || options.writeConcern == null && options.w == null && options.wtimeout == null && options.j == null && options.journal == null && options.fsync == null) {
          return;
        }
        if (options.writeConcern) {
          if (typeof options.writeConcern === "string") {
            return new _WriteConcern(options.writeConcern);
          }
          if (!Object.keys(options.writeConcern).some((key) => kWriteConcernKeys.has(key))) {
            return;
          }
          return new _WriteConcern(
            options.writeConcern.w,
            options.writeConcern.wtimeout,
            options.writeConcern.j || options.writeConcern.journal,
            options.writeConcern.fsync
          );
        }
        if (!utils2)
          utils2 = require_utils();
        utils2.emitWarningOnce(
          `Top-level use of w, wtimeout, j, and fsync is deprecated. Use writeConcern instead.`
        );
        return new _WriteConcern(
          options.w,
          options.wtimeout,
          options.j || options.journal,
          options.fsync
        );
      }
    };
    module2.exports = WriteConcern;
  }
});

// node_modules/mongodb/lib/async/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/mongodb/lib/async/async_iterator.js"(exports2) {
    "use strict";
    function asyncIterator() {
      const cursor = this;
      return {
        next: function() {
          return Promise.resolve().then(() => cursor.next()).then((value2) => {
            if (!value2) {
              return cursor.close().then(() => ({ value: value2, done: true }));
            }
            return { value: value2, done: false };
          });
        }
      };
    }
    exports2.asyncIterator = asyncIterator;
  }
});

// node_modules/mongodb/lib/utils.js
var require_utils = __commonJS({
  "node_modules/mongodb/lib/utils.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var WriteConcern = require_write_concern();
    var shallowClone = function(obj) {
      var copy = {};
      for (var name in obj)
        copy[name] = obj[name];
      return copy;
    };
    var getSingleProperty = function(obj, name, value2) {
      Object.defineProperty(obj, name, {
        enumerable: true,
        get: function() {
          return value2;
        }
      });
    };
    var formatSortValue = exports2.formatSortValue = function(sortDirection) {
      var value2 = ("" + sortDirection).toLowerCase();
      switch (value2) {
        case "ascending":
        case "asc":
        case "1":
          return 1;
        case "descending":
        case "desc":
        case "-1":
          return -1;
        default:
          throw new Error(
            "Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]"
          );
      }
    };
    var formattedOrderClause = exports2.formattedOrderClause = function(sortValue) {
      var orderBy = /* @__PURE__ */ new Map();
      if (sortValue == null)
        return null;
      if (Array.isArray(sortValue)) {
        if (sortValue.length === 0) {
          return null;
        }
        for (var i = 0; i < sortValue.length; i++) {
          if (sortValue[i].constructor === String) {
            orderBy.set(`${sortValue[i]}`, 1);
          } else {
            orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));
          }
        }
      } else if (sortValue != null && typeof sortValue === "object") {
        if (sortValue instanceof Map) {
          orderBy = sortValue;
        } else {
          var sortKeys = Object.keys(sortValue);
          for (var k of sortKeys) {
            orderBy.set(k, sortValue[k]);
          }
        }
      } else if (typeof sortValue === "string") {
        orderBy.set(`${sortValue}`, 1);
      } else {
        throw new Error(
          "Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]"
        );
      }
      return orderBy;
    };
    var checkCollectionName = function checkCollectionName2(collectionName) {
      if ("string" !== typeof collectionName) {
        throw new MongoError("collection name must be a String");
      }
      if (!collectionName || collectionName.indexOf("..") !== -1) {
        throw new MongoError("collection names cannot be empty");
      }
      if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
        throw new MongoError("collection names must not contain '$'");
      }
      if (collectionName.match(/^\.|\.$/) != null) {
        throw new MongoError("collection names must not start or end with '.'");
      }
      if (collectionName.indexOf("\0") !== -1) {
        throw new MongoError("collection names cannot contain a null character");
      }
    };
    var handleCallback = function(callback, err, value1, value2) {
      try {
        if (callback == null)
          return;
        if (callback) {
          return value2 ? callback(err, value1, value2) : callback(err, value1);
        }
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
        return false;
      }
      return true;
    };
    var toError = function(error) {
      if (error instanceof Error)
        return error;
      var msg = error.err || error.errmsg || error.errMessage || error;
      var e = MongoError.create({ message: msg, driver: true });
      var keys = typeof error === "object" ? Object.keys(error) : [];
      for (var i = 0; i < keys.length; i++) {
        try {
          e[keys[i]] = error[keys[i]];
        } catch (err) {
        }
      }
      return e;
    };
    var normalizeHintField = function normalizeHintField2(hint) {
      var finalHint = null;
      if (typeof hint === "string") {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach(function(param) {
          finalHint[param] = 1;
        });
      } else if (hint != null && typeof hint === "object") {
        finalHint = {};
        for (var name in hint) {
          finalHint[name] = hint[name];
        }
      }
      return finalHint;
    };
    var parseIndexOptions = function(fieldOrSpec) {
      var fieldHash = {};
      var indexes = [];
      var keys;
      if ("string" === typeof fieldOrSpec) {
        indexes.push(fieldOrSpec + "_1");
        fieldHash[fieldOrSpec] = 1;
      } else if (Array.isArray(fieldOrSpec)) {
        fieldOrSpec.forEach(function(f) {
          if ("string" === typeof f) {
            indexes.push(f + "_1");
            fieldHash[f] = 1;
          } else if (Array.isArray(f)) {
            indexes.push(f[0] + "_" + (f[1] || 1));
            fieldHash[f[0]] = f[1] || 1;
          } else if (isObject(f)) {
            keys = Object.keys(f);
            keys.forEach(function(k) {
              indexes.push(k + "_" + f[k]);
              fieldHash[k] = f[k];
            });
          } else {
          }
        });
      } else if (isObject(fieldOrSpec)) {
        keys = Object.keys(fieldOrSpec);
        keys.forEach(function(key) {
          indexes.push(key + "_" + fieldOrSpec[key]);
          fieldHash[key] = fieldOrSpec[key];
        });
      }
      return {
        name: indexes.join("_"),
        keys,
        fieldHash
      };
    };
    var isObject = exports2.isObject = function(arg) {
      return "[object Object]" === Object.prototype.toString.call(arg);
    };
    var debugOptions = function(debugFields, options) {
      var finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options[n];
      });
      return finaloptions;
    };
    var decorateCommand = function(command, options, exclude) {
      for (var name in options) {
        if (exclude.indexOf(name) === -1)
          command[name] = options[name];
      }
      return command;
    };
    var mergeOptions = function(target, source) {
      for (var name in source) {
        target[name] = source[name];
      }
      return target;
    };
    var translateOptions = function(target, source) {
      var translations = {
        // SSL translation options
        sslCA: "ca",
        sslCRL: "crl",
        sslValidate: "rejectUnauthorized",
        sslKey: "key",
        sslCert: "cert",
        sslPass: "passphrase",
        // SocketTimeout translation options
        socketTimeoutMS: "socketTimeout",
        connectTimeoutMS: "connectionTimeout",
        // Replicaset options
        replicaSet: "setName",
        rs_name: "setName",
        secondaryAcceptableLatencyMS: "acceptableLatency",
        connectWithNoPrimary: "secondaryOnlyConnectionAllowed",
        // Mongos options
        acceptableLatencyMS: "localThresholdMS"
      };
      for (var name in source) {
        if (translations[name]) {
          target[translations[name]] = source[name];
        } else {
          target[name] = source[name];
        }
      }
      return target;
    };
    var filterOptions = function(options, names) {
      var filterOptions2 = {};
      for (var name in options) {
        if (names.indexOf(name) !== -1)
          filterOptions2[name] = options[name];
      }
      return filterOptions2;
    };
    var WRITE_CONCERN_KEYS = ["w", "j", "wtimeout", "fsync", "writeConcern"];
    function conditionallyMergeWriteConcern(target, source) {
      let found = false;
      for (const wcKey of WRITE_CONCERN_KEYS) {
        if (wcKey in target) {
          found = true;
          break;
        }
      }
      if (!found) {
        for (const wcKey of WRITE_CONCERN_KEYS) {
          if (source[wcKey]) {
            if (!("writeConcern" in target)) {
              target.writeConcern = {};
            }
            target.writeConcern[wcKey] = source[wcKey];
          }
        }
      }
      return target;
    }
    var executeLegacyOperation = (topology, operation, args, options) => {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!Array.isArray(args)) {
        throw new TypeError("This method requires an array of arguments to apply");
      }
      options = options || {};
      const Promise2 = topology.s.promiseLibrary;
      let callback = args[args.length - 1];
      let session, opOptions, owner;
      if (!options.skipSessions && topology.hasSessionSupport()) {
        opOptions = args[args.length - 2];
        if (opOptions == null || opOptions.session == null) {
          owner = Symbol();
          session = topology.startSession({ owner });
          const optionsIndex = args.length - 2;
          args[optionsIndex] = Object.assign({}, args[optionsIndex], { session });
        } else if (opOptions.session && opOptions.session.hasEnded) {
          throw new MongoError("Use of expired sessions is not permitted");
        }
      }
      const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {
        if (session && session.owner === owner && !options.returnsCursor) {
          session.endSession(() => {
            delete opOptions.session;
            if (err)
              return reject(err);
            resolve(result);
          });
        } else {
          if (err)
            return reject(err);
          resolve(result);
        }
      };
      if (typeof callback === "function") {
        callback = args.pop();
        const handler = makeExecuteCallback(
          (result) => callback(null, result),
          (err) => callback(err, null)
        );
        args.push(handler);
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
          throw e;
        }
      }
      if (args[args.length - 1] != null) {
        throw new TypeError("final argument to `executeLegacyOperation` must be a callback");
      }
      return new Promise2(function(resolve, reject) {
        const handler = makeExecuteCallback(resolve, reject);
        args[args.length - 1] = handler;
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
        }
      });
    };
    function applyRetryableWrites(target, db) {
      if (db && db.s.options.retryWrites) {
        target.retryWrites = true;
      }
      return target;
    }
    function applyWriteConcern(target, sources, options) {
      options = options || {};
      const db = sources.db;
      const coll = sources.collection;
      if (options.session && options.session.inTransaction()) {
        if (target.writeConcern) {
          delete target.writeConcern;
        }
        return target;
      }
      const writeConcern = WriteConcern.fromOptions(options);
      if (writeConcern) {
        return Object.assign(target, { writeConcern });
      }
      if (coll && coll.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });
      }
      if (db && db.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });
      }
      return target;
    }
    function isPromiseLike(maybePromise2) {
      return maybePromise2 && typeof maybePromise2.then === "function";
    }
    function decorateWithCollation(command, target, options) {
      const topology = target.s && target.s.topology || target.topology;
      if (!topology) {
        throw new TypeError('parameter "target" is missing a topology');
      }
      const capabilities = topology.capabilities();
      if (options.collation && typeof options.collation === "object") {
        if (capabilities && capabilities.commandsTakeCollation) {
          command.collation = options.collation;
        } else {
          throw new MongoError(`Current topology does not support collation`);
        }
      }
    }
    function decorateWithReadConcern(command, coll, options) {
      if (options && options.session && options.session.inTransaction()) {
        return;
      }
      let readConcern = Object.assign({}, command.readConcern || {});
      if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
      }
      if (Object.keys(readConcern).length > 0) {
        Object.assign(command, { readConcern });
      }
    }
    function decorateWithExplain(command, explain) {
      if (command.explain) {
        return command;
      }
      return { explain: command, verbosity: explain.verbosity };
    }
    var nodejsMajorVersion = +process.version.split(".")[0].substring(1);
    var emitProcessWarning = (msg) => nodejsMajorVersion <= 6 ? process.emitWarning(msg, "DeprecationWarning", MONGODB_WARNING_CODE) : process.emitWarning(msg, { type: "DeprecationWarning", code: MONGODB_WARNING_CODE });
    var emitConsoleWarning = (msg) => console.error(msg);
    var emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;
    function defaultMsgHandler(name, option) {
      return `${name} option [${option}] is deprecated and will be removed in a later version.`;
    }
    function deprecateOptions(config, fn) {
      if (process.noDeprecation === true) {
        return fn;
      }
      const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
      const optionsWarned = /* @__PURE__ */ new Set();
      function deprecated() {
        const options = arguments[config.optionsIndex];
        if (!isObject(options) || Object.keys(options).length === 0) {
          return fn.apply(this, arguments);
        }
        config.deprecatedOptions.forEach((deprecatedOption) => {
          if (Object.prototype.hasOwnProperty.call(options, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {
            optionsWarned.add(deprecatedOption);
            const msg = msgHandler(config.name, deprecatedOption);
            emitDeprecationWarning(msg);
            if (this && this.getLogger) {
              const logger = this.getLogger();
              if (logger) {
                logger.warn(msg);
              }
            }
          }
        });
        return fn.apply(this, arguments);
      }
      Object.setPrototypeOf(deprecated, fn);
      if (fn.prototype) {
        deprecated.prototype = fn.prototype;
      }
      return deprecated;
    }
    var SUPPORTS = {};
    try {
      require_async_iterator();
      SUPPORTS.ASYNC_ITERATOR = true;
    } catch (e) {
      SUPPORTS.ASYNC_ITERATOR = false;
    }
    var MongoDBNamespace = class _MongoDBNamespace {
      constructor(db, collection) {
        this.db = db;
        this.collection = collection;
      }
      toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
      }
      withCollection(collection) {
        return new _MongoDBNamespace(this.db, collection);
      }
      static fromString(namespace) {
        if (!namespace) {
          throw new Error(`Cannot parse namespace from "${namespace}"`);
        }
        const index = namespace.indexOf(".");
        return new _MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));
      }
    };
    function* makeCounter(seed) {
      let count = seed || 0;
      while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
      }
    }
    function maybePromise(parent, callback, fn) {
      const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;
      let result;
      if (typeof callback !== "function") {
        result = new PromiseLibrary((resolve, reject) => {
          callback = (err, res) => {
            if (err)
              return reject(err);
            resolve(res);
          };
        });
      }
      fn(function(err, res) {
        if (err != null) {
          try {
            callback(err);
          } catch (error) {
            return process.nextTick(() => {
              throw error;
            });
          }
          return;
        }
        callback(err, res);
      });
      return result;
    }
    function now() {
      const hrtime = process.hrtime();
      return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
    }
    function calculateDurationInMs(started) {
      if (typeof started !== "number") {
        throw TypeError("numeric value required to calculate duration");
      }
      const elapsed = now() - started;
      return elapsed < 0 ? 0 : elapsed;
    }
    function makeInterruptableAsyncInterval(fn, options) {
      let timerId;
      let lastCallTime;
      let lastWakeTime;
      let stopped = false;
      options = options || {};
      const interval = options.interval || 1e3;
      const minInterval = options.minInterval || 500;
      const immediate = typeof options.immediate === "boolean" ? options.immediate : false;
      const clock = typeof options.clock === "function" ? options.clock : now;
      function wake() {
        const currentTime = clock();
        const timeSinceLastWake = currentTime - lastWakeTime;
        const timeSinceLastCall = currentTime - lastCallTime;
        const timeUntilNextCall = interval - timeSinceLastCall;
        lastWakeTime = currentTime;
        if (timeSinceLastWake < minInterval) {
          return;
        }
        if (timeUntilNextCall > minInterval) {
          reschedule(minInterval);
        }
        if (timeUntilNextCall < 0) {
          executeAndReschedule();
        }
      }
      function stop() {
        stopped = true;
        if (timerId) {
          clearTimeout(timerId);
          timerId = null;
        }
        lastCallTime = 0;
        lastWakeTime = 0;
      }
      function reschedule(ms) {
        if (stopped)
          return;
        clearTimeout(timerId);
        timerId = setTimeout(executeAndReschedule, ms || interval);
      }
      function executeAndReschedule() {
        lastWakeTime = 0;
        lastCallTime = clock();
        fn((err) => {
          if (err)
            throw err;
          reschedule(interval);
        });
      }
      if (immediate) {
        executeAndReschedule();
      } else {
        lastCallTime = clock();
        reschedule();
      }
      return { wake, stop };
    }
    function hasAtomicOperators(doc) {
      if (Array.isArray(doc)) {
        return doc.reduce((err, u) => err || hasAtomicOperators(u), null);
      }
      return Object.keys(typeof doc.toBSON !== "function" ? doc : doc.toBSON()).map((k) => k[0]).indexOf("$") >= 0;
    }
    var MONGODB_WARNING_CODE = "MONGODB DRIVER";
    function emitWarning(message) {
      if (process.emitWarning) {
        return nodejsMajorVersion <= 6 ? process.emitWarning(message, void 0, MONGODB_WARNING_CODE) : process.emitWarning(message, { code: MONGODB_WARNING_CODE });
      } else {
        return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);
      }
    }
    var emittedWarnings = /* @__PURE__ */ new Set();
    function emitWarningOnce(message) {
      if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
      }
    }
    function isSuperset(set, subset) {
      set = Array.isArray(set) ? new Set(set) : set;
      subset = Array.isArray(subset) ? new Set(subset) : subset;
      for (const elem of subset) {
        if (!set.has(elem)) {
          return false;
        }
      }
      return true;
    }
    function isRecord(value2, requiredKeys) {
      const toString = Object.prototype.toString;
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      const isObject2 = (v) => toString.call(v) === "[object Object]";
      if (!isObject2(value2)) {
        return false;
      }
      const ctor = value2.constructor;
      if (ctor && ctor.prototype) {
        if (!isObject2(ctor.prototype)) {
          return false;
        }
        if (!hasOwnProperty.call(ctor.prototype, "isPrototypeOf")) {
          return false;
        }
      }
      if (requiredKeys) {
        const keys = Object.keys(value2);
        return isSuperset(keys, requiredKeys);
      }
      return true;
    }
    function deepCopy(value2) {
      if (value2 == null) {
        return value2;
      } else if (Array.isArray(value2)) {
        return value2.map((item) => deepCopy(item));
      } else if (isRecord(value2)) {
        const res = {};
        for (const key in value2) {
          res[key] = deepCopy(value2[key]);
        }
        return res;
      }
      const ctor = value2.constructor;
      if (ctor) {
        switch (ctor.name.toLowerCase()) {
          case "date":
            return new ctor(Number(value2));
          case "map":
            return new Map(value2);
          case "set":
            return new Set(value2);
          case "buffer":
            return Buffer.from(value2);
        }
      }
      return value2;
    }
    function parsePackageVersion(pkg) {
      const versionParts = pkg.version.split(".").map((n) => Number.parseInt(n, 10));
      return { major: versionParts[0], minor: versionParts[1], patch: versionParts[2] };
    }
    module2.exports = {
      filterOptions,
      mergeOptions,
      translateOptions,
      shallowClone,
      getSingleProperty,
      checkCollectionName,
      toError,
      formattedOrderClause,
      parseIndexOptions,
      normalizeHintField,
      handleCallback,
      decorateCommand,
      isObject,
      debugOptions,
      MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,
      conditionallyMergeWriteConcern,
      executeLegacyOperation,
      applyRetryableWrites,
      applyWriteConcern,
      isPromiseLike,
      decorateWithCollation,
      decorateWithReadConcern,
      decorateWithExplain,
      deprecateOptions,
      SUPPORTS,
      MongoDBNamespace,
      emitDeprecationWarning,
      makeCounter,
      maybePromise,
      now,
      calculateDurationInMs,
      makeInterruptableAsyncInterval,
      hasAtomicOperators,
      MONGODB_WARNING_CODE,
      emitWarning,
      emitWarningOnce,
      deepCopy,
      parsePackageVersion
    };
  }
});

// node_modules/bson/lib/bson/map.js
var require_map = __commonJS({
  "node_modules/bson/lib/bson/map.js"(exports2, module2) {
    "use strict";
    if (typeof global.Map !== "undefined") {
      module2.exports = global.Map;
      module2.exports.Map = global.Map;
    } else {
      Map2 = function(array) {
        this._keys = [];
        this._values = {};
        for (var i = 0; i < array.length; i++) {
          if (array[i] == null)
            continue;
          var entry = array[i];
          var key = entry[0];
          var value2 = entry[1];
          this._keys.push(key);
          this._values[key] = { v: value2, i: this._keys.length - 1 };
        }
      };
      Map2.prototype.clear = function() {
        this._keys = [];
        this._values = {};
      };
      Map2.prototype.delete = function(key) {
        var value2 = this._values[key];
        if (value2 == null)
          return false;
        delete this._values[key];
        this._keys.splice(value2.i, 1);
        return true;
      };
      Map2.prototype.entries = function() {
        var self2 = this;
        var index = 0;
        return {
          next: function() {
            var key = self2._keys[index++];
            return {
              value: key !== void 0 ? [key, self2._values[key].v] : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.forEach = function(callback, self2) {
        self2 = self2 || this;
        for (var i = 0; i < this._keys.length; i++) {
          var key = this._keys[i];
          callback.call(self2, this._values[key].v, key, self2);
        }
      };
      Map2.prototype.get = function(key) {
        return this._values[key] ? this._values[key].v : void 0;
      };
      Map2.prototype.has = function(key) {
        return this._values[key] != null;
      };
      Map2.prototype.keys = function() {
        var self2 = this;
        var index = 0;
        return {
          next: function() {
            var key = self2._keys[index++];
            return {
              value: key !== void 0 ? key : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.set = function(key, value2) {
        if (this._values[key]) {
          this._values[key].v = value2;
          return this;
        }
        this._keys.push(key);
        this._values[key] = { v: value2, i: this._keys.length - 1 };
        return this;
      };
      Map2.prototype.values = function() {
        var self2 = this;
        var index = 0;
        return {
          next: function() {
            var key = self2._keys[index++];
            return {
              value: key !== void 0 ? self2._values[key].v : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Object.defineProperty(Map2.prototype, "size", {
        enumerable: true,
        get: function() {
          return this._keys.length;
        }
      });
      module2.exports = Map2;
      module2.exports.Map = Map2;
    }
    var Map2;
  }
});

// node_modules/bson/lib/bson/long.js
var require_long = __commonJS({
  "node_modules/bson/lib/bson/long.js"(exports2, module2) {
    function Long2(low, high) {
      if (!(this instanceof Long2))
        return new Long2(low, high);
      this._bsontype = "Long";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Long2.prototype.toInt = function() {
      return this.low_;
    };
    Long2.prototype.toNumber = function() {
      return this.high_ * Long2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Long2.prototype.toBigInt = function() {
      return BigInt(this.toString());
    };
    Long2.prototype.toJSON = function() {
      return this.toString();
    };
    Long2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          var radixLong = Long2.fromNumber(radix);
          var div = this.div(radixLong);
          var rem = div.multiply(radixLong).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Long2.prototype.getHighBits = function() {
      return this.high_;
    };
    Long2.prototype.getLowBits = function() {
      return this.low_;
    };
    Long2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Long2.TWO_PWR_32_DBL_ + this.low_;
    };
    Long2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Long2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Long2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Long2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Long2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Long2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Long2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Long2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Long2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Long2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Long2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Long2.prototype.negate = function() {
      if (this.equals(Long2.MIN_VALUE)) {
        return Long2.MIN_VALUE;
      } else {
        return this.not().add(Long2.ONE);
      }
    };
    Long2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Long2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Long2.ZERO;
      } else if (other.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        return other.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      } else if (other.equals(Long2.MIN_VALUE)) {
        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Long2.TWO_PWR_24_) && other.lessThan(Long2.TWO_PWR_24_)) {
        return Long2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        if (other.equals(Long2.ONE) || other.equals(Long2.NEG_ONE)) {
          return Long2.MIN_VALUE;
        } else if (other.equals(Long2.MIN_VALUE)) {
          return Long2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Long2.ZERO)) {
            return other.isNegative() ? Long2.ONE : Long2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Long2.MIN_VALUE)) {
        return Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Long2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Long2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Long2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Long2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Long2.prototype.not = function() {
      return Long2.fromBits(~this.low_, ~this.high_);
    };
    Long2.prototype.and = function(other) {
      return Long2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Long2.prototype.or = function(other) {
      return Long2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Long2.prototype.xor = function(other) {
      return Long2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Long2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Long2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Long2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Long2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Long2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Long2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Long2.fromBits(high, 0);
        } else {
          return Long2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Long2.fromInt = function(value2) {
      if (-128 <= value2 && value2 < 128) {
        var cachedObj = Long2.INT_CACHE_[value2];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Long2(value2 | 0, value2 < 0 ? -1 : 0);
      if (-128 <= value2 && value2 < 128) {
        Long2.INT_CACHE_[value2] = obj;
      }
      return obj;
    };
    Long2.fromNumber = function(value2) {
      if (isNaN(value2) || !isFinite(value2)) {
        return Long2.ZERO;
      } else if (value2 <= -Long2.TWO_PWR_63_DBL_) {
        return Long2.MIN_VALUE;
      } else if (value2 + 1 >= Long2.TWO_PWR_63_DBL_) {
        return Long2.MAX_VALUE;
      } else if (value2 < 0) {
        return Long2.fromNumber(-value2).negate();
      } else {
        return new Long2(value2 % Long2.TWO_PWR_32_DBL_ | 0, value2 / Long2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Long2.fromBigInt = function(value2) {
      return Long2.fromString(value2.toString(10), 10);
    };
    Long2.fromBits = function(lowBits, highBits) {
      return new Long2(lowBits, highBits);
    };
    Long2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Long2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
      var result = Long2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value2 = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Long2.fromNumber(value2));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Long2.fromNumber(value2));
        }
      }
      return result;
    };
    Long2.INT_CACHE_ = {};
    Long2.TWO_PWR_16_DBL_ = 1 << 16;
    Long2.TWO_PWR_24_DBL_ = 1 << 24;
    Long2.TWO_PWR_32_DBL_ = Long2.TWO_PWR_16_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_31_DBL_ = Long2.TWO_PWR_32_DBL_ / 2;
    Long2.TWO_PWR_48_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_64_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_32_DBL_;
    Long2.TWO_PWR_63_DBL_ = Long2.TWO_PWR_64_DBL_ / 2;
    Long2.ZERO = Long2.fromInt(0);
    Long2.ONE = Long2.fromInt(1);
    Long2.NEG_ONE = Long2.fromInt(-1);
    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0);
    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0);
    Long2.TWO_PWR_24_ = Long2.fromInt(1 << 24);
    module2.exports = Long2;
    module2.exports.Long = Long2;
  }
});

// node_modules/bson/lib/bson/double.js
var require_double = __commonJS({
  "node_modules/bson/lib/bson/double.js"(exports2, module2) {
    function Double2(value2) {
      if (!(this instanceof Double2))
        return new Double2(value2);
      this._bsontype = "Double";
      this.value = value2;
    }
    Double2.prototype.valueOf = function() {
      return this.value;
    };
    Double2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Double2;
    module2.exports.Double = Double2;
  }
});

// node_modules/bson/lib/bson/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/bson/lib/bson/timestamp.js"(exports2, module2) {
    function Timestamp2(low, high) {
      if (!(this instanceof Timestamp2))
        return new Timestamp2(low, high);
      this._bsontype = "Timestamp";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Timestamp2.prototype.toInt = function() {
      return this.low_;
    };
    Timestamp2.prototype.toNumber = function() {
      return this.high_ * Timestamp2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Timestamp2.prototype.toJSON = function() {
      return this.toString();
    };
    Timestamp2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          var radixTimestamp = Timestamp2.fromNumber(radix);
          var div = this.div(radixTimestamp);
          var rem = div.multiply(radixTimestamp).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Timestamp2.prototype.getHighBits = function() {
      return this.high_;
    };
    Timestamp2.prototype.getLowBits = function() {
      return this.low_;
    };
    Timestamp2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Timestamp2.TWO_PWR_32_DBL_ + this.low_;
    };
    Timestamp2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Timestamp2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Timestamp2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Timestamp2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Timestamp2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Timestamp2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Timestamp2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Timestamp2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Timestamp2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Timestamp2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Timestamp2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Timestamp2.prototype.negate = function() {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.MIN_VALUE;
      } else {
        return this.not().add(Timestamp2.ONE);
      }
    };
    Timestamp2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Timestamp2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Timestamp2.ZERO;
      } else if (other.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return other.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return this.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Timestamp2.TWO_PWR_24_) && other.lessThan(Timestamp2.TWO_PWR_24_)) {
        return Timestamp2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        if (other.equals(Timestamp2.ONE) || other.equals(Timestamp2.NEG_ONE)) {
          return Timestamp2.MIN_VALUE;
        } else if (other.equals(Timestamp2.MIN_VALUE)) {
          return Timestamp2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Timestamp2.ZERO)) {
            return other.isNegative() ? Timestamp2.ONE : Timestamp2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Timestamp2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Timestamp2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Timestamp2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Timestamp2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Timestamp2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Timestamp2.prototype.not = function() {
      return Timestamp2.fromBits(~this.low_, ~this.high_);
    };
    Timestamp2.prototype.and = function(other) {
      return Timestamp2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Timestamp2.prototype.or = function(other) {
      return Timestamp2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Timestamp2.prototype.xor = function(other) {
      return Timestamp2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Timestamp2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Timestamp2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Timestamp2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Timestamp2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Timestamp2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Timestamp2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Timestamp2.fromBits(high, 0);
        } else {
          return Timestamp2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Timestamp2.fromInt = function(value2) {
      if (-128 <= value2 && value2 < 128) {
        var cachedObj = Timestamp2.INT_CACHE_[value2];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Timestamp2(value2 | 0, value2 < 0 ? -1 : 0);
      if (-128 <= value2 && value2 < 128) {
        Timestamp2.INT_CACHE_[value2] = obj;
      }
      return obj;
    };
    Timestamp2.fromNumber = function(value2) {
      if (isNaN(value2) || !isFinite(value2)) {
        return Timestamp2.ZERO;
      } else if (value2 <= -Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MIN_VALUE;
      } else if (value2 + 1 >= Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MAX_VALUE;
      } else if (value2 < 0) {
        return Timestamp2.fromNumber(-value2).negate();
      } else {
        return new Timestamp2(
          value2 % Timestamp2.TWO_PWR_32_DBL_ | 0,
          value2 / Timestamp2.TWO_PWR_32_DBL_ | 0
        );
      }
    };
    Timestamp2.fromBits = function(lowBits, highBits) {
      return new Timestamp2(lowBits, highBits);
    };
    Timestamp2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Timestamp2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 8));
      var result = Timestamp2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value2 = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Timestamp2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Timestamp2.fromNumber(value2));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Timestamp2.fromNumber(value2));
        }
      }
      return result;
    };
    Timestamp2.INT_CACHE_ = {};
    Timestamp2.TWO_PWR_16_DBL_ = 1 << 16;
    Timestamp2.TWO_PWR_24_DBL_ = 1 << 24;
    Timestamp2.TWO_PWR_32_DBL_ = Timestamp2.TWO_PWR_16_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_31_DBL_ = Timestamp2.TWO_PWR_32_DBL_ / 2;
    Timestamp2.TWO_PWR_48_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_64_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_32_DBL_;
    Timestamp2.TWO_PWR_63_DBL_ = Timestamp2.TWO_PWR_64_DBL_ / 2;
    Timestamp2.ZERO = Timestamp2.fromInt(0);
    Timestamp2.ONE = Timestamp2.fromInt(1);
    Timestamp2.NEG_ONE = Timestamp2.fromInt(-1);
    Timestamp2.MAX_VALUE = Timestamp2.fromBits(4294967295 | 0, 2147483647 | 0);
    Timestamp2.MIN_VALUE = Timestamp2.fromBits(0, 2147483648 | 0);
    Timestamp2.TWO_PWR_24_ = Timestamp2.fromInt(1 << 24);
    module2.exports = Timestamp2;
    module2.exports.Timestamp = Timestamp2;
  }
});

// node_modules/bson/lib/bson/parser/utils.js
var require_utils2 = __commonJS({
  "node_modules/bson/lib/bson/parser/utils.js"(exports2, module2) {
    "use strict";
    function normalizedFunctionString(fn) {
      return fn.toString().replace(/function *\(/, "function (");
    }
    function newBuffer(item, encoding) {
      return new Buffer(item, encoding);
    }
    function allocBuffer() {
      return Buffer.alloc.apply(Buffer, arguments);
    }
    function toBuffer() {
      return Buffer.from.apply(Buffer, arguments);
    }
    module2.exports = {
      normalizedFunctionString,
      allocBuffer: typeof Buffer.alloc === "function" ? allocBuffer : newBuffer,
      toBuffer: typeof Buffer.from === "function" ? toBuffer : newBuffer
    };
  }
});

// node_modules/bson/lib/bson/objectid.js
var require_objectid = __commonJS({
  "node_modules/bson/lib/bson/objectid.js"(exports2, module2) {
    var inspect = "inspect";
    var utils2 = require_utils2();
    var MACHINE_ID = parseInt(Math.random() * 16777215, 10);
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    try {
      if (Buffer && Buffer.from) {
        hasBufferType = true;
        inspect = __require("util").inspect.custom || "inspect";
      }
    } catch (err) {
      hasBufferType = false;
    }
    var hasBufferType;
    var ObjectID2 = function ObjectID3(id) {
      if (id instanceof ObjectID3)
        return id;
      if (!(this instanceof ObjectID3))
        return new ObjectID3(id);
      this._bsontype = "ObjectID";
      if (id == null || typeof id === "number") {
        this.id = this.generate(id);
        if (ObjectID3.cacheHexString)
          this.__id = this.toString("hex");
        return;
      }
      var valid = ObjectID3.isValid(id);
      if (!valid && id != null) {
        throw new Error(
          "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
        );
      } else if (valid && typeof id === "string" && id.length === 24 && hasBufferType) {
        return new ObjectID3(utils2.toBuffer(id, "hex"));
      } else if (valid && typeof id === "string" && id.length === 24) {
        return ObjectID3.createFromHexString(id);
      } else if (id != null && id.length === 12) {
        this.id = id;
      } else if (id != null && typeof id.toHexString === "function") {
        return id;
      } else {
        throw new Error(
          "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
        );
      }
      if (ObjectID3.cacheHexString)
        this.__id = this.toString("hex");
    };
    var hexTable = [];
    for (i = 0; i < 256; i++) {
      hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
    }
    var i;
    ObjectID2.prototype.toHexString = function() {
      if (ObjectID2.cacheHexString && this.__id)
        return this.__id;
      var hexString = "";
      if (!this.id || !this.id.length) {
        throw new Error(
          "invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]"
        );
      }
      if (this.id instanceof _Buffer) {
        hexString = convertToHex(this.id);
        if (ObjectID2.cacheHexString)
          this.__id = hexString;
        return hexString;
      }
      for (var i2 = 0; i2 < this.id.length; i2++) {
        hexString += hexTable[this.id.charCodeAt(i2)];
      }
      if (ObjectID2.cacheHexString)
        this.__id = hexString;
      return hexString;
    };
    ObjectID2.prototype.get_inc = function() {
      return ObjectID2.index = (ObjectID2.index + 1) % 16777215;
    };
    ObjectID2.prototype.getInc = function() {
      return this.get_inc();
    };
    ObjectID2.prototype.generate = function(time) {
      if ("number" !== typeof time) {
        time = ~~(Date.now() / 1e3);
      }
      var pid = (typeof process === "undefined" || process.pid === 1 ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
      var inc = this.get_inc();
      var buffer = utils2.allocBuffer(12);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      buffer[6] = MACHINE_ID & 255;
      buffer[5] = MACHINE_ID >> 8 & 255;
      buffer[4] = MACHINE_ID >> 16 & 255;
      buffer[8] = pid & 255;
      buffer[7] = pid >> 8 & 255;
      buffer[11] = inc & 255;
      buffer[10] = inc >> 8 & 255;
      buffer[9] = inc >> 16 & 255;
      return buffer;
    };
    ObjectID2.prototype.toString = function(format) {
      if (this.id && this.id.copy) {
        return this.id.toString(typeof format === "string" ? format : "hex");
      }
      return this.toHexString();
    };
    ObjectID2.prototype[inspect] = ObjectID2.prototype.toString;
    ObjectID2.prototype.toJSON = function() {
      return this.toHexString();
    };
    ObjectID2.prototype.equals = function equals(otherId) {
      if (otherId instanceof ObjectID2) {
        return this.toString() === otherId.toString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
        return otherId === this.id.toString("binary");
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12) {
        return otherId === this.id;
      } else if (otherId != null && (otherId instanceof ObjectID2 || otherId.toHexString)) {
        return otherId.toHexString() === this.toHexString();
      } else {
        return false;
      }
    };
    ObjectID2.prototype.getTimestamp = function() {
      var timestamp = /* @__PURE__ */ new Date();
      var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      timestamp.setTime(Math.floor(time) * 1e3);
      return timestamp;
    };
    ObjectID2.index = ~~(Math.random() * 16777215);
    ObjectID2.createPk = function createPk() {
      return new ObjectID2();
    };
    ObjectID2.createFromTime = function createFromTime(time) {
      var buffer = utils2.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      return new ObjectID2(buffer);
    };
    var decodeLookup = [];
    i = 0;
    while (i < 10)
      decodeLookup[48 + i] = i++;
    while (i < 16)
      decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
    var _Buffer = Buffer;
    var convertToHex = function(bytes) {
      return bytes.toString("hex");
    };
    ObjectID2.createFromHexString = function createFromHexString(string) {
      if (typeof string === "undefined" || string != null && string.length !== 24) {
        throw new Error(
          "Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"
        );
      }
      if (hasBufferType)
        return new ObjectID2(utils2.toBuffer(string, "hex"));
      var array = new _Buffer(12);
      var n = 0;
      var i2 = 0;
      while (i2 < 24) {
        array[n++] = decodeLookup[string.charCodeAt(i2++)] << 4 | decodeLookup[string.charCodeAt(i2++)];
      }
      return new ObjectID2(array);
    };
    ObjectID2.isValid = function isValid(id) {
      if (id == null)
        return false;
      if (typeof id === "number") {
        return true;
      }
      if (typeof id === "string") {
        return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
      }
      if (id instanceof ObjectID2) {
        return true;
      }
      if (id instanceof _Buffer) {
        return true;
      }
      if (typeof id.toHexString === "function" && (id.id instanceof _Buffer || typeof id.id === "string")) {
        return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
      }
      return false;
    };
    Object.defineProperty(ObjectID2.prototype, "generationTime", {
      enumerable: true,
      get: function() {
        return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      },
      set: function(value2) {
        this.id[3] = value2 & 255;
        this.id[2] = value2 >> 8 & 255;
        this.id[1] = value2 >> 16 & 255;
        this.id[0] = value2 >> 24 & 255;
      }
    });
    module2.exports = ObjectID2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.ObjectId = ObjectID2;
  }
});

// node_modules/bson/lib/bson/regexp.js
var require_regexp = __commonJS({
  "node_modules/bson/lib/bson/regexp.js"(exports2, module2) {
    function BSONRegExp2(pattern, options) {
      if (!(this instanceof BSONRegExp2))
        return new BSONRegExp2();
      this._bsontype = "BSONRegExp";
      this.pattern = pattern || "";
      this.options = options || "";
      for (var i = 0; i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new Error("the regular expression options [" + this.options[i] + "] is not supported");
        }
      }
    }
    module2.exports = BSONRegExp2;
    module2.exports.BSONRegExp = BSONRegExp2;
  }
});

// node_modules/bson/lib/bson/symbol.js
var require_symbol = __commonJS({
  "node_modules/bson/lib/bson/symbol.js"(exports2, module2) {
    var inspect = Buffer ? __require("util").inspect.custom || "inspect" : "inspect";
    function Symbol2(value2) {
      if (!(this instanceof Symbol2))
        return new Symbol2(value2);
      this._bsontype = "Symbol";
      this.value = value2;
    }
    Symbol2.prototype.valueOf = function() {
      return this.value;
    };
    Symbol2.prototype.toString = function() {
      return this.value;
    };
    Symbol2.prototype[inspect] = function() {
      return this.value;
    };
    Symbol2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Symbol2;
    module2.exports.Symbol = Symbol2;
  }
});

// node_modules/bson/lib/bson/int_32.js
var require_int_32 = __commonJS({
  "node_modules/bson/lib/bson/int_32.js"(exports2, module2) {
    var Int322 = function(value2) {
      if (!(this instanceof Int322))
        return new Int322(value2);
      this._bsontype = "Int32";
      this.value = value2;
    };
    Int322.prototype.valueOf = function() {
      return this.value;
    };
    Int322.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Int322;
    module2.exports.Int32 = Int322;
  }
});

// node_modules/bson/lib/bson/code.js
var require_code = __commonJS({
  "node_modules/bson/lib/bson/code.js"(exports2, module2) {
    var Code2 = function Code3(code, scope) {
      if (!(this instanceof Code3))
        return new Code3(code, scope);
      this._bsontype = "Code";
      this.code = code;
      this.scope = scope;
    };
    Code2.prototype.toJSON = function() {
      return { scope: this.scope, code: this.code };
    };
    module2.exports = Code2;
    module2.exports.Code = Code2;
  }
});

// node_modules/bson/lib/bson/decimal128.js
var require_decimal128 = __commonJS({
  "node_modules/bson/lib/bson/decimal128.js"(exports2, module2) {
    "use strict";
    var Long2 = require_long();
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = [
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_NEGATIVE_BUFFER = [
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_POSITIVE_BUFFER = [
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var utils2 = require_utils2();
    var isDigit = function(value2) {
      return !isNaN(parseInt(value2, 10));
    };
    var divideu128 = function(value2) {
      var DIVISOR = Long2.fromNumber(1e3 * 1e3 * 1e3);
      var _rem = Long2.fromNumber(0);
      var i = 0;
      if (!value2.parts[0] && !value2.parts[1] && !value2.parts[2] && !value2.parts[3]) {
        return { quotient: value2, rem: _rem };
      }
      for (i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long2(value2.parts[i], 0));
        value2.parts[i] = _rem.div(DIVISOR).low_;
        _rem = _rem.modulo(DIVISOR);
      }
      return { quotient: value2, rem: _rem };
    };
    var multiply64x2 = function(left, right) {
      if (!left && !right) {
        return { high: Long2.fromNumber(0), low: Long2.fromNumber(0) };
      }
      var leftHigh = left.shiftRightUnsigned(32);
      var leftLow = new Long2(left.getLowBits(), 0);
      var rightHigh = right.shiftRightUnsigned(32);
      var rightLow = new Long2(right.getLowBits(), 0);
      var productHigh = leftHigh.multiply(rightHigh);
      var productMid = leftHigh.multiply(rightLow);
      var productMid2 = leftLow.multiply(rightHigh);
      var productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long2(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long2(productLow.getLowBits(), 0));
      return { high: productHigh, low: productLow };
    };
    var lessThan = function(left, right) {
      var uhleft = left.high_ >>> 0;
      var uhright = right.high_ >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        var ulleft = left.low_ >>> 0;
        var ulright = right.low_ >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    };
    var Decimal1282 = function(bytes) {
      this._bsontype = "Decimal128";
      this.bytes = bytes;
    };
    Decimal1282.fromString = function(string) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = [0, 0];
      var significandLow = [0, 0];
      var biasedExponent = 0;
      var index = 0;
      string = string.trim();
      if (string.length >= 7e3) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      var stringMatch = string.match(PARSE_STRING_REGEXP);
      var infMatch = string.match(PARSE_INF_REGEXP);
      var nanMatch = string.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || string.length === 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (stringMatch && stringMatch[4] && stringMatch[2] === void 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index] === "+" || string[index] === "-") {
        isNegative = string[index++] === "-";
      }
      if (!isDigit(string[index]) && string[index] !== ".") {
        if (string[index] === "i" || string[index] === "I") {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        } else if (string[index] === "N") {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
      }
      while (isDigit(string[index]) || string[index] === ".") {
        if (string[index] === ".") {
          if (sawRadix) {
            return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
          }
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (string[index] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(string[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) {
          nDigits = nDigits + 1;
        }
        if (sawRadix) {
          radixPosition = radixPosition + 1;
        }
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index] === "e" || string[index] === "E") {
        var match = string.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2]) {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (string[index]) {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (exponent !== 0 && significantDigits !== 1) {
          while (string[firstNonZero + significantDigits - 1] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits && string[significantDigits] !== "0") {
        var endOfString = nDigitsRead;
        if (sawRadix && exponent === EXPONENT_MIN) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1;
            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(string[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal1282(
                    utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER)
                  );
                }
              }
            } else {
              break;
            }
          }
        }
      }
      significandHigh = Long2.fromNumber(0);
      significandLow = Long2.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long2.fromNumber(0);
        significandLow = Long2.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        dIdx = firstDigit;
        significandLow = Long2.fromNumber(digits[dIdx++]);
        significandHigh = new Long2(0, 0);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      } else {
        dIdx = firstDigit;
        significandHigh = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long2.fromNumber(10));
          significandHigh = significandHigh.add(Long2.fromNumber(digits[dIdx]));
        }
        significandLow = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      }
      var significand = multiply64x2(significandHigh, Long2.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long2.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec = { low: Long2.fromNumber(0), high: Long2.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long2.fromNumber(1)).equals(Long2.fromNumber)) {
        dec.high = dec.high.or(Long2.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(
          Long2.fromNumber(biasedExponent).and(Long2.fromNumber(16383).shiftLeft(47))
        );
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long2.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long2.fromString("9223372036854775808"));
      }
      var buffer = utils2.allocBuffer(16);
      index = 0;
      buffer[index++] = dec.low.low_ & 255;
      buffer[index++] = dec.low.low_ >> 8 & 255;
      buffer[index++] = dec.low.low_ >> 16 & 255;
      buffer[index++] = dec.low.low_ >> 24 & 255;
      buffer[index++] = dec.low.high_ & 255;
      buffer[index++] = dec.low.high_ >> 8 & 255;
      buffer[index++] = dec.low.high_ >> 16 & 255;
      buffer[index++] = dec.low.high_ >> 24 & 255;
      buffer[index++] = dec.high.low_ & 255;
      buffer[index++] = dec.high.low_ >> 8 & 255;
      buffer[index++] = dec.high.low_ >> 16 & 255;
      buffer[index++] = dec.high.low_ >> 24 & 255;
      buffer[index++] = dec.high.high_ & 255;
      buffer[index++] = dec.high.high_ >> 8 & 255;
      buffer[index++] = dec.high.high_ >> 16 & 255;
      buffer[index++] = dec.high.high_ >> 24 & 255;
      return new Decimal1282(buffer);
    };
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    EXPONENT_BIAS = 6176;
    Decimal1282.prototype.toString = function() {
      var high;
      var midh;
      var midl;
      var low;
      var combination;
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++)
        significand[i] = 0;
      var index = 0;
      var exponent;
      var scientific_exponent;
      var is_zero = false;
      var significand_msb;
      var significand128 = { parts: new Array(4) };
      i;
      var j, k;
      var string = [];
      index = 0;
      var buffer = this.bytes;
      low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      index = 0;
      var dec = {
        low: new Long2(low, midl),
        high: new Long2(midh, high)
      };
      if (dec.high.lessThan(Long2.ZERO)) {
        string.push("-");
      }
      combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low_;
          if (!least_digits)
            continue;
          for (j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        i = 0;
        while (!significand[index]) {
          i++;
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        string.push(significand[index++]);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (i = 0; i < significand_digits; i++) {
          string.push(significand[index++]);
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push("+" + scientific_exponent);
        } else {
          string.push(scientific_exponent);
        }
      } else {
        if (exponent >= 0) {
          for (i = 0; i < significand_digits; i++) {
            string.push(significand[index++]);
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (i = 0; i < radix_position; i++) {
              string.push(significand[index++]);
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(significand[index++]);
          }
        }
      }
      return string.join("");
    };
    Decimal1282.prototype.toJSON = function() {
      return { $numberDecimal: this.toString() };
    };
    module2.exports = Decimal1282;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/lib/bson/min_key.js
var require_min_key = __commonJS({
  "node_modules/bson/lib/bson/min_key.js"(exports2, module2) {
    function MinKey2() {
      if (!(this instanceof MinKey2))
        return new MinKey2();
      this._bsontype = "MinKey";
    }
    module2.exports = MinKey2;
    module2.exports.MinKey = MinKey2;
  }
});

// node_modules/bson/lib/bson/max_key.js
var require_max_key = __commonJS({
  "node_modules/bson/lib/bson/max_key.js"(exports2, module2) {
    function MaxKey2() {
      if (!(this instanceof MaxKey2))
        return new MaxKey2();
      this._bsontype = "MaxKey";
    }
    module2.exports = MaxKey2;
    module2.exports.MaxKey = MaxKey2;
  }
});

// node_modules/bson/lib/bson/db_ref.js
var require_db_ref = __commonJS({
  "node_modules/bson/lib/bson/db_ref.js"(exports2, module2) {
    function DBRef2(namespace, oid, db) {
      if (!(this instanceof DBRef2))
        return new DBRef2(namespace, oid, db);
      this._bsontype = "DBRef";
      this.namespace = namespace;
      this.oid = oid;
      this.db = db;
    }
    DBRef2.prototype.toJSON = function() {
      return {
        $ref: this.namespace,
        $id: this.oid,
        $db: this.db == null ? "" : this.db
      };
    };
    module2.exports = DBRef2;
    module2.exports.DBRef = DBRef2;
  }
});

// node_modules/bson/lib/bson/binary.js
var require_binary = __commonJS({
  "node_modules/bson/lib/bson/binary.js"(exports2, module2) {
    if (typeof global !== "undefined") {
      Buffer2 = __require("buffer").Buffer;
    }
    var Buffer2;
    var utils2 = require_utils2();
    function Binary2(buffer, subType) {
      if (!(this instanceof Binary2))
        return new Binary2(buffer, subType);
      if (buffer != null && !(typeof buffer === "string") && !Buffer2.isBuffer(buffer) && !(buffer instanceof Uint8Array) && !Array.isArray(buffer)) {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
      this._bsontype = "Binary";
      if (buffer instanceof Number) {
        this.sub_type = buffer;
        this.position = 0;
      } else {
        this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
        this.position = 0;
      }
      if (buffer != null && !(buffer instanceof Number)) {
        if (typeof buffer === "string") {
          if (typeof Buffer2 !== "undefined") {
            this.buffer = utils2.toBuffer(buffer);
          } else if (typeof Uint8Array !== "undefined" || Object.prototype.toString.call(buffer) === "[object Array]") {
            this.buffer = writeStringToArray(buffer);
          } else {
            throw new Error("only String, Buffer, Uint8Array or Array accepted");
          }
        } else {
          this.buffer = buffer;
        }
        this.position = buffer.length;
      } else {
        if (typeof Buffer2 !== "undefined") {
          this.buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE);
        } else if (typeof Uint8Array !== "undefined") {
          this.buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE));
        } else {
          this.buffer = new Array(Binary2.BUFFER_SIZE);
        }
        this.position = 0;
      }
    }
    Binary2.prototype.put = function put(byte_value) {
      if (byte_value["length"] != null && typeof byte_value !== "number" && byte_value.length !== 1)
        throw new Error("only accepts single character String, Uint8Array or Array");
      if (typeof byte_value !== "number" && byte_value < 0 || byte_value > 255)
        throw new Error("only accepts number in a valid unsigned byte range 0-255");
      var decoded_byte = null;
      if (typeof byte_value === "string") {
        decoded_byte = byte_value.charCodeAt(0);
      } else if (byte_value["length"] != null) {
        decoded_byte = byte_value[0];
      } else {
        decoded_byte = byte_value;
      }
      if (this.buffer.length > this.position) {
        this.buffer[this.position++] = decoded_byte;
      } else {
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          var buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE + this.buffer.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        } else {
          buffer = null;
          if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
            buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE + this.buffer.length));
          } else {
            buffer = new Array(Binary2.BUFFER_SIZE + this.buffer.length);
          }
          for (var i = 0; i < this.buffer.length; i++) {
            buffer[i] = this.buffer[i];
          }
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        }
      }
    };
    Binary2.prototype.write = function write(string, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.length < offset + string.length) {
        var buffer = null;
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          buffer = utils2.allocBuffer(this.buffer.length + string.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
        } else if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
          buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
          for (var i = 0; i < this.position; i++) {
            buffer[i] = this.buffer[i];
          }
        }
        this.buffer = buffer;
      }
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(string) && Buffer2.isBuffer(this.buffer)) {
        string.copy(this.buffer, offset, 0, string.length);
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (typeof Buffer2 !== "undefined" && typeof string === "string" && Buffer2.isBuffer(this.buffer)) {
        this.buffer.write(string, offset, "binary");
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (Object.prototype.toString.call(string) === "[object Uint8Array]" || Object.prototype.toString.call(string) === "[object Array]" && typeof string !== "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string[i];
        }
        this.position = offset > this.position ? offset : this.position;
      } else if (typeof string === "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string.charCodeAt(i);
        }
        this.position = offset > this.position ? offset : this.position;
      }
    };
    Binary2.prototype.read = function read(position, length) {
      length = length && length > 0 ? length : this.position;
      if (this.buffer["slice"]) {
        return this.buffer.slice(position, position + length);
      } else {
        var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
        for (var i = 0; i < length; i++) {
          buffer[i] = this.buffer[position++];
        }
      }
      return buffer;
    };
    Binary2.prototype.value = function value2(asRaw) {
      asRaw = asRaw == null ? false : asRaw;
      if (asRaw && typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer) && this.buffer.length === this.position)
        return this.buffer;
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString("binary", 0, this.position);
      } else {
        if (asRaw) {
          if (this.buffer["slice"] != null) {
            return this.buffer.slice(0, this.position);
          } else {
            var newBuffer = Object.prototype.toString.call(this.buffer) === "[object Uint8Array]" ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
            for (var i = 0; i < this.position; i++) {
              newBuffer[i] = this.buffer[i];
            }
            return newBuffer;
          }
        } else {
          return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
        }
      }
    };
    Binary2.prototype.length = function length() {
      return this.position;
    };
    Binary2.prototype.toJSON = function() {
      return this.buffer != null ? this.buffer.toString("base64") : "";
    };
    Binary2.prototype.toString = function(format) {
      return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : "";
    };
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var writeStringToArray = function(data) {
      var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        buffer[i] = data.charCodeAt(i);
      }
      return buffer;
    };
    var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
      var result = "";
      for (var i = startIndex; i < endIndex; i++) {
        result = result + String.fromCharCode(byteArray[i]);
      }
      return result;
    };
    Binary2.BUFFER_SIZE = 256;
    Binary2.SUBTYPE_DEFAULT = 0;
    Binary2.SUBTYPE_FUNCTION = 1;
    Binary2.SUBTYPE_BYTE_ARRAY = 2;
    Binary2.SUBTYPE_UUID_OLD = 3;
    Binary2.SUBTYPE_UUID = 4;
    Binary2.SUBTYPE_MD5 = 5;
    Binary2.SUBTYPE_USER_DEFINED = 128;
    module2.exports = Binary2;
    module2.exports.Binary = Binary2;
  }
});

// node_modules/bson/lib/bson/parser/deserializer.js
var require_deserializer = __commonJS({
  "node_modules/bson/lib/bson/parser/deserializer.js"(exports, module) {
    "use strict";
    var Long = require_long().Long;
    var Double = require_double().Double;
    var Timestamp = require_timestamp().Timestamp;
    var ObjectID = require_objectid().ObjectID;
    var Symbol = require_symbol().Symbol;
    var Code = require_code().Code;
    var MinKey = require_min_key().MinKey;
    var MaxKey = require_max_key().MaxKey;
    var Decimal128 = require_decimal128();
    var Int32 = require_int_32();
    var DBRef = require_db_ref().DBRef;
    var BSONRegExp = require_regexp().BSONRegExp;
    var Binary = require_binary().Binary;
    var utils = require_utils2();
    var deserialize = function(buffer, options, isArray) {
      options = options == null ? {} : options;
      var index = options && options.index ? options.index : 0;
      var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
      if (size < 5 || buffer.length < size || size + index > buffer.length) {
        throw new Error("corrupt bson message");
      }
      if (buffer[index + size - 1] !== 0) {
        throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer, index, options, isArray);
    };
    var deserializeObject = function(buffer, index, options, isArray) {
      var evalFunctions = options["evalFunctions"] == null ? false : options["evalFunctions"];
      var cacheFunctions = options["cacheFunctions"] == null ? false : options["cacheFunctions"];
      var cacheFunctionsCrc32 = options["cacheFunctionsCrc32"] == null ? false : options["cacheFunctionsCrc32"];
      if (!cacheFunctionsCrc32)
        var crc32 = null;
      var fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
      var raw = options["raw"] == null ? false : options["raw"];
      var bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
      var promoteBuffers = options["promoteBuffers"] == null ? false : options["promoteBuffers"];
      var promoteLongs = options["promoteLongs"] == null ? true : options["promoteLongs"];
      var promoteValues = options["promoteValues"] == null ? true : options["promoteValues"];
      var startIndex = index;
      if (buffer.length < 5)
        throw new Error("corrupt bson message < 5 bytes long");
      var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (size < 5 || size > buffer.length)
        throw new Error("corrupt bson message");
      var object2 = isArray ? [] : {};
      var arrayIndex = 0;
      var done = false;
      while (!done) {
        var elementType = buffer[index++];
        if (elementType === 0)
          break;
        var i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        var name = isArray ? arrayIndex++ : buffer.toString("utf8", index, i);
        index = i + 1;
        if (elementType === BSON.BSON_DATA_STRING) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object2[name] = buffer.toString("utf8", index, index + stringSize - 1);
          index = index + stringSize;
        } else if (elementType === BSON.BSON_DATA_OID) {
          var oid = utils.allocBuffer(12);
          buffer.copy(oid, 0, index, index + 12);
          object2[name] = new ObjectID(oid);
          index = index + 12;
        } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {
          object2[name] = new Int32(
            buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24
          );
        } else if (elementType === BSON.BSON_DATA_INT) {
          object2[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {
          object2[name] = new Double(buffer.readDoubleLE(index));
          index = index + 8;
        } else if (elementType === BSON.BSON_DATA_NUMBER) {
          object2[name] = buffer.readDoubleLE(index);
          index = index + 8;
        } else if (elementType === BSON.BSON_DATA_DATE) {
          var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          object2[name] = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType === BSON.BSON_DATA_BOOLEAN) {
          if (buffer[index] !== 0 && buffer[index] !== 1)
            throw new Error("illegal boolean type value");
          object2[name] = buffer[index++] === 1;
        } else if (elementType === BSON.BSON_DATA_OBJECT) {
          var _index = index;
          var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          if (objectSize <= 0 || objectSize > buffer.length - index)
            throw new Error("bad embedded document length in bson");
          if (raw) {
            object2[name] = buffer.slice(index, index + objectSize);
          } else {
            object2[name] = deserializeObject(buffer, _index, options, false);
          }
          index = index + objectSize;
        } else if (elementType === BSON.BSON_DATA_ARRAY) {
          _index = index;
          objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          var arrayOptions = options;
          var stopIndex = index + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name]) {
            arrayOptions = {};
            for (var n in options)
              arrayOptions[n] = options[n];
            arrayOptions["raw"] = true;
          }
          object2[name] = deserializeObject(buffer, _index, arrayOptions, true);
          index = index + objectSize;
          if (buffer[index - 1] !== 0)
            throw new Error("invalid array terminator byte");
          if (index !== stopIndex)
            throw new Error("corrupted array bson");
        } else if (elementType === BSON.BSON_DATA_UNDEFINED) {
          object2[name] = void 0;
        } else if (elementType === BSON.BSON_DATA_NULL) {
          object2[name] = null;
        } else if (elementType === BSON.BSON_DATA_LONG) {
          lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            object2[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            object2[name] = long;
          }
        } else if (elementType === BSON.BSON_DATA_DECIMAL128) {
          var bytes = utils.allocBuffer(16);
          buffer.copy(bytes, 0, index, index + 16);
          index = index + 16;
          var decimal128 = new Decimal128(bytes);
          object2[name] = decimal128.toObject ? decimal128.toObject() : decimal128;
        } else if (elementType === BSON.BSON_DATA_BINARY) {
          var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var totalBinarySize = binarySize;
          var subType = buffer[index++];
          if (binarySize < 0)
            throw new Error("Negative binary type element size found");
          if (binarySize > buffer.length)
            throw new Error("Binary type size larger than document size");
          if (buffer["slice"] != null) {
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            if (promoteBuffers && promoteValues) {
              object2[name] = buffer.slice(index, index + binarySize);
            } else {
              object2[name] = new Binary(buffer.slice(index, index + binarySize), subType);
            }
          } else {
            var _buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            for (i = 0; i < binarySize; i++) {
              _buffer[i] = buffer[index + i];
            }
            if (promoteBuffers && promoteValues) {
              object2[name] = _buffer;
            } else {
              object2[name] = new Binary(_buffer, subType);
            }
          }
          index = index + binarySize;
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var source = buffer.toString("utf8", index, i);
          index = i + 1;
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var regExpOptions = buffer.toString("utf8", index, i);
          index = i + 1;
          var optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          object2[name] = new RegExp(source, optionsArray.join(""));
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          source = buffer.toString("utf8", index, i);
          index = i + 1;
          i = index;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          regExpOptions = buffer.toString("utf8", index, i);
          index = i + 1;
          object2[name] = new BSONRegExp(source, regExpOptions);
        } else if (elementType === BSON.BSON_DATA_SYMBOL) {
          stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object2[name] = new Symbol(buffer.toString("utf8", index, index + stringSize - 1));
          index = index + stringSize;
        } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {
          lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          object2[name] = new Timestamp(lowBits, highBits);
        } else if (elementType === BSON.BSON_DATA_MIN_KEY) {
          object2[name] = new MinKey();
        } else if (elementType === BSON.BSON_DATA_MAX_KEY) {
          object2[name] = new MaxKey();
        } else if (elementType === BSON.BSON_DATA_CODE) {
          stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var functionString2 = buffer.toString("utf8", index, index + stringSize - 1);
          if (evalFunctions) {
            if (cacheFunctions) {
              var hash2 = cacheFunctionsCrc32 ? crc32(functionString2) : functionString2;
              object2[name] = isolateEvalWithHash(functionCache, hash2, functionString2, object2);
            } else {
              object2[name] = isolateEval(functionString2);
            }
          } else {
            object2[name] = new Code(functionString2);
          }
          index = index + stringSize;
        } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {
          var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new Error("code_w_scope total size shorter minimum expected length");
          }
          stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          functionString2 = buffer.toString("utf8", index, index + stringSize - 1);
          index = index + stringSize;
          _index = index;
          objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          var scopeObject = deserializeObject(buffer, _index, options, false);
          index = index + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to long, clips outer document");
          }
          if (evalFunctions) {
            if (cacheFunctions) {
              hash2 = cacheFunctionsCrc32 ? crc32(functionString2) : functionString2;
              object2[name] = isolateEvalWithHash(functionCache, hash2, functionString2, object2);
            } else {
              object2[name] = isolateEval(functionString2);
            }
            object2[name].scope = scopeObject;
          } else {
            object2[name] = new Code(functionString2, scopeObject);
          }
        } else if (elementType === BSON.BSON_DATA_DBPOINTER) {
          stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var namespace = buffer.toString("utf8", index, index + stringSize - 1);
          index = index + stringSize;
          var oidBuffer = utils.allocBuffer(12);
          buffer.copy(oidBuffer, 0, index, index + 12);
          oid = new ObjectID(oidBuffer);
          index = index + 12;
          var parts = namespace.split(".");
          var db = parts.shift();
          var collection = parts.join(".");
          object2[name] = new DBRef(collection, oid, db);
        } else {
          throw new Error(
            "Detected unknown BSON type " + elementType.toString(16) + ' for fieldname "' + name + '", are you using the latest BSON parser'
          );
        }
      }
      if (size !== index - startIndex) {
        if (isArray)
          throw new Error("corrupt array bson");
        throw new Error("corrupt object bson");
      }
      if (object2["$id"] != null)
        object2 = new DBRef(object2["$ref"], object2["$id"], object2["$db"]);
      return object2;
    };
    var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
      var value = null;
      if (functionCache[hash] == null) {
        eval("value = " + functionString);
        functionCache[hash] = value;
      }
      return functionCache[hash].bind(object);
    };
    var isolateEval = function(functionString) {
      var value = null;
      eval("value = " + functionString);
      return value;
    };
    var BSON = {};
    var functionCache = BSON.functionCache = {};
    BSON.BSON_DATA_NUMBER = 1;
    BSON.BSON_DATA_STRING = 2;
    BSON.BSON_DATA_OBJECT = 3;
    BSON.BSON_DATA_ARRAY = 4;
    BSON.BSON_DATA_BINARY = 5;
    BSON.BSON_DATA_UNDEFINED = 6;
    BSON.BSON_DATA_OID = 7;
    BSON.BSON_DATA_BOOLEAN = 8;
    BSON.BSON_DATA_DATE = 9;
    BSON.BSON_DATA_NULL = 10;
    BSON.BSON_DATA_REGEXP = 11;
    BSON.BSON_DATA_DBPOINTER = 12;
    BSON.BSON_DATA_CODE = 13;
    BSON.BSON_DATA_SYMBOL = 14;
    BSON.BSON_DATA_CODE_W_SCOPE = 15;
    BSON.BSON_DATA_INT = 16;
    BSON.BSON_DATA_TIMESTAMP = 17;
    BSON.BSON_DATA_LONG = 18;
    BSON.BSON_DATA_DECIMAL128 = 19;
    BSON.BSON_DATA_MIN_KEY = 255;
    BSON.BSON_DATA_MAX_KEY = 127;
    BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON.BSON_INT32_MAX = 2147483647;
    BSON.BSON_INT32_MIN = -2147483648;
    BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON.JS_INT_MAX = 9007199254740992;
    BSON.JS_INT_MIN = -9007199254740992;
    var JS_INT_MAX_LONG = Long.fromNumber(9007199254740992);
    var JS_INT_MIN_LONG = Long.fromNumber(-9007199254740992);
    module.exports = deserialize;
  }
});

// node_modules/bson/lib/bson/float_parser.js
var require_float_parser = __commonJS({
  "node_modules/bson/lib/bson/float_parser.js"(exports2) {
    var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
      var e, m, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = bBE ? 0 : nBytes - 1, d = bBE ? 1 : -1, s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    var writeIEEE754 = function(buffer, value2, offset, endian, mLen, nBytes) {
      var e, m, c, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = bBE ? nBytes - 1 : 0, d = bBE ? -1 : 1, s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m = isNaN(value2) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value2 += rt / c;
        } else {
          value2 += rt * Math.pow(2, 1 - eBias);
        }
        if (value2 * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value2 * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8)
        ;
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8)
        ;
      buffer[offset + i - d] |= s * 128;
    };
    exports2.readIEEE754 = readIEEE754;
    exports2.writeIEEE754 = writeIEEE754;
  }
});

// node_modules/bson/lib/bson/parser/serializer.js
var require_serializer = __commonJS({
  "node_modules/bson/lib/bson/parser/serializer.js"(exports2, module2) {
    "use strict";
    var writeIEEE754 = require_float_parser().writeIEEE754;
    var Long2 = require_long().Long;
    var Map2 = require_map();
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils2().normalizedFunctionString;
    var regexp = /\x00/;
    var ignoreKeys = ["$db", "$ref", "$id", "$clusterTime"];
    var isDate = function isDate2(d) {
      return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
    };
    var isRegExp = function isRegExp2(d) {
      return Object.prototype.toString.call(d) === "[object RegExp]";
    };
    var serializeString = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_STRING;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      var size = buffer.write(value2, index + 4, "utf8");
      buffer[index + 3] = size + 1 >> 24 & 255;
      buffer[index + 2] = size + 1 >> 16 & 255;
      buffer[index + 1] = size + 1 >> 8 & 255;
      buffer[index] = size + 1 & 255;
      index = index + 4 + size;
      buffer[index++] = 0;
      return index;
    };
    var serializeNumber = function(buffer, key, value2, index, isArray) {
      if (Math.floor(value2) === value2 && value2 >= BSON2.JS_INT_MIN && value2 <= BSON2.JS_INT_MAX) {
        if (value2 >= BSON2.BSON_INT32_MIN && value2 <= BSON2.BSON_INT32_MAX) {
          buffer[index++] = BSON2.BSON_DATA_INT;
          var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
          index = index + numberOfWrittenBytes;
          buffer[index++] = 0;
          buffer[index++] = value2 & 255;
          buffer[index++] = value2 >> 8 & 255;
          buffer[index++] = value2 >> 16 & 255;
          buffer[index++] = value2 >> 24 & 255;
        } else if (value2 >= BSON2.JS_INT_MIN && value2 <= BSON2.JS_INT_MAX) {
          buffer[index++] = BSON2.BSON_DATA_NUMBER;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
          index = index + numberOfWrittenBytes;
          buffer[index++] = 0;
          writeIEEE754(buffer, value2, index, "little", 52, 8);
          index = index + 8;
        } else {
          buffer[index++] = BSON2.BSON_DATA_LONG;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
          index = index + numberOfWrittenBytes;
          buffer[index++] = 0;
          var longVal = Long2.fromNumber(value2);
          var lowBits = longVal.getLowBits();
          var highBits = longVal.getHighBits();
          buffer[index++] = lowBits & 255;
          buffer[index++] = lowBits >> 8 & 255;
          buffer[index++] = lowBits >> 16 & 255;
          buffer[index++] = lowBits >> 24 & 255;
          buffer[index++] = highBits & 255;
          buffer[index++] = highBits >> 8 & 255;
          buffer[index++] = highBits >> 16 & 255;
          buffer[index++] = highBits >> 24 & 255;
        }
      } else {
        buffer[index++] = BSON2.BSON_DATA_NUMBER;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        writeIEEE754(buffer, value2, index, "little", 52, 8);
        index = index + 8;
      }
      return index;
    };
    var serializeNull = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_NULL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      return index;
    };
    var serializeBoolean = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_BOOLEAN;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value2 ? 1 : 0;
      return index;
    };
    var serializeDate = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_DATE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var dateInMilis = Long2.fromNumber(value2.getTime());
      var lowBits = dateInMilis.getLowBits();
      var highBits = dateInMilis.getHighBits();
      buffer[index++] = lowBits & 255;
      buffer[index++] = lowBits >> 8 & 255;
      buffer[index++] = lowBits >> 16 & 255;
      buffer[index++] = lowBits >> 24 & 255;
      buffer[index++] = highBits & 255;
      buffer[index++] = highBits >> 8 & 255;
      buffer[index++] = highBits >> 16 & 255;
      buffer[index++] = highBits >> 24 & 255;
      return index;
    };
    var serializeRegExp = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (value2.source && value2.source.match(regexp) != null) {
        throw Error("value " + value2.source + " must not contain null bytes");
      }
      index = index + buffer.write(value2.source, index, "utf8");
      buffer[index++] = 0;
      if (value2.global)
        buffer[index++] = 115;
      if (value2.ignoreCase)
        buffer[index++] = 105;
      if (value2.multiline)
        buffer[index++] = 109;
      buffer[index++] = 0;
      return index;
    };
    var serializeBSONRegExp = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (value2.pattern.match(regexp) != null) {
        throw Error("pattern " + value2.pattern + " must not contain null bytes");
      }
      index = index + buffer.write(value2.pattern, index, "utf8");
      buffer[index++] = 0;
      index = index + buffer.write(
        value2.options.split("").sort().join(""),
        index,
        "utf8"
      );
      buffer[index++] = 0;
      return index;
    };
    var serializeMinMax = function(buffer, key, value2, index, isArray) {
      if (value2 === null) {
        buffer[index++] = BSON2.BSON_DATA_NULL;
      } else if (value2._bsontype === "MinKey") {
        buffer[index++] = BSON2.BSON_DATA_MIN_KEY;
      } else {
        buffer[index++] = BSON2.BSON_DATA_MAX_KEY;
      }
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      return index;
    };
    var serializeObjectId = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_OID;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (typeof value2.id === "string") {
        buffer.write(value2.id, index, "binary");
      } else if (value2.id && value2.id.copy) {
        value2.id.copy(buffer, index, 0, 12);
      } else {
        throw new Error("object [" + JSON.stringify(value2) + "] is not a valid ObjectId");
      }
      return index + 12;
    };
    var serializeBuffer = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var size = value2.length;
      buffer[index++] = size & 255;
      buffer[index++] = size >> 8 & 255;
      buffer[index++] = size >> 16 & 255;
      buffer[index++] = size >> 24 & 255;
      buffer[index++] = BSON2.BSON_BINARY_SUBTYPE_DEFAULT;
      value2.copy(buffer, index, 0, size);
      index = index + size;
      return index;
    };
    var serializeObject = function(buffer, key, value2, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path2) {
      for (var i = 0; i < path2.length; i++) {
        if (path2[i] === value2)
          throw new Error("cyclic dependency detected");
      }
      path2.push(value2);
      buffer[index++] = Array.isArray(value2) ? BSON2.BSON_DATA_ARRAY : BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var endIndex = serializeInto(
        buffer,
        value2,
        checkKeys,
        index,
        depth + 1,
        serializeFunctions,
        ignoreUndefined,
        path2
      );
      path2.pop();
      return endIndex;
    };
    var serializeDecimal128 = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_DECIMAL128;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      value2.bytes.copy(buffer, index, 0, 16);
      return index + 16;
    };
    var serializeLong = function(buffer, key, value2, index, isArray) {
      buffer[index++] = value2._bsontype === "Long" ? BSON2.BSON_DATA_LONG : BSON2.BSON_DATA_TIMESTAMP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var lowBits = value2.getLowBits();
      var highBits = value2.getHighBits();
      buffer[index++] = lowBits & 255;
      buffer[index++] = lowBits >> 8 & 255;
      buffer[index++] = lowBits >> 16 & 255;
      buffer[index++] = lowBits >> 24 & 255;
      buffer[index++] = highBits & 255;
      buffer[index++] = highBits >> 8 & 255;
      buffer[index++] = highBits >> 16 & 255;
      buffer[index++] = highBits >> 24 & 255;
      return index;
    };
    var serializeInt32 = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value2 & 255;
      buffer[index++] = value2 >> 8 & 255;
      buffer[index++] = value2 >> 16 & 255;
      buffer[index++] = value2 >> 24 & 255;
      return index;
    };
    var serializeDouble = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_NUMBER;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      writeIEEE754(buffer, value2, index, "little", 52, 8);
      index = index + 8;
      return index;
    };
    var serializeFunction = function(buffer, key, value2, index, checkKeys, depth, isArray) {
      buffer[index++] = BSON2.BSON_DATA_CODE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var functionString2 = normalizedFunctionString(value2);
      var size = buffer.write(functionString2, index + 4, "utf8") + 1;
      buffer[index] = size & 255;
      buffer[index + 1] = size >> 8 & 255;
      buffer[index + 2] = size >> 16 & 255;
      buffer[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
      return index;
    };
    var serializeCode = function(buffer, key, value2, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
      if (value2.scope && typeof value2.scope === "object") {
        buffer[index++] = BSON2.BSON_DATA_CODE_W_SCOPE;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        var startIndex = index;
        var functionString2 = typeof value2.code === "string" ? value2.code : value2.code.toString();
        index = index + 4;
        var codeSize = buffer.write(functionString2, index + 4, "utf8") + 1;
        buffer[index] = codeSize & 255;
        buffer[index + 1] = codeSize >> 8 & 255;
        buffer[index + 2] = codeSize >> 16 & 255;
        buffer[index + 3] = codeSize >> 24 & 255;
        buffer[index + 4 + codeSize - 1] = 0;
        index = index + codeSize + 4;
        var endIndex = serializeInto(
          buffer,
          value2.scope,
          checkKeys,
          index,
          depth + 1,
          serializeFunctions,
          ignoreUndefined
        );
        index = endIndex - 1;
        var totalSize = endIndex - startIndex;
        buffer[startIndex++] = totalSize & 255;
        buffer[startIndex++] = totalSize >> 8 & 255;
        buffer[startIndex++] = totalSize >> 16 & 255;
        buffer[startIndex++] = totalSize >> 24 & 255;
        buffer[index++] = 0;
      } else {
        buffer[index++] = BSON2.BSON_DATA_CODE;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        functionString2 = value2.code.toString();
        var size = buffer.write(functionString2, index + 4, "utf8") + 1;
        buffer[index] = size & 255;
        buffer[index + 1] = size >> 8 & 255;
        buffer[index + 2] = size >> 16 & 255;
        buffer[index + 3] = size >> 24 & 255;
        index = index + 4 + size - 1;
        buffer[index++] = 0;
      }
      return index;
    };
    var serializeBinary = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var data = value2.value(true);
      var size = value2.position;
      if (value2.sub_type === Binary2.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      buffer[index++] = size & 255;
      buffer[index++] = size >> 8 & 255;
      buffer[index++] = size >> 16 & 255;
      buffer[index++] = size >> 24 & 255;
      buffer[index++] = value2.sub_type;
      if (value2.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        buffer[index++] = size & 255;
        buffer[index++] = size >> 8 & 255;
        buffer[index++] = size >> 16 & 255;
        buffer[index++] = size >> 24 & 255;
      }
      data.copy(buffer, index, 0, value2.position);
      index = index + value2.position;
      return index;
    };
    var serializeSymbol = function(buffer, key, value2, index, isArray) {
      buffer[index++] = BSON2.BSON_DATA_SYMBOL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var size = buffer.write(value2.value, index + 4, "utf8") + 1;
      buffer[index] = size & 255;
      buffer[index + 1] = size >> 8 & 255;
      buffer[index + 2] = size >> 16 & 255;
      buffer[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
      return index;
    };
    var serializeDBRef = function(buffer, key, value2, index, depth, serializeFunctions, isArray) {
      buffer[index++] = BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, "utf8") : buffer.write(key, index, "ascii");
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var startIndex = index;
      var endIndex;
      if (null != value2.db) {
        endIndex = serializeInto(
          buffer,
          {
            $ref: value2.namespace,
            $id: value2.oid,
            $db: value2.db
          },
          false,
          index,
          depth + 1,
          serializeFunctions
        );
      } else {
        endIndex = serializeInto(
          buffer,
          {
            $ref: value2.namespace,
            $id: value2.oid
          },
          false,
          index,
          depth + 1,
          serializeFunctions
        );
      }
      var size = endIndex - startIndex;
      buffer[startIndex++] = size & 255;
      buffer[startIndex++] = size >> 8 & 255;
      buffer[startIndex++] = size >> 16 & 255;
      buffer[startIndex++] = size >> 24 & 255;
      return endIndex;
    };
    var serializeInto = function serializeInto2(buffer, object2, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path2) {
      startingIndex = startingIndex || 0;
      path2 = path2 || [];
      path2.push(object2);
      var index = startingIndex + 4;
      if (Array.isArray(object2)) {
        for (var i = 0; i < object2.length; i++) {
          var key = "" + i;
          var value2 = object2[i];
          if (value2 && value2.toBSON) {
            if (typeof value2.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value2 = value2.toBSON();
          }
          var type = typeof value2;
          if (type === "string") {
            index = serializeString(buffer, key, value2, index, true);
          } else if (type === "number") {
            index = serializeNumber(buffer, key, value2, index, true);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index = serializeBoolean(buffer, key, value2, index, true);
          } else if (value2 instanceof Date || isDate(value2)) {
            index = serializeDate(buffer, key, value2, index, true);
          } else if (value2 === void 0) {
            index = serializeNull(buffer, key, value2, index, true);
          } else if (value2 === null) {
            index = serializeNull(buffer, key, value2, index, true);
          } else if (value2["_bsontype"] === "ObjectID" || value2["_bsontype"] === "ObjectId") {
            index = serializeObjectId(buffer, key, value2, index, true);
          } else if (Buffer.isBuffer(value2)) {
            index = serializeBuffer(buffer, key, value2, index, true);
          } else if (value2 instanceof RegExp || isRegExp(value2)) {
            index = serializeRegExp(buffer, key, value2, index, true);
          } else if (type === "object" && value2["_bsontype"] == null) {
            index = serializeObject(
              buffer,
              key,
              value2,
              index,
              checkKeys,
              depth,
              serializeFunctions,
              ignoreUndefined,
              true,
              path2
            );
          } else if (type === "object" && value2["_bsontype"] === "Decimal128") {
            index = serializeDecimal128(buffer, key, value2, index, true);
          } else if (value2["_bsontype"] === "Long" || value2["_bsontype"] === "Timestamp") {
            index = serializeLong(buffer, key, value2, index, true);
          } else if (value2["_bsontype"] === "Double") {
            index = serializeDouble(buffer, key, value2, index, true);
          } else if (typeof value2 === "function" && serializeFunctions) {
            index = serializeFunction(
              buffer,
              key,
              value2,
              index,
              checkKeys,
              depth,
              serializeFunctions,
              true
            );
          } else if (value2["_bsontype"] === "Code") {
            index = serializeCode(
              buffer,
              key,
              value2,
              index,
              checkKeys,
              depth,
              serializeFunctions,
              ignoreUndefined,
              true
            );
          } else if (value2["_bsontype"] === "Binary") {
            index = serializeBinary(buffer, key, value2, index, true);
          } else if (value2["_bsontype"] === "Symbol") {
            index = serializeSymbol(buffer, key, value2, index, true);
          } else if (value2["_bsontype"] === "DBRef") {
            index = serializeDBRef(buffer, key, value2, index, depth, serializeFunctions, true);
          } else if (value2["_bsontype"] === "BSONRegExp") {
            index = serializeBSONRegExp(buffer, key, value2, index, true);
          } else if (value2["_bsontype"] === "Int32") {
            index = serializeInt32(buffer, key, value2, index, true);
          } else if (value2["_bsontype"] === "MinKey" || value2["_bsontype"] === "MaxKey") {
            index = serializeMinMax(buffer, key, value2, index, true);
          } else if (typeof value2["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value2["_bsontype"]);
          }
        }
      } else if (object2 instanceof Map2) {
        var iterator = object2.entries();
        var done = false;
        while (!done) {
          var entry = iterator.next();
          done = entry.done;
          if (done)
            continue;
          key = entry.value[0];
          value2 = entry.value[1];
          type = typeof value2;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index = serializeString(buffer, key, value2, index);
          } else if (type === "number") {
            index = serializeNumber(buffer, key, value2, index);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index = serializeBoolean(buffer, key, value2, index);
          } else if (value2 instanceof Date || isDate(value2)) {
            index = serializeDate(buffer, key, value2, index);
          } else if (value2 === null || value2 === void 0 && ignoreUndefined === false) {
            index = serializeNull(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "ObjectID" || value2["_bsontype"] === "ObjectId") {
            index = serializeObjectId(buffer, key, value2, index);
          } else if (Buffer.isBuffer(value2)) {
            index = serializeBuffer(buffer, key, value2, index);
          } else if (value2 instanceof RegExp || isRegExp(value2)) {
            index = serializeRegExp(buffer, key, value2, index);
          } else if (type === "object" && value2["_bsontype"] == null) {
            index = serializeObject(
              buffer,
              key,
              value2,
              index,
              checkKeys,
              depth,
              serializeFunctions,
              ignoreUndefined,
              false,
              path2
            );
          } else if (type === "object" && value2["_bsontype"] === "Decimal128") {
            index = serializeDecimal128(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Long" || value2["_bsontype"] === "Timestamp") {
            index = serializeLong(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Double") {
            index = serializeDouble(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Code") {
            index = serializeCode(
              buffer,
              key,
              value2,
              index,
              checkKeys,
              depth,
              serializeFunctions,
              ignoreUndefined
            );
          } else if (typeof value2 === "function" && serializeFunctions) {
            index = serializeFunction(buffer, key, value2, index, checkKeys, depth, serializeFunctions);
          } else if (value2["_bsontype"] === "Binary") {
            index = serializeBinary(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Symbol") {
            index = serializeSymbol(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "DBRef") {
            index = serializeDBRef(buffer, key, value2, index, depth, serializeFunctions);
          } else if (value2["_bsontype"] === "BSONRegExp") {
            index = serializeBSONRegExp(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Int32") {
            index = serializeInt32(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "MinKey" || value2["_bsontype"] === "MaxKey") {
            index = serializeMinMax(buffer, key, value2, index);
          } else if (typeof value2["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value2["_bsontype"]);
          }
        }
      } else {
        if (object2.toBSON) {
          if (typeof object2.toBSON !== "function")
            throw new Error("toBSON is not a function");
          object2 = object2.toBSON();
          if (object2 != null && typeof object2 !== "object")
            throw new Error("toBSON function did not return an object");
        }
        for (key in object2) {
          value2 = object2[key];
          if (value2 && value2.toBSON) {
            if (typeof value2.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value2 = value2.toBSON();
          }
          type = typeof value2;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index = serializeString(buffer, key, value2, index);
          } else if (type === "number") {
            index = serializeNumber(buffer, key, value2, index);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index = serializeBoolean(buffer, key, value2, index);
          } else if (value2 instanceof Date || isDate(value2)) {
            index = serializeDate(buffer, key, value2, index);
          } else if (value2 === void 0) {
            if (ignoreUndefined === false)
              index = serializeNull(buffer, key, value2, index);
          } else if (value2 === null) {
            index = serializeNull(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "ObjectID" || value2["_bsontype"] === "ObjectId") {
            index = serializeObjectId(buffer, key, value2, index);
          } else if (Buffer.isBuffer(value2)) {
            index = serializeBuffer(buffer, key, value2, index);
          } else if (value2 instanceof RegExp || isRegExp(value2)) {
            index = serializeRegExp(buffer, key, value2, index);
          } else if (type === "object" && value2["_bsontype"] == null) {
            index = serializeObject(
              buffer,
              key,
              value2,
              index,
              checkKeys,
              depth,
              serializeFunctions,
              ignoreUndefined,
              false,
              path2
            );
          } else if (type === "object" && value2["_bsontype"] === "Decimal128") {
            index = serializeDecimal128(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Long" || value2["_bsontype"] === "Timestamp") {
            index = serializeLong(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Double") {
            index = serializeDouble(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Code") {
            index = serializeCode(
              buffer,
              key,
              value2,
              index,
              checkKeys,
              depth,
              serializeFunctions,
              ignoreUndefined
            );
          } else if (typeof value2 === "function" && serializeFunctions) {
            index = serializeFunction(buffer, key, value2, index, checkKeys, depth, serializeFunctions);
          } else if (value2["_bsontype"] === "Binary") {
            index = serializeBinary(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Symbol") {
            index = serializeSymbol(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "DBRef") {
            index = serializeDBRef(buffer, key, value2, index, depth, serializeFunctions);
          } else if (value2["_bsontype"] === "BSONRegExp") {
            index = serializeBSONRegExp(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "Int32") {
            index = serializeInt32(buffer, key, value2, index);
          } else if (value2["_bsontype"] === "MinKey" || value2["_bsontype"] === "MaxKey") {
            index = serializeMinMax(buffer, key, value2, index);
          } else if (typeof value2["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value2["_bsontype"]);
          }
        }
      }
      path2.pop();
      buffer[index++] = 0;
      var size = index - startingIndex;
      buffer[startingIndex++] = size & 255;
      buffer[startingIndex++] = size >> 8 & 255;
      buffer[startingIndex++] = size >> 16 & 255;
      buffer[startingIndex++] = size >> 24 & 255;
      return index;
    };
    var BSON2 = {};
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_UNDEFINED = 6;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_DECIMAL128 = 19;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = serializeInto;
  }
});

// node_modules/bson/lib/bson/parser/calculate_size.js
var require_calculate_size = __commonJS({
  "node_modules/bson/lib/bson/parser/calculate_size.js"(exports2, module2) {
    "use strict";
    var Long2 = require_long().Long;
    var Double2 = require_double().Double;
    var Timestamp2 = require_timestamp().Timestamp;
    var ObjectID2 = require_objectid().ObjectID;
    var Symbol2 = require_symbol().Symbol;
    var BSONRegExp2 = require_regexp().BSONRegExp;
    var Code2 = require_code().Code;
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key().MinKey;
    var MaxKey2 = require_max_key().MaxKey;
    var DBRef2 = require_db_ref().DBRef;
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils2().normalizedFunctionString;
    var isDate = function isDate2(d) {
      return typeof d === "object" && Object.prototype.toString.call(d) === "[object Date]";
    };
    var calculateObjectSize = function calculateObjectSize2(object2, serializeFunctions, ignoreUndefined) {
      var totalLength = 4 + 1;
      if (Array.isArray(object2)) {
        for (var i = 0; i < object2.length; i++) {
          totalLength += calculateElement(
            i.toString(),
            object2[i],
            serializeFunctions,
            true,
            ignoreUndefined
          );
        }
      } else {
        if (object2.toBSON) {
          object2 = object2.toBSON();
        }
        for (var key in object2) {
          totalLength += calculateElement(key, object2[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    };
    function calculateElement(name, value2, serializeFunctions, isArray, ignoreUndefined) {
      if (value2 && value2.toBSON) {
        value2 = value2.toBSON();
      }
      switch (typeof value2) {
        case "string":
          return 1 + Buffer.byteLength(name, "utf8") + 1 + 4 + Buffer.byteLength(value2, "utf8") + 1;
        case "number":
          if (Math.floor(value2) === value2 && value2 >= BSON2.JS_INT_MIN && value2 <= BSON2.JS_INT_MAX) {
            if (value2 >= BSON2.BSON_INT32_MIN && value2 <= BSON2.BSON_INT32_MAX) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (4 + 1);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
            }
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray || !ignoreUndefined)
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 1);
        case "object":
          if (value2 == null || value2 instanceof MinKey2 || value2 instanceof MaxKey2 || value2["_bsontype"] === "MinKey" || value2["_bsontype"] === "MaxKey") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          } else if (value2 instanceof ObjectID2 || value2["_bsontype"] === "ObjectID" || value2["_bsontype"] === "ObjectId") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (12 + 1);
          } else if (value2 instanceof Date || isDate(value2)) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(value2)) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 4 + 1) + value2.length;
          } else if (value2 instanceof Long2 || value2 instanceof Double2 || value2 instanceof Timestamp2 || value2["_bsontype"] === "Long" || value2["_bsontype"] === "Double" || value2["_bsontype"] === "Timestamp") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (value2 instanceof Decimal1282 || value2["_bsontype"] === "Decimal128") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (16 + 1);
          } else if (value2 instanceof Code2 || value2["_bsontype"] === "Code") {
            if (value2.scope != null && Object.keys(value2.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value2.code.toString(), "utf8") + 1 + calculateObjectSize(value2.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(value2.code.toString(), "utf8") + 1;
            }
          } else if (value2 instanceof Binary2 || value2["_bsontype"] === "Binary") {
            if (value2.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value2.position + 1 + 4 + 1 + 4);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value2.position + 1 + 4 + 1);
            }
          } else if (value2 instanceof Symbol2 || value2["_bsontype"] === "Symbol") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + Buffer.byteLength(value2.value, "utf8") + 4 + 1 + 1;
          } else if (value2 instanceof DBRef2 || value2["_bsontype"] === "DBRef") {
            var ordered_values = {
              $ref: value2.namespace,
              $id: value2.oid
            };
            if (null != value2.db) {
              ordered_values["$db"] = value2.db;
            }
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value2 instanceof RegExp || Object.prototype.toString.call(value2) === "[object RegExp]") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value2.source, "utf8") + 1 + (value2.global ? 1 : 0) + (value2.ignoreCase ? 1 : 0) + (value2.multiline ? 1 : 0) + 1;
          } else if (value2 instanceof BSONRegExp2 || value2["_bsontype"] === "BSONRegExp") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value2.pattern, "utf8") + 1 + Buffer.byteLength(value2.options, "utf8") + 1;
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + calculateObjectSize(value2, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (value2 instanceof RegExp || Object.prototype.toString.call(value2) === "[object RegExp]" || String.call(value2) === "[object RegExp]") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value2.source, "utf8") + 1 + (value2.global ? 1 : 0) + (value2.ignoreCase ? 1 : 0) + (value2.multiline ? 1 : 0) + 1;
          } else {
            if (serializeFunctions && value2.scope != null && Object.keys(value2.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(normalizedFunctionString(value2), "utf8") + 1 + calculateObjectSize(value2.scope, serializeFunctions, ignoreUndefined);
            } else if (serializeFunctions) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(normalizedFunctionString(value2), "utf8") + 1;
            }
          }
      }
      return 0;
    }
    var BSON2 = {};
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = calculateObjectSize;
  }
});

// node_modules/bson/lib/bson/bson.js
var require_bson = __commonJS({
  "node_modules/bson/lib/bson/bson.js"(exports2, module2) {
    "use strict";
    var Map2 = require_map();
    var Long2 = require_long();
    var Double2 = require_double();
    var Timestamp2 = require_timestamp();
    var ObjectID2 = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Int322 = require_int_32();
    var Code2 = require_code();
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key();
    var MaxKey2 = require_max_key();
    var DBRef2 = require_db_ref();
    var Binary2 = require_binary();
    var deserialize2 = require_deserializer();
    var serializer = require_serializer();
    var calculateObjectSize = require_calculate_size();
    var utils2 = require_utils2();
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = utils2.allocBuffer(MAXSIZE);
    var BSON2 = function() {
    };
    BSON2.prototype.serialize = function serialize(object2, options) {
      options = options || {};
      var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      var minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
      if (buffer.length < minInternalBufferSize) {
        buffer = utils2.allocBuffer(minInternalBufferSize);
      }
      var serializationIndex = serializer(
        buffer,
        object2,
        checkKeys,
        0,
        0,
        serializeFunctions,
        ignoreUndefined,
        []
      );
      var finishedBuffer = utils2.allocBuffer(serializationIndex);
      buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
      return finishedBuffer;
    };
    BSON2.prototype.serializeWithBufferAndIndex = function(object2, finalBuffer, options) {
      options = options || {};
      var checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      var startIndex = typeof options.index === "number" ? options.index : 0;
      var serializationIndex = serializer(
        finalBuffer,
        object2,
        checkKeys,
        startIndex || 0,
        0,
        serializeFunctions,
        ignoreUndefined
      );
      return serializationIndex - 1;
    };
    BSON2.prototype.deserialize = function(buffer2, options) {
      return deserialize2(buffer2, options);
    };
    BSON2.prototype.calculateObjectSize = function(object2, options) {
      options = options || {};
      var serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      return calculateObjectSize(object2, serializeFunctions, ignoreUndefined);
    };
    BSON2.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
      options = options != null ? options : {};
      var index = startIndex;
      for (var i = 0; i < numberOfDocuments; i++) {
        var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
        options["index"] = index;
        documents[docStartIndex + i] = this.deserialize(data, options);
        index = index + size;
      }
      return index;
    };
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    module2.exports = BSON2;
    module2.exports.Code = Code2;
    module2.exports.Map = Map2;
    module2.exports.Symbol = Symbol2;
    module2.exports.BSON = BSON2;
    module2.exports.DBRef = DBRef2;
    module2.exports.Binary = Binary2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.Long = Long2;
    module2.exports.Timestamp = Timestamp2;
    module2.exports.Double = Double2;
    module2.exports.Int32 = Int322;
    module2.exports.MinKey = MinKey2;
    module2.exports.MaxKey = MaxKey2;
    module2.exports.BSONRegExp = BSONRegExp2;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/index.js
var require_bson2 = __commonJS({
  "node_modules/bson/index.js"(exports2, module2) {
    var BSON2 = require_bson();
    var Binary2 = require_binary();
    var Code2 = require_code();
    var DBRef2 = require_db_ref();
    var Decimal1282 = require_decimal128();
    var Double2 = require_double();
    var Int322 = require_int_32();
    var Long2 = require_long();
    var Map2 = require_map();
    var MaxKey2 = require_max_key();
    var MinKey2 = require_min_key();
    var ObjectId = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Timestamp2 = require_timestamp();
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.Binary = Binary2;
    BSON2.Code = Code2;
    BSON2.DBRef = DBRef2;
    BSON2.Decimal128 = Decimal1282;
    BSON2.Double = Double2;
    BSON2.Int32 = Int322;
    BSON2.Long = Long2;
    BSON2.Map = Map2;
    BSON2.MaxKey = MaxKey2;
    BSON2.MinKey = MinKey2;
    BSON2.ObjectId = ObjectId;
    BSON2.ObjectID = ObjectId;
    BSON2.BSONRegExp = BSONRegExp2;
    BSON2.Symbol = Symbol2;
    BSON2.Timestamp = Timestamp2;
    module2.exports = BSON2;
  }
});

// node_modules/require-at/create-require.js
var require_create_require = __commonJS({
  "node_modules/require-at/create-require.js"(exports, module) {
    "use strict";
    var Module = __require("module");
    var xrequire = eval("require");
    var createRequireFromPath = Module.createRequire || Module.createRequireFromPath || ((filename, dir) => {
      const m = new Module(filename);
      m.filename = filename;
      m.paths = Module._nodeModulePaths(dir);
      function _require(request) {
        return xrequire(resolve(request));
      }
      function resolve(request, options) {
        return Module._resolveFilename(request, m, false, options);
      }
      _require.resolve = resolve;
      function paths(request) {
        return Module._resolveLookupPaths(request, m, true);
      }
      resolve.paths = paths;
      _require.main = process.mainModule;
      _require.extensions = Module._extensions;
      _require.cache = Module._cache;
      return _require;
    });
    module.exports = createRequireFromPath;
  }
});

// node_modules/require-at/require-at.js
var require_require_at = __commonJS({
  "node_modules/require-at/require-at.js"(exports2, module2) {
    "use strict";
    var Path = __require("path");
    var Fs = __require("fs");
    var createRequireFromPath2 = require_create_require();
    var cache = /* @__PURE__ */ new Map();
    function requireAt(dir, request) {
      const makeIt = (xdir, checked) => {
        let xRequire = requireAt.cache && requireAt.cache.get(xdir);
        if (!xRequire) {
          let stat;
          try {
            stat = Fs.statSync(xdir);
          } catch (e) {
            throw new Error(`require-at: stat '${xdir}' failed: ${e.message}`);
          }
          if (!stat || !stat.isDirectory()) {
            if (checked)
              throw new Error(`require-at: not a directory: '${dir}'`);
            return makeIt(Path.dirname(xdir), true);
          }
          xRequire = createRequireFromPath2(Path.join(xdir, "._require-at_"), xdir);
          requireAt.cache && requireAt.cache.set(xdir, xRequire);
        }
        return request ? xRequire(request) : xRequire;
      };
      return makeIt(Path.resolve(dir), false);
    }
    requireAt.cache = cache;
    module2.exports = requireAt;
  }
});

// node_modules/optional-require/dist/index.js
var require_dist = __commonJS({
  "node_modules/optional-require/dist/index.js"(exports, module) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.optionalRequireCwd = exports.optionalRequire = exports.makeOptionalRequire = exports.tryResolve = exports.tryRequire = exports.setDefaultLog = void 0;
    var assert_1 = __importDefault(__require("assert"));
    var require_at_1 = __importDefault(require_require_at());
    var xrequire = eval("require");
    var pnpDependencyNameRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:node:)?(?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
    function getPnpDependencyName(name) {
      var dependencyNameMatch = name.match(pnpDependencyNameRegExp);
      if (!dependencyNameMatch)
        return null;
      return dependencyNameMatch[1];
    }
    function findModuleNotFound(err, name) {
      var msg = err.message.split("\n")[0];
      if (!msg) {
        return false;
      }
      if (msg.includes("'" + name + "'")) {
        return true;
      }
      var pnpDependencyName = getPnpDependencyName(name);
      if (pnpDependencyName) {
        return (
          // Check for "Your application tried to access foo (a peer dependency) ..." (Yarn Berry PnP)
          // https://github.com/yarnpkg/berry/blob/e81dc0d29bb2f41818d9c5c1c74bab1406fb979b/packages/yarnpkg-pnp/sources/loader/makeApi.ts#L680
          msg.includes(" " + pnpDependencyName + " ") || // Check for "Your application tried to access foo. While ..." (Yarn Berry PnP)
          // https://github.com/yarnpkg/berry/blob/e81dc0d29bb2f41818d9c5c1c74bab1406fb979b/packages/yarnpkg-pnp/sources/loader/makeApi.ts#L704
          msg.includes(" " + pnpDependencyName + ". ") || // Check for "Your application tried to access foo, but ..." (Yarn Berry PnP)
          // https://github.com/yarnpkg/berry/blob/e81dc0d29bb2f41818d9c5c1c74bab1406fb979b/packages/yarnpkg-pnp/sources/loader/makeApi.ts#L718
          msg.includes(" " + pnpDependencyName + ", ")
        );
      }
      return false;
    }
    function defaultLog(message, path2) {
      console.log("Just FYI: " + message + '; Path "' + path2 + '"');
    }
    var __defaultLog = defaultLog;
    function setDefaultLog(log) {
      __defaultLog = log;
    }
    exports.setDefaultLog = setDefaultLog;
    function _getOptions(optsOrMsg, requireFunction, log) {
      if (requireFunction === void 0) {
        requireFunction = xrequire;
      }
      if (typeof optsOrMsg === "object") {
        var opts = __assign({ require: requireFunction, log }, optsOrMsg);
        (0, assert_1.default)(!(opts.hasOwnProperty("notFound") && opts.hasOwnProperty("default")), "optionalRequire: options set with both `notFound` and `default`");
        return opts;
      } else {
        return { require: requireFunction, log, message: optsOrMsg };
      }
    }
    function _optionalRequire(path2, opts) {
      try {
        return opts.resolve ? opts.require.resolve(path2) : opts.require(path2);
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" || !findModuleNotFound(e, path2)) {
          if (typeof opts.fail === "function") {
            return opts.fail(e);
          }
          throw e;
        }
        if (opts.message) {
          var message = opts.message === true ? "" : opts.message + " - ";
          var r = opts.resolve ? "resolved" : "found";
          opts.log(message + "optional module not " + r, path2);
        }
        if (typeof opts.notFound === "function") {
          return opts.notFound(e);
        }
        return opts.default;
      }
    }
    function tryRequire(callerRequire, path2, optsOrMsg) {
      var opts = _getOptions(optsOrMsg, callerRequire, __defaultLog);
      opts.resolve = false;
      return _optionalRequire(path2, opts);
    }
    exports.tryRequire = tryRequire;
    function tryResolve(callerRequire, path2, optsOrMsg) {
      var opts = _getOptions(optsOrMsg, callerRequire, __defaultLog);
      opts.resolve = true;
      return _optionalRequire(path2, opts);
    }
    exports.tryResolve = tryResolve;
    function makeOptionalRequire(callerRequire, log) {
      var x = function(path2, optsOrMsg) {
        var opts = _getOptions(optsOrMsg, callerRequire, x.log);
        return _optionalRequire(path2, opts);
      };
      x.resolve = function(path2, optsOrMsg) {
        var opts = _getOptions(optsOrMsg, callerRequire, x.log);
        opts.resolve = true;
        return _optionalRequire(path2, opts);
      };
      x.log = log || __defaultLog;
      return x;
    }
    exports.makeOptionalRequire = makeOptionalRequire;
    exports.optionalRequire = makeOptionalRequire(xrequire);
    exports.optionalRequireCwd = makeOptionalRequire((0, require_at_1.default)(process.cwd()));
  }
});

// node_modules/optional-require/index.js
var require_optional_require = __commonJS({
  "node_modules/optional-require/index.js"(exports2, module2) {
    "use strict";
    var lib = require_dist();
    module2.exports = function() {
      return lib.makeOptionalRequire.apply(lib, arguments);
    };
    module2.exports.tryRequire = lib.tryRequire;
    module2.exports.tryResolve = lib.tryResolve;
    module2.exports.try = lib.tryRequire;
    module2.exports.resolve = lib.tryResolve;
    module2.exports.makeOptionalRequire = lib.makeOptionalRequire;
    module2.exports.optionalRequire = lib.optionalRequire;
    module2.exports.optionalRequireCwd = lib.optionalRequireCwd;
    module2.exports.optionalRequireTop = lib.optionalRequireTop;
    var __defaultLog2;
    Object.defineProperty(module2.exports, "log", {
      set(func) {
        __defaultLog2 = func;
        lib.setDefaultLog(func);
      },
      get() {
        return __defaultLog2;
      }
    });
  }
});

// node_modules/mongodb/package.json
var require_package = __commonJS({
  "node_modules/mongodb/package.json"(exports2, module2) {
    module2.exports = {
      name: "mongodb",
      version: "3.7.4",
      description: "The official MongoDB driver for Node.js",
      main: "index.js",
      files: [
        "index.js",
        "lib"
      ],
      repository: {
        type: "git",
        url: "git@github.com:mongodb/node-mongodb-native.git"
      },
      keywords: [
        "mongodb",
        "driver",
        "official"
      ],
      author: {
        name: "The MongoDB NodeJS Team",
        email: "dbx-node@mongodb.com"
      },
      peerDependenciesMeta: {
        kerberos: {
          optional: true
        },
        "mongodb-client-encryption": {
          optional: true
        },
        "mongodb-extjson": {
          optional: true
        },
        snappy: {
          optional: true
        },
        "bson-ext": {
          optional: true
        },
        aws4: {
          optional: true
        }
      },
      dependencies: {
        bl: "^2.2.1",
        bson: "^1.1.4",
        denque: "^1.4.1",
        "optional-require": "^1.1.8",
        "safe-buffer": "^5.1.2"
      },
      devDependencies: {
        "@types/chai": "^4.2.16",
        "@types/mocha": "^8.2.2",
        "@types/node": "^14.14.37",
        "array-includes": "^3.1.3",
        chai: "^4.1.1",
        "chai-subset": "^1.6.0",
        chalk: "^2.4.2",
        co: "4.6.0",
        eslint: "^7.10.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-es": "^3.0.1",
        "eslint-plugin-prettier": "^3.1.3",
        jsdoc: "^3.5.5",
        "lodash.camelcase": "^4.3.0",
        mocha: "5.2.0",
        "mocha-sinon": "^2.1.0",
        "mongodb-extjson": "^2.1.1",
        "mongodb-mock-server": "^1.0.1",
        nyc: "^15.1.0",
        "object.entries": "^1.1.3",
        prettier: "^1.19.1",
        semver: "^5.5.0",
        sinon: "^4.3.0",
        "sinon-chai": "^3.2.0",
        snappy: "^6.3.4",
        "spec-xunit-file": "0.0.1-3",
        "standard-version": "^9.2.0",
        tslib: "^2.2.0",
        typescript: "^4.2.4",
        "util.promisify": "^1.0.1",
        "worker-farm": "^1.5.0",
        wtfnode: "^0.8.0",
        yargs: "^14.2.0"
      },
      license: "Apache-2.0",
      engines: {
        node: ">=4"
      },
      bugs: {
        url: "https://jira.mongodb.org/projects/NODE/issues/"
      },
      scripts: {
        "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
        "build:unified": "tsc -p test/functional/unified-spec-runner/tsconfig.unified.json",
        "check:atlas": "mocha --opts '{}' ./test/manual/atlas_connectivity.test.js",
        "check:bench": "node test/benchmarks/driverBench/",
        "check:coverage": "nyc npm run check:test",
        "check:kerberos": "mocha --opts '{}' -t 60000 test/manual/kerberos.test.js",
        "check:ldap": "mocha --opts '{}' test/manual/ldap.test.js",
        "check:lint": "eslint -v && eslint lib test",
        "check:test": "mocha --recursive test/functional test/unit",
        "check:tls": "mocha --opts '{}' test/manual/tls_support.test.js",
        format: "npm run check:lint -- --fix",
        release: "standard-version -i HISTORY.md",
        test: "npm run check:lint && mocha --recursive test/functional test/unit"
      },
      homepage: "https://github.com/mongodb/node-mongodb-native",
      optionalDependencies: {
        saslprep: "^1.0.0"
      }
    };
  }
});

// node_modules/mongodb/lib/core/utils.js
var require_utils3 = __commonJS({
  "node_modules/mongodb/lib/core/utils.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var crypto = __require("crypto");
    var requireOptional = require_optional_require()(__require);
    var uuidV4 = () => {
      const result = crypto.randomBytes(16);
      result[6] = result[6] & 15 | 64;
      result[8] = result[8] & 63 | 128;
      return result;
    };
    function relayEvents(listener, emitter, events) {
      events.forEach((eventName) => listener.on(eventName, (event) => emitter.emit(eventName, event)));
    }
    function retrieveKerberos() {
      let kerberos;
      try {
        kerberos = requireOptional("kerberos");
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          throw new Error("The `kerberos` module was not found. Please install it and try again.");
        }
        throw err;
      }
      return kerberos;
    }
    var noEJSONError = function() {
      throw new Error("The `mongodb-extjson` module was not found. Please install it and try again.");
    };
    function retrieveEJSON() {
      let EJSON = requireOptional("mongodb-extjson");
      if (!EJSON) {
        EJSON = {
          parse: noEJSONError,
          deserialize: noEJSONError,
          serialize: noEJSONError,
          stringify: noEJSONError,
          setBSONModule: noEJSONError,
          BSON: noEJSONError
        };
      }
      return EJSON;
    }
    function maxWireVersion(topologyOrServer) {
      if (topologyOrServer) {
        if (topologyOrServer.ismaster) {
          return topologyOrServer.ismaster.maxWireVersion;
        }
        if (typeof topologyOrServer.lastIsMaster === "function") {
          const lastIsMaster = topologyOrServer.lastIsMaster();
          if (lastIsMaster) {
            return lastIsMaster.maxWireVersion;
          }
        }
        if (topologyOrServer.description) {
          return topologyOrServer.description.maxWireVersion;
        }
      }
      return 0;
    }
    function collationNotSupported(server, cmd) {
      return cmd && cmd.collation && maxWireVersion(server) < 5;
    }
    function isPromiseLike(maybePromise) {
      return maybePromise && typeof maybePromise.then === "function";
    }
    function eachAsync(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = 0;
      for (idx = 0; idx < arr.length; ++idx) {
        awaiting++;
        eachFn(arr[idx], eachCallback);
      }
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
        }
      }
    }
    function eachAsyncSeries(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = arr.length;
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        idx++;
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
          return;
        }
        eachFn(arr[idx], eachCallback);
      }
      eachFn(arr[idx], eachCallback);
    }
    function isUnifiedTopology(topology) {
      return topology.description != null;
    }
    function arrayStrictEqual(arr, arr2) {
      if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
      }
      return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
    }
    function tagsStrictEqual(tags, tags2) {
      const tagsKeys = Object.keys(tags);
      const tags2Keys = Object.keys(tags2);
      return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
    }
    function errorStrictEqual(lhs, rhs) {
      if (lhs === rhs) {
        return true;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
      }
      if (lhs.message !== rhs.message) {
        return false;
      }
      return true;
    }
    function makeStateMachine(stateTable) {
      return function stateTransition(target, newState) {
        const legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
          throw new TypeError(
            `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`
          );
        }
        target.emit("stateChanged", target.s.state, newState);
        target.s.state = newState;
      };
    }
    function makeClientMetadata(options) {
      options = options || {};
      const metadata = {
        driver: {
          name: "nodejs",
          version: require_package().version
        },
        os: {
          type: os.type(),
          name: process.platform,
          architecture: process.arch,
          version: os.release()
        },
        platform: `'Node.js ${process.version}, ${os.endianness} (${options.useUnifiedTopology ? "unified" : "legacy"})`
      };
      if (options.driverInfo) {
        if (options.driverInfo.name) {
          metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;
        }
        if (options.driverInfo.version) {
          metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;
        }
        if (options.driverInfo.platform) {
          metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;
        }
      }
      if (options.appname) {
        const buffer = Buffer.from(options.appname);
        metadata.application = {
          name: buffer.length > 128 ? buffer.slice(0, 128).toString("utf8") : options.appname
        };
      }
      return metadata;
    }
    var noop = () => {
    };
    module2.exports = {
      uuidV4,
      relayEvents,
      collationNotSupported,
      retrieveEJSON,
      retrieveKerberos,
      maxWireVersion,
      isPromiseLike,
      eachAsync,
      eachAsyncSeries,
      isUnifiedTopology,
      arrayStrictEqual,
      tagsStrictEqual,
      errorStrictEqual,
      makeStateMachine,
      makeClientMetadata,
      noop
    };
  }
});

// node_modules/mongodb/lib/core/connection/utils.js
var require_utils4 = __commonJS({
  "node_modules/mongodb/lib/core/connection/utils.js"(exports2, module2) {
    "use strict";
    var parsePackageVersion = require_utils().parsePackageVersion;
    var MongoError = require_error().MongoError;
    var require_optional = require_optional_require()(__require);
    function debugOptions(debugFields, options) {
      const finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options[n];
      });
      return finaloptions;
    }
    function retrieveBSON() {
      const BSON2 = require_bson2();
      BSON2.native = false;
      const optionalBSON = require_optional("bson-ext");
      const bsonExtVersion = parsePackageVersion(
        require_optional("bson-ext/package.json") || { version: "0.0.0" }
      );
      if (optionalBSON) {
        if (bsonExtVersion.major >= 4) {
          throw new MongoError(
            "bson-ext version 4 and above does not work with the 3.x version of the mongodb driver"
          );
        }
        optionalBSON.native = true;
        return optionalBSON;
      }
      return BSON2;
    }
    function noSnappyWarning() {
      throw new Error(
        "Attempted to use Snappy compression, but Snappy is not installed. Install or disable Snappy compression and try again."
      );
    }
    var PKG_VERSION = Symbol("kPkgVersion");
    function retrieveSnappy() {
      const snappy = require_optional("snappy");
      if (!snappy) {
        return {
          compress: noSnappyWarning,
          uncompress: noSnappyWarning,
          compressSync: noSnappyWarning,
          uncompressSync: noSnappyWarning
        };
      }
      const snappyPkg = require_optional("snappy/package.json") || { version: "0.0.0" };
      const version = parsePackageVersion(snappyPkg);
      snappy[PKG_VERSION] = version;
      if (version.major >= 7) {
        const compressOriginal = snappy.compress;
        const uncompressOriginal = snappy.uncompress;
        snappy.compress = (data, callback) => {
          compressOriginal(data).then((res) => callback(void 0, res)).catch((error) => callback(error));
        };
        snappy.uncompress = (data, callback) => {
          uncompressOriginal(data).then((res) => callback(void 0, res)).catch((error) => callback(error));
        };
      }
      return snappy;
    }
    module2.exports = {
      PKG_VERSION,
      debugOptions,
      retrieveBSON,
      retrieveSnappy
    };
  }
});

// node_modules/mongodb/lib/core/topologies/read_preference.js
var require_read_preference = __commonJS({
  "node_modules/mongodb/lib/core/topologies/read_preference.js"(exports2, module2) {
    "use strict";
    var emitWarningOnce = require_utils().emitWarningOnce;
    var ReadPreference = function(mode, tags, options) {
      if (!ReadPreference.isValid(mode)) {
        throw new TypeError(`Invalid read preference mode ${mode}`);
      }
      if (tags && !Array.isArray(tags)) {
        emitWarningOnce(
          "ReadPreference tags must be an array, this will change in the next major version"
        );
        const tagsHasMaxStalenessSeconds = typeof tags.maxStalenessSeconds !== "undefined";
        const tagsHasHedge = typeof tags.hedge !== "undefined";
        const tagsHasOptions = tagsHasMaxStalenessSeconds || tagsHasHedge;
        if (tagsHasOptions) {
          options = tags;
          tags = void 0;
        } else {
          tags = [tags];
        }
      }
      this.mode = mode;
      this.tags = tags;
      this.hedge = options && options.hedge;
      options = options || {};
      if (options.maxStalenessSeconds != null) {
        if (options.maxStalenessSeconds <= 0) {
          throw new TypeError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new TypeError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new TypeError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new TypeError("Primary read preference cannot be combined with hedge");
        }
      }
    };
    Object.defineProperty(ReadPreference.prototype, "preference", {
      enumerable: true,
      get: function() {
        return this.mode;
      }
    });
    ReadPreference.PRIMARY = "primary";
    ReadPreference.PRIMARY_PREFERRED = "primaryPreferred";
    ReadPreference.SECONDARY = "secondary";
    ReadPreference.SECONDARY_PREFERRED = "secondaryPreferred";
    ReadPreference.NEAREST = "nearest";
    var VALID_MODES = [
      ReadPreference.PRIMARY,
      ReadPreference.PRIMARY_PREFERRED,
      ReadPreference.SECONDARY,
      ReadPreference.SECONDARY_PREFERRED,
      ReadPreference.NEAREST,
      null
    ];
    ReadPreference.fromOptions = function(options) {
      if (!options)
        return null;
      const readPreference = options.readPreference;
      if (!readPreference)
        return null;
      const readPreferenceTags = options.readPreferenceTags;
      const maxStalenessSeconds = options.maxStalenessSeconds;
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags);
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds || maxStalenessSeconds,
            hedge: readPreference.hedge
          });
        }
      }
      return readPreference;
    };
    ReadPreference.resolve = function(parent, options) {
      options = options || {};
      const session = options.session;
      const inheritedReadPreference = parent && parent.readPreference;
      let readPreference;
      if (options.readPreference) {
        readPreference = ReadPreference.fromOptions(options);
      } else if (session && session.inTransaction() && session.transaction.options.readPreference) {
        readPreference = session.transaction.options.readPreference;
      } else if (inheritedReadPreference != null) {
        readPreference = inheritedReadPreference;
      } else {
        readPreference = ReadPreference.primary;
      }
      return typeof readPreference === "string" ? new ReadPreference(readPreference) : readPreference;
    };
    ReadPreference.translate = function(options) {
      if (options.readPreference == null)
        return options;
      const r = options.readPreference;
      if (typeof r === "string") {
        options.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
        const mode = r.mode || r.preference;
        if (mode && typeof mode === "string") {
          options.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new TypeError("Invalid read preference: " + r);
      }
      return options;
    };
    ReadPreference.isValid = function(mode) {
      return VALID_MODES.indexOf(mode) !== -1;
    };
    ReadPreference.prototype.isValid = function(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    };
    var needSlaveOk = ["primaryPreferred", "secondary", "secondaryPreferred", "nearest"];
    ReadPreference.prototype.slaveOk = function() {
      return needSlaveOk.indexOf(this.mode) !== -1;
    };
    ReadPreference.prototype.equals = function(readPreference) {
      return readPreference.mode === this.mode;
    };
    ReadPreference.prototype.toJSON = function() {
      const readPreference = { mode: this.mode };
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    };
    ReadPreference.primary = new ReadPreference("primary");
    ReadPreference.primaryPreferred = new ReadPreference("primaryPreferred");
    ReadPreference.secondary = new ReadPreference("secondary");
    ReadPreference.secondaryPreferred = new ReadPreference("secondaryPreferred");
    ReadPreference.nearest = new ReadPreference("nearest");
    module2.exports = ReadPreference;
  }
});

// node_modules/mongodb/lib/core/sdam/common.js
var require_common = __commonJS({
  "node_modules/mongodb/lib/core/sdam/common.js"(exports2, module2) {
    "use strict";
    var STATE_CLOSING = "closing";
    var STATE_CLOSED = "closed";
    var STATE_CONNECTING = "connecting";
    var STATE_CONNECTED = "connected";
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    function serverType(server) {
      let description = server.s.description || server.s.serverDescription;
      if (description.topologyType === TopologyType.Single)
        return description.servers[0].type;
      return description.type;
    }
    var TOPOLOGY_DEFAULTS = {
      useUnifiedTopology: true,
      localThresholdMS: 15,
      serverSelectionTimeoutMS: 3e4,
      heartbeatFrequencyMS: 1e4,
      minHeartbeatFrequencyMS: 500
    };
    function drainTimerQueue(queue) {
      queue.forEach(clearTimeout);
      queue.clear();
    }
    function clearAndRemoveTimerFrom(timer, timers) {
      clearTimeout(timer);
      return timers.delete(timer);
    }
    module2.exports = {
      STATE_CLOSING,
      STATE_CLOSED,
      STATE_CONNECTING,
      STATE_CONNECTED,
      TOPOLOGY_DEFAULTS,
      TopologyType,
      ServerType,
      serverType,
      drainTimerQueue,
      clearAndRemoveTimerFrom
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server_description.js
var require_server_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_description.js"(exports2, module2) {
    "use strict";
    var arrayStrictEqual = require_utils3().arrayStrictEqual;
    var tagsStrictEqual = require_utils3().tagsStrictEqual;
    var errorStrictEqual = require_utils3().errorStrictEqual;
    var ServerType = require_common().ServerType;
    var now = require_utils().now;
    var WRITABLE_SERVER_TYPES = /* @__PURE__ */ new Set([
      ServerType.RSPrimary,
      ServerType.Standalone,
      ServerType.Mongos
    ]);
    var DATA_BEARING_SERVER_TYPES = /* @__PURE__ */ new Set([
      ServerType.RSPrimary,
      ServerType.RSSecondary,
      ServerType.Mongos,
      ServerType.Standalone
    ]);
    var ISMASTER_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "compression",
      "me",
      "hosts",
      "passives",
      "arbiters",
      "tags",
      "setName",
      "setVersion",
      "electionId",
      "primary",
      "logicalSessionTimeoutMinutes",
      "saslSupportedMechs",
      "__nodejs_mock_server__",
      "$clusterTime"
    ];
    var ServerDescription = class {
      /**
       * Create a ServerDescription
       * @param {String} address The address of the server
       * @param {Object} [ismaster] An optional ismaster response for this server
       * @param {Object} [options] Optional settings
       * @param {Number} [options.roundTripTime] The round trip time to ping this server (in ms)
       * @param {Error} [options.error] An Error used for better reporting debugging
       * @param {any} [options.topologyVersion] The topologyVersion
       */
      constructor(address, ismaster, options) {
        options = options || {};
        ismaster = Object.assign(
          {
            minWireVersion: 0,
            maxWireVersion: 0,
            hosts: [],
            passives: [],
            arbiters: [],
            tags: []
          },
          ismaster
        );
        if (ismaster.isWritablePrimary != null) {
          ismaster.ismaster = ismaster.isWritablePrimary;
        }
        this.address = address;
        this.error = options.error;
        this.roundTripTime = options.roundTripTime || -1;
        this.lastUpdateTime = now();
        this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;
        this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;
        this.type = parseServerType(ismaster);
        this.topologyVersion = options.topologyVersion || ismaster.topologyVersion;
        ISMASTER_FIELDS.forEach((field) => {
          if (typeof ismaster[field] !== "undefined")
            this[field] = ismaster[field];
        });
        if (this.me)
          this.me = this.me.toLowerCase();
        this.hosts = this.hosts.map((host) => host.toLowerCase());
        this.passives = this.passives.map((host) => host.toLowerCase());
        this.arbiters = this.arbiters.map((host) => host.toLowerCase());
      }
      get allHosts() {
        return this.hosts.concat(this.arbiters).concat(this.passives);
      }
      /**
       * @return {Boolean} Is this server available for reads
       */
      get isReadable() {
        return this.type === ServerType.RSSecondary || this.isWritable;
      }
      /**
       * @return {Boolean} Is this server data bearing
       */
      get isDataBearing() {
        return DATA_BEARING_SERVER_TYPES.has(this.type);
      }
      /**
       * @return {Boolean} Is this server available for writes
       */
      get isWritable() {
        return WRITABLE_SERVER_TYPES.has(this.type);
      }
      get host() {
        const chopLength = `:${this.port}`.length;
        return this.address.slice(0, -chopLength);
      }
      get port() {
        const port = this.address.split(":").pop();
        return port ? Number.parseInt(port, 10) : port;
      }
      /**
       * Determines if another `ServerDescription` is equal to this one per the rules defined
       * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}
       *
       * @param {ServerDescription} other
       * @return {Boolean}
       */
      equals(other) {
        const topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;
        return other != null && errorStrictEqual(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && this.me === other.me && arrayStrictEqual(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && (this.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId) && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
      }
    };
    function parseServerType(ismaster) {
      if (!ismaster || !ismaster.ok) {
        return ServerType.Unknown;
      }
      if (ismaster.isreplicaset) {
        return ServerType.RSGhost;
      }
      if (ismaster.msg && ismaster.msg === "isdbgrid") {
        return ServerType.Mongos;
      }
      if (ismaster.setName) {
        if (ismaster.hidden) {
          return ServerType.RSOther;
        } else if (ismaster.ismaster) {
          return ServerType.RSPrimary;
        } else if (ismaster.secondary) {
          return ServerType.RSSecondary;
        } else if (ismaster.arbiterOnly) {
          return ServerType.RSArbiter;
        } else {
          return ServerType.RSOther;
        }
      }
      return ServerType.Standalone;
    }
    function compareTopologyVersion(lhs, rhs) {
      if (lhs == null || rhs == null) {
        return -1;
      }
      if (lhs.processId.equals(rhs.processId)) {
        if (lhs.counter === rhs.counter) {
          return 0;
        } else if (lhs.counter < rhs.counter) {
          return -1;
        }
        return 1;
      }
      return -1;
    }
    module2.exports = {
      ServerDescription,
      parseServerType,
      compareTopologyVersion
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/constants.js
var require_constants = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/constants.js"(exports2, module2) {
    "use strict";
    var MIN_SUPPORTED_SERVER_VERSION = "2.6";
    var MAX_SUPPORTED_SERVER_VERSION = "5.0";
    var MIN_SUPPORTED_WIRE_VERSION = 2;
    var MAX_SUPPORTED_WIRE_VERSION = 13;
    module2.exports = {
      MIN_SUPPORTED_SERVER_VERSION,
      MAX_SUPPORTED_SERVER_VERSION,
      MIN_SUPPORTED_WIRE_VERSION,
      MAX_SUPPORTED_WIRE_VERSION
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology_description.js
var require_topology_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology_description.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var ServerDescription = require_server_description().ServerDescription;
    var WIRE_CONSTANTS = require_constants();
    var TopologyType = require_common().TopologyType;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var TopologyDescription = class _TopologyDescription {
      /**
       * Create a TopologyDescription
       *
       * @param {string} topologyType
       * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription
       * @param {string} setName
       * @param {number} maxSetVersion
       * @param {ObjectId} maxElectionId
       */
      constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {
        options = options || {};
        this.type = topologyType || TopologyType.Unknown;
        this.setName = setName || null;
        this.maxSetVersion = maxSetVersion || null;
        this.maxElectionId = maxElectionId || null;
        this.servers = serverDescriptions || /* @__PURE__ */ new Map();
        this.stale = false;
        this.compatible = true;
        this.compatibilityError = null;
        this.logicalSessionTimeoutMinutes = null;
        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;
        this.localThresholdMS = options.localThresholdMS || 0;
        this.commonWireVersion = commonWireVersion || null;
        Object.defineProperty(this, "options", { value: options, enumberable: false });
        for (const serverDescription of this.servers.values()) {
          if (serverDescription.type === ServerType.Unknown)
            continue;
          if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
          }
          if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
            break;
          }
        }
        this.logicalSessionTimeoutMinutes = null;
        for (const addressServerTuple of this.servers) {
          const server = addressServerTuple[1];
          if (server.isReadable) {
            if (server.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = null;
              break;
            }
            if (this.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
              continue;
            }
            this.logicalSessionTimeoutMinutes = Math.min(
              this.logicalSessionTimeoutMinutes,
              server.logicalSessionTimeoutMinutes
            );
          }
        }
      }
      /**
       * Returns a new TopologyDescription based on the SrvPollingEvent
       * @param {SrvPollingEvent} ev The event
       */
      updateFromSrvPollingEvent(ev) {
        const newAddresses = ev.addresses();
        const serverDescriptions = new Map(this.servers);
        for (const server of this.servers) {
          if (newAddresses.has(server[0])) {
            newAddresses.delete(server[0]);
          } else {
            serverDescriptions.delete(server[0]);
          }
        }
        if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {
          return this;
        }
        for (const address of newAddresses) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
        return new _TopologyDescription(
          this.type,
          serverDescriptions,
          this.setName,
          this.maxSetVersion,
          this.maxElectionId,
          this.commonWireVersion,
          this.options,
          null
        );
      }
      /**
       * Returns a copy of this description updated with a given ServerDescription
       *
       * @param {ServerDescription} serverDescription
       */
      update(serverDescription) {
        const address = serverDescription.address;
        let topologyType = this.type;
        let setName = this.setName;
        let maxSetVersion = this.maxSetVersion;
        let maxElectionId = this.maxElectionId;
        let commonWireVersion = this.commonWireVersion;
        if (serverDescription.setName && setName && serverDescription.setName !== setName) {
          serverDescription = new ServerDescription(address, null);
        }
        const serverType = serverDescription.type;
        let serverDescriptions = new Map(this.servers);
        if (serverDescription.maxWireVersion !== 0) {
          if (commonWireVersion == null) {
            commonWireVersion = serverDescription.maxWireVersion;
          } else {
            commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
          }
        }
        serverDescriptions.set(address, serverDescription);
        if (topologyType === TopologyType.Single) {
          return new _TopologyDescription(
            TopologyType.Single,
            serverDescriptions,
            setName,
            maxSetVersion,
            maxElectionId,
            commonWireVersion,
            this.options
          );
        }
        if (topologyType === TopologyType.Unknown) {
          if (serverType === ServerType.Standalone && this.servers.size !== 1) {
            serverDescriptions.delete(address);
          } else {
            topologyType = topologyTypeForServerType(serverType);
          }
        }
        if (topologyType === TopologyType.Sharded) {
          if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {
            serverDescriptions.delete(address);
          }
        }
        if (topologyType === TopologyType.ReplicaSetNoPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
          }
          if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(
              serverDescriptions,
              setName,
              serverDescription,
              maxSetVersion,
              maxElectionId
            );
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);
            topologyType = result[0], setName = result[1];
          }
        }
        if (topologyType === TopologyType.ReplicaSetWithPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
            topologyType = checkHasPrimary(serverDescriptions);
          } else if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(
              serverDescriptions,
              setName,
              serverDescription,
              maxSetVersion,
              maxElectionId
            );
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            topologyType = updateRsWithPrimaryFromMember(
              serverDescriptions,
              setName,
              serverDescription
            );
          } else {
            topologyType = checkHasPrimary(serverDescriptions);
          }
        }
        return new _TopologyDescription(
          topologyType,
          serverDescriptions,
          setName,
          maxSetVersion,
          maxElectionId,
          commonWireVersion,
          this.options
        );
      }
      get error() {
        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
        if (descriptionsWithError.length > 0) {
          return descriptionsWithError[0].error;
        }
        return void 0;
      }
      /**
       * Determines if the topology description has any known servers
       */
      get hasKnownServers() {
        return Array.from(this.servers.values()).some((sd) => sd.type !== ServerType.Unknown);
      }
      /**
       * Determines if this topology description has a data-bearing server available.
       */
      get hasDataBearingServers() {
        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
      }
      /**
       * Determines if the topology has a definition for the provided address
       *
       * @param {String} address
       * @return {Boolean} Whether the topology knows about this server
       */
      hasServer(address) {
        return this.servers.has(address);
      }
    };
    function topologyTypeForServerType(serverType) {
      if (serverType === ServerType.Standalone) {
        return TopologyType.Single;
      }
      if (serverType === ServerType.Mongos) {
        return TopologyType.Sharded;
      }
      if (serverType === ServerType.RSPrimary) {
        return TopologyType.ReplicaSetWithPrimary;
      }
      if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function compareObjectId(oid1, oid2) {
      if (oid1 == null) {
        return -1;
      }
      if (oid2 == null) {
        return 1;
      }
      if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {
        const oid1Buffer = oid1.id;
        const oid2Buffer = oid2.id;
        return oid1Buffer.compare(oid2Buffer);
      }
      const oid1String = oid1.toString();
      const oid2String = oid2.toString();
      return oid1String.localeCompare(oid2String);
    }
    function updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {
            serverDescriptions.set(
              serverDescription.address,
              new ServerDescription(serverDescription.address)
            );
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
      for (const address of serverDescriptions.keys()) {
        const server = serverDescriptions.get(address);
        if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {
          serverDescriptions.set(address, new ServerDescription(server.address));
          break;
        }
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      const currentAddresses = Array.from(serverDescriptions.keys());
      const responseAddresses = serverDescription.allHosts;
      currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
        serverDescriptions.delete(address);
      });
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    function updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      if (setName == null) {
        throw new TypeError("setName is required");
      }
      if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return checkHasPrimary(serverDescriptions);
    }
    function updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      let topologyType = TopologyType.ReplicaSetNoPrimary;
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [topologyType, setName];
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return [topologyType, setName];
    }
    function checkHasPrimary(serverDescriptions) {
      for (const addr of serverDescriptions.keys()) {
        if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {
          return TopologyType.ReplicaSetWithPrimary;
        }
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    module2.exports = {
      TopologyDescription
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/shared.js
var require_shared = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/shared.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var MESSAGE_HEADER_SIZE = 16;
    var COMPRESSION_DETAILS_SIZE = 9;
    var opcodes = {
      OP_REPLY: 1,
      OP_UPDATE: 2001,
      OP_INSERT: 2002,
      OP_QUERY: 2004,
      OP_GETMORE: 2005,
      OP_DELETE: 2006,
      OP_KILL_CURSORS: 2007,
      OP_COMPRESSED: 2012,
      OP_MSG: 2013
    };
    var getReadPreference = function(cmd, options) {
      var readPreference = cmd.readPreference || new ReadPreference("primary");
      if (options.readPreference) {
        readPreference = options.readPreference;
      }
      if (typeof readPreference === "string") {
        readPreference = new ReadPreference(readPreference);
      }
      if (!(readPreference instanceof ReadPreference)) {
        throw new MongoError("read preference must be a ReadPreference instance");
      }
      return readPreference;
    };
    var parseHeader = function(message) {
      return {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
    };
    function applyCommonQueryOptions(queryOptions, options) {
      Object.assign(queryOptions, {
        raw: typeof options.raw === "boolean" ? options.raw : false,
        promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
        bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false,
        monitoring: typeof options.monitoring === "boolean" ? options.monitoring : false,
        fullResult: typeof options.fullResult === "boolean" ? options.fullResult : false
      });
      if (typeof options.socketTimeout === "number") {
        queryOptions.socketTimeout = options.socketTimeout;
      }
      if (options.session) {
        queryOptions.session = options.session;
      }
      if (typeof options.documentsReturnedIn === "string") {
        queryOptions.documentsReturnedIn = options.documentsReturnedIn;
      }
      return queryOptions;
    }
    function isSharded(topologyOrServer) {
      if (topologyOrServer.type === "mongos")
        return true;
      if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {
        return true;
      }
      if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {
        const servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some((server) => server.type === ServerType.Mongos);
      }
      return false;
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    module2.exports = {
      getReadPreference,
      MESSAGE_HEADER_SIZE,
      COMPRESSION_DETAILS_SIZE,
      opcodes,
      parseHeader,
      applyCommonQueryOptions,
      isSharded,
      databaseNamespace,
      collectionNamespace
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/compression.js
var require_compression = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/compression.js"(exports2, module2) {
    "use strict";
    var Snappy = require_utils4().retrieveSnappy();
    var zlib = __require("zlib");
    var compressorIDs = {
      snappy: 1,
      zlib: 2
    };
    var uncompressibleCommands = /* @__PURE__ */ new Set([
      "ismaster",
      "saslStart",
      "saslContinue",
      "getnonce",
      "authenticate",
      "createUser",
      "updateUser",
      "copydbSaslStart",
      "copydbgetnonce",
      "copydb"
    ]);
    function compress(self2, dataToBeCompressed, callback) {
      switch (self2.options.agreedCompressor) {
        case "snappy":
          Snappy.compress(dataToBeCompressed, callback);
          break;
        case "zlib":
          var zlibOptions = {};
          if (self2.options.zlibCompressionLevel) {
            zlibOptions.level = self2.options.zlibCompressionLevel;
          }
          zlib.deflate(dataToBeCompressed, zlibOptions, callback);
          break;
        default:
          throw new Error(
            'Attempt to compress message using unknown compressor "' + self2.options.agreedCompressor + '".'
          );
      }
    }
    function decompress(compressorID, compressedData, callback) {
      if (compressorID < 0 || compressorID > compressorIDs.length) {
        throw new Error(
          "Server sent message compressed using an unsupported compressor. (Received compressor ID " + compressorID + ")"
        );
      }
      switch (compressorID) {
        case compressorIDs.snappy:
          Snappy.uncompress(compressedData, callback);
          break;
        case compressorIDs.zlib:
          zlib.inflate(compressedData, callback);
          break;
        default:
          callback(null, compressedData);
      }
    }
    module2.exports = {
      compressorIDs,
      uncompressibleCommands,
      compress,
      decompress
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/mongodb/lib/core/connection/commands.js
var require_commands = __commonJS({
  "node_modules/mongodb/lib/core/connection/commands.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils4().retrieveBSON;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var Buffer2 = require_safe_buffer().Buffer;
    var _requestId = 0;
    var opcodes = require_shared().opcodes;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SLAVE = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 1;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var Query = function(bson, ns, query, options) {
      var self2 = this;
      if (ns == null)
        throw new Error("ns must be specified for query");
      if (query == null)
        throw new Error("query must be specified for query");
      if (ns.indexOf("\0") !== -1) {
        throw new Error("namespace cannot contain a null character");
      }
      this.bson = bson;
      this.ns = ns;
      this.query = query;
      this.numberToSkip = options.numberToSkip || 0;
      this.numberToReturn = options.numberToReturn || 0;
      this.returnFieldSelector = options.returnFieldSelector || null;
      this.requestId = Query.getRequestId();
      this.pre32Limit = options.pre32Limit;
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : true;
      this.batchSize = self2.numberToReturn;
      this.tailable = false;
      this.slaveOk = typeof options.slaveOk === "boolean" ? options.slaveOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    };
    Query.prototype.incRequestId = function() {
      this.requestId = _requestId++;
    };
    Query.nextRequestId = function() {
      return _requestId + 1;
    };
    Query.prototype.toBin = function() {
      var self2 = this;
      var buffers = [];
      var projection = null;
      var flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.slaveOk) {
        flags |= OPTS_SLAVE;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (self2.batchSize !== self2.numberToReturn)
        self2.numberToReturn = self2.batchSize;
      var header = Buffer2.alloc(
        4 * 4 + // Header
        4 + // Flags
        Buffer2.byteLength(self2.ns) + 1 + // namespace
        4 + // numberToSkip
        4
        // numberToReturn
      );
      buffers.push(header);
      var query = self2.bson.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (self2.returnFieldSelector && Object.keys(self2.returnFieldSelector).length > 0) {
        projection = self2.bson.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      var totalLength = header.length + query.length + (projection ? projection.length : 0);
      var index = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index + 3] = this.requestId >> 24 & 255;
      header[index + 2] = this.requestId >> 16 & 255;
      header[index + 1] = this.requestId >> 8 & 255;
      header[index] = this.requestId & 255;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 255;
      header[index + 2] = 0 >> 16 & 255;
      header[index + 1] = 0 >> 8 & 255;
      header[index] = 0 & 255;
      index = index + 4;
      header[index + 3] = opcodes.OP_QUERY >> 24 & 255;
      header[index + 2] = opcodes.OP_QUERY >> 16 & 255;
      header[index + 1] = opcodes.OP_QUERY >> 8 & 255;
      header[index] = opcodes.OP_QUERY & 255;
      index = index + 4;
      header[index + 3] = flags >> 24 & 255;
      header[index + 2] = flags >> 16 & 255;
      header[index + 1] = flags >> 8 & 255;
      header[index] = flags & 255;
      index = index + 4;
      index = index + header.write(this.ns, index, "utf8") + 1;
      header[index - 1] = 0;
      header[index + 3] = this.numberToSkip >> 24 & 255;
      header[index + 2] = this.numberToSkip >> 16 & 255;
      header[index + 1] = this.numberToSkip >> 8 & 255;
      header[index] = this.numberToSkip & 255;
      index = index + 4;
      header[index + 3] = this.numberToReturn >> 24 & 255;
      header[index + 2] = this.numberToReturn >> 16 & 255;
      header[index + 1] = this.numberToReturn >> 8 & 255;
      header[index] = this.numberToReturn & 255;
      index = index + 4;
      return buffers;
    };
    Query.getRequestId = function() {
      return ++_requestId;
    };
    var GetMore = function(bson, ns, cursorId, opts) {
      opts = opts || {};
      this.numberToReturn = opts.numberToReturn || 0;
      this.requestId = _requestId++;
      this.bson = bson;
      this.ns = ns;
      this.cursorId = cursorId;
    };
    GetMore.prototype.toBin = function() {
      var length = 4 + Buffer2.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4;
      var index = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index + 3] = length >> 24 & 255;
      _buffer[index + 2] = length >> 16 & 255;
      _buffer[index + 1] = length >> 8 & 255;
      _buffer[index] = length & 255;
      index = index + 4;
      _buffer[index + 3] = this.requestId >> 24 & 255;
      _buffer[index + 2] = this.requestId >> 16 & 255;
      _buffer[index + 1] = this.requestId >> 8 & 255;
      _buffer[index] = this.requestId & 255;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 255;
      _buffer[index + 2] = 0 >> 16 & 255;
      _buffer[index + 1] = 0 >> 8 & 255;
      _buffer[index] = 0 & 255;
      index = index + 4;
      _buffer[index + 3] = opcodes.OP_GETMORE >> 24 & 255;
      _buffer[index + 2] = opcodes.OP_GETMORE >> 16 & 255;
      _buffer[index + 1] = opcodes.OP_GETMORE >> 8 & 255;
      _buffer[index] = opcodes.OP_GETMORE & 255;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 255;
      _buffer[index + 2] = 0 >> 16 & 255;
      _buffer[index + 1] = 0 >> 8 & 255;
      _buffer[index] = 0 & 255;
      index = index + 4;
      index = index + _buffer.write(this.ns, index, "utf8") + 1;
      _buffer[index - 1] = 0;
      _buffer[index + 3] = this.numberToReturn >> 24 & 255;
      _buffer[index + 2] = this.numberToReturn >> 16 & 255;
      _buffer[index + 1] = this.numberToReturn >> 8 & 255;
      _buffer[index] = this.numberToReturn & 255;
      index = index + 4;
      _buffer[index + 3] = this.cursorId.getLowBits() >> 24 & 255;
      _buffer[index + 2] = this.cursorId.getLowBits() >> 16 & 255;
      _buffer[index + 1] = this.cursorId.getLowBits() >> 8 & 255;
      _buffer[index] = this.cursorId.getLowBits() & 255;
      index = index + 4;
      _buffer[index + 3] = this.cursorId.getHighBits() >> 24 & 255;
      _buffer[index + 2] = this.cursorId.getHighBits() >> 16 & 255;
      _buffer[index + 1] = this.cursorId.getHighBits() >> 8 & 255;
      _buffer[index] = this.cursorId.getHighBits() & 255;
      index = index + 4;
      return _buffer;
    };
    var KillCursor = function(bson, ns, cursorIds) {
      this.ns = ns;
      this.requestId = _requestId++;
      this.cursorIds = cursorIds;
    };
    KillCursor.prototype.toBin = function() {
      var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8;
      var index = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index + 3] = length >> 24 & 255;
      _buffer[index + 2] = length >> 16 & 255;
      _buffer[index + 1] = length >> 8 & 255;
      _buffer[index] = length & 255;
      index = index + 4;
      _buffer[index + 3] = this.requestId >> 24 & 255;
      _buffer[index + 2] = this.requestId >> 16 & 255;
      _buffer[index + 1] = this.requestId >> 8 & 255;
      _buffer[index] = this.requestId & 255;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 255;
      _buffer[index + 2] = 0 >> 16 & 255;
      _buffer[index + 1] = 0 >> 8 & 255;
      _buffer[index] = 0 & 255;
      index = index + 4;
      _buffer[index + 3] = opcodes.OP_KILL_CURSORS >> 24 & 255;
      _buffer[index + 2] = opcodes.OP_KILL_CURSORS >> 16 & 255;
      _buffer[index + 1] = opcodes.OP_KILL_CURSORS >> 8 & 255;
      _buffer[index] = opcodes.OP_KILL_CURSORS & 255;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 255;
      _buffer[index + 2] = 0 >> 16 & 255;
      _buffer[index + 1] = 0 >> 8 & 255;
      _buffer[index] = 0 & 255;
      index = index + 4;
      _buffer[index + 3] = this.cursorIds.length >> 24 & 255;
      _buffer[index + 2] = this.cursorIds.length >> 16 & 255;
      _buffer[index + 1] = this.cursorIds.length >> 8 & 255;
      _buffer[index] = this.cursorIds.length & 255;
      index = index + 4;
      for (var i = 0; i < this.cursorIds.length; i++) {
        _buffer[index + 3] = this.cursorIds[i].getLowBits() >> 24 & 255;
        _buffer[index + 2] = this.cursorIds[i].getLowBits() >> 16 & 255;
        _buffer[index + 1] = this.cursorIds[i].getLowBits() >> 8 & 255;
        _buffer[index] = this.cursorIds[i].getLowBits() & 255;
        index = index + 4;
        _buffer[index + 3] = this.cursorIds[i].getHighBits() >> 24 & 255;
        _buffer[index + 2] = this.cursorIds[i].getHighBits() >> 16 & 255;
        _buffer[index + 1] = this.cursorIds[i].getHighBits() >> 8 & 255;
        _buffer[index] = this.cursorIds[i].getHighBits() & 255;
        index = index + 4;
      }
      return _buffer;
    };
    var Response = function(bson, message, msgHeader, msgBody, opts) {
      opts = opts || {
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.bson = bson;
      this.opts = opts;
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.cursorId = new Long2(msgBody.readInt32LE(4), msgBody.readInt32LE(8));
      this.startingFrom = msgBody.readInt32LE(12);
      this.numberReturned = msgBody.readInt32LE(16);
      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
      this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
      this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
      this.bsonRegExp = typeof opts.bsonRegExp === "boolean" ? opts.bsonRegExp : false;
    };
    Response.prototype.isParsed = function() {
      return this.parsed;
    };
    Response.prototype.parse = function(options) {
      if (this.parsed)
        return;
      options = options || {};
      var raw = options.raw || false;
      var documentsReturnedIn = options.documentsReturnedIn || null;
      var promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : this.opts.promoteLongs;
      var promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : this.opts.promoteValues;
      var promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : this.opts.promoteBuffers;
      var bsonRegExp = typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : this.opts.bsonRegExp;
      var bsonSize, _options;
      _options = {
        promoteLongs,
        promoteValues,
        promoteBuffers,
        bsonRegExp
      };
      this.index = 20;
      for (var i = 0; i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = this.bson.deserialize(
            this.data.slice(this.index, this.index + bsonSize),
            _options
          );
        }
        this.index = this.index + bsonSize;
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc = this.bson.deserialize(this.documents[0], _options);
        this.documents = [doc];
      }
      this.parsed = true;
    };
    module2.exports = {
      Query,
      GetMore,
      Response,
      KillCursor
    };
  }
});

// node_modules/mongodb/lib/core/connection/msg.js
var require_msg = __commonJS({
  "node_modules/mongodb/lib/core/connection/msg.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var opcodes = require_shared().opcodes;
    var databaseNamespace = require_shared().databaseNamespace;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var _requestId = 0;
    var OPTS_CHECKSUM_PRESENT = 1;
    var OPTS_MORE_TO_COME = 2;
    var OPTS_EXHAUST_ALLOWED = 1 << 16;
    var Msg = class _Msg {
      constructor(bson, ns, command, options) {
        if (command == null)
          throw new Error("query must be specified for query");
        this.bson = bson;
        this.ns = ns;
        this.command = command;
        this.command.$db = databaseNamespace(ns);
        if (options.readPreference && options.readPreference.mode !== ReadPreference.PRIMARY) {
          this.command.$readPreference = options.readPreference.toJSON();
        }
        this.options = options || {};
        this.requestId = options.requestId ? options.requestId : _Msg.getRequestId();
        this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
        this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
        this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
        this.checksumPresent = false;
        this.moreToCome = options.moreToCome || false;
        this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
      }
      toBin() {
        const buffers = [];
        let flags = 0;
        if (this.checksumPresent) {
          flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
          flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
          flags |= OPTS_EXHAUST_ALLOWED;
        }
        const header = Buffer2.alloc(
          4 * 4 + // Header
          4
          // Flags
        );
        buffers.push(header);
        let totalLength = header.length;
        const command = this.command;
        totalLength += this.makeDocumentSegment(buffers, command);
        header.writeInt32LE(totalLength, 0);
        header.writeInt32LE(this.requestId, 4);
        header.writeInt32LE(0, 8);
        header.writeInt32LE(opcodes.OP_MSG, 12);
        header.writeUInt32LE(flags, 16);
        return buffers;
      }
      makeDocumentSegment(buffers, document) {
        const payloadTypeBuffer = Buffer2.alloc(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document);
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        return payloadTypeBuffer.length + documentBuffer.length;
      }
      serializeBson(document) {
        return this.bson.serialize(document, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
      }
    };
    Msg.getRequestId = function() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    };
    var BinMsg = class {
      constructor(bson, message, msgHeader, msgBody, opts) {
        opts = opts || {
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false
        };
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.bson = bson;
        this.opts = opts;
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
        this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
        this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
        this.bsonRegExp = typeof opts.bsonRegExp === "boolean" ? opts.bsonRegExp : false;
        this.documents = [];
      }
      isParsed() {
        return this.parsed;
      }
      parse(options) {
        if (this.parsed)
          return;
        options = options || {};
        this.index = 4;
        const raw = options.raw || false;
        const documentsReturnedIn = options.documentsReturnedIn || null;
        const promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : this.opts.promoteLongs;
        const promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : this.opts.promoteValues;
        const promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : this.opts.promoteBuffers;
        const bsonRegExp = typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : this.opts.bsonRegExp;
        const _options = {
          promoteLongs,
          promoteValues,
          promoteBuffers,
          bsonRegExp
        };
        while (this.index < this.data.length) {
          const payloadType = this.data.readUInt8(this.index++);
          if (payloadType === 1) {
            throw new MongoError("OP_MSG Payload Type 1 detected unsupported protocol");
          } else if (payloadType === 0) {
            const bsonSize = this.data.readUInt32LE(this.index);
            const bin = this.data.slice(this.index, this.index + bsonSize);
            this.documents.push(raw ? bin : this.bson.deserialize(bin, _options));
            this.index += bsonSize;
          }
        }
        if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
          const fieldsAsRaw = {};
          fieldsAsRaw[documentsReturnedIn] = true;
          _options.fieldsAsRaw = fieldsAsRaw;
          const doc = this.bson.deserialize(this.documents[0], _options);
          this.documents = [doc];
        }
        this.parsed = true;
      }
    };
    module2.exports = { Msg, BinMsg };
  }
});

// node_modules/mongodb/lib/core/connection/logger.js
var require_logger = __commonJS({
  "node_modules/mongodb/lib/core/connection/logger.js"(exports2, module2) {
    "use strict";
    var f = __require("util").format;
    var MongoError = require_error().MongoError;
    var classFilters = {};
    var filteredClasses = {};
    var level = null;
    var pid = process.pid;
    var currentLogger = null;
    var Logger = function(className, options) {
      if (!(this instanceof Logger))
        return new Logger(className, options);
      options = options || {};
      this.className = className;
      if (options.logger) {
        currentLogger = options.logger;
      } else if (currentLogger == null) {
        currentLogger = console.log;
      }
      if (options.loggerLevel) {
        level = options.loggerLevel || "error";
      }
      if (filteredClasses[this.className] == null)
        classFilters[this.className] = true;
    };
    Logger.prototype.debug = function(message, object2) {
      if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = (/* @__PURE__ */ new Date()).getTime();
        var msg = f("[%s-%s:%s] %s %s", "DEBUG", this.className, pid, dateTime, message);
        var state = {
          type: "debug",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object2)
          state.meta = object2;
        currentLogger(msg, state);
      }
    };
    Logger.prototype.warn = function(message, object2) {
      if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = (/* @__PURE__ */ new Date()).getTime();
        var msg = f("[%s-%s:%s] %s %s", "WARN", this.className, pid, dateTime, message);
        var state = {
          type: "warn",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object2)
          state.meta = object2;
        currentLogger(msg, state);
      }
    }, /**
     * Log a message at the info level
     * @method
     * @param {string} message The message to log
     * @param {object} object additional meta data to log
     * @return {null}
     */
    Logger.prototype.info = function(message, object2) {
      if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = (/* @__PURE__ */ new Date()).getTime();
        var msg = f("[%s-%s:%s] %s %s", "INFO", this.className, pid, dateTime, message);
        var state = {
          type: "info",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object2)
          state.meta = object2;
        currentLogger(msg, state);
      }
    }, /**
     * Log a message at the error level
     * @method
     * @param {string} message The message to log
     * @param {object} object additional meta data to log
     * @return {null}
     */
    Logger.prototype.error = function(message, object2) {
      if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = (/* @__PURE__ */ new Date()).getTime();
        var msg = f("[%s-%s:%s] %s %s", "ERROR", this.className, pid, dateTime, message);
        var state = {
          type: "error",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object2)
          state.meta = object2;
        currentLogger(msg, state);
      }
    }, /**
     * Is the logger set at info level
     * @method
     * @return {boolean}
     */
    Logger.prototype.isInfo = function() {
      return level === "info" || level === "debug";
    }, /**
     * Is the logger set at error level
     * @method
     * @return {boolean}
     */
    Logger.prototype.isError = function() {
      return level === "error" || level === "info" || level === "debug";
    }, /**
     * Is the logger set at error level
     * @method
     * @return {boolean}
     */
    Logger.prototype.isWarn = function() {
      return level === "error" || level === "warn" || level === "info" || level === "debug";
    }, /**
     * Is the logger set at debug level
     * @method
     * @return {boolean}
     */
    Logger.prototype.isDebug = function() {
      return level === "debug";
    };
    Logger.reset = function() {
      level = "error";
      filteredClasses = {};
    };
    Logger.currentLogger = function() {
      return currentLogger;
    };
    Logger.setCurrentLogger = function(logger) {
      if (typeof logger !== "function")
        throw new MongoError("current logger must be a function");
      currentLogger = logger;
    };
    Logger.filter = function(type, values) {
      if (type === "class" && Array.isArray(values)) {
        filteredClasses = {};
        values.forEach(function(x) {
          filteredClasses[x] = true;
        });
      }
    };
    Logger.setLevel = function(_level) {
      if (_level !== "info" && _level !== "error" && _level !== "debug" && _level !== "warn") {
        throw new Error(f("%s is an illegal logging level", _level));
      }
      level = _level;
    };
    module2.exports = Logger;
  }
});

// node_modules/mongodb/lib/core/connection/command_result.js
var require_command_result = __commonJS({
  "node_modules/mongodb/lib/core/connection/command_result.js"(exports2, module2) {
    "use strict";
    var CommandResult = function(result, connection, message) {
      this.result = result;
      this.connection = connection;
      this.message = message;
    };
    CommandResult.prototype.toJSON = function() {
      let result = Object.assign({}, this, this.result);
      delete result.message;
      return result;
    };
    CommandResult.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    module2.exports = CommandResult;
  }
});

// node_modules/mongodb/lib/core/connection/connection.js
var require_connection = __commonJS({
  "node_modules/mongodb/lib/core/connection/connection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var crypto = __require("crypto");
    var debugOptions = require_utils4().debugOptions;
    var parseHeader = require_shared().parseHeader;
    var decompress = require_compression().decompress;
    var Response = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoError = require_error().MongoError;
    var Logger = require_logger();
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var Buffer2 = require_safe_buffer().Buffer;
    var Query = require_commands().Query;
    var CommandResult = require_command_result();
    var _id = 0;
    var DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;
    var DEBUG_FIELDS = [
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "checkServerIdentity"
    ];
    var connectionAccountingSpy = void 0;
    var connectionAccounting = false;
    var connections = {};
    var Connection2 = class extends EventEmitter {
      /**
       * Creates a new Connection instance
       *
       * **NOTE**: Internal class, do not instantiate directly
       *
       * @param {Socket} socket The socket this connection wraps
       * @param {Object} options Various settings
       * @param {object} options.bson An implementation of bson serialize and deserialize
       * @param {string} [options.host='localhost'] The host the socket is connected to
       * @param {number} [options.port=27017] The port used for the socket connection
       * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
       * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled
       * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting
       * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
       * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits
       * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
       * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.
       * @param {boolean} [options.bsonRegExp] By default, regex returned from MDB will be native to the language. Setting to true will ensure that a BSON.BSONRegExp object is returned.
       * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)
       */
      constructor(socket, options) {
        super();
        options = options || {};
        if (!options.bson) {
          throw new TypeError("must pass in valid bson parser");
        }
        this.id = _id++;
        this.options = options;
        this.logger = Logger("Connection", options);
        this.bson = options.bson;
        this.tag = options.tag;
        this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;
        this.helloOk = void 0;
        this.port = options.port || 27017;
        this.host = options.host || "localhost";
        this.socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
        this.keepAlive = typeof options.keepAlive === "boolean" ? options.keepAlive : true;
        this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === "number" ? options.keepAliveInitialDelay : 12e4;
        this.connectionTimeout = typeof options.connectionTimeout === "number" ? options.connectionTimeout : 3e4;
        if (this.keepAliveInitialDelay > this.socketTimeout) {
          this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);
        }
        if (this.logger.isDebug()) {
          this.logger.debug(
            `creating connection ${this.id} with options [${JSON.stringify(
              debugOptions(DEBUG_FIELDS, options)
            )}]`
          );
        }
        this.responseOptions = {
          promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
          promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
          promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
          bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false
        };
        this.flushing = false;
        this.queue = [];
        this.writeStream = null;
        this.destroyed = false;
        this.timedOut = false;
        const hash2 = crypto.createHash("sha1");
        hash2.update(this.address);
        this.hashedName = hash2.digest("hex");
        this.workItems = [];
        this.socket = socket;
        this.socket.once("error", errorHandler(this));
        this.socket.once("timeout", timeoutHandler(this));
        this.socket.once("close", closeHandler(this));
        this.socket.on("data", dataHandler(this));
        if (connectionAccounting) {
          addConnection(this.id, this);
        }
      }
      setSocketTimeout(value2) {
        if (this.socket) {
          this.socket.setTimeout(value2);
        }
      }
      resetSocketTimeout() {
        if (this.socket) {
          this.socket.setTimeout(this.socketTimeout);
        }
      }
      static enableConnectionAccounting(spy) {
        if (spy) {
          connectionAccountingSpy = spy;
        }
        connectionAccounting = true;
        connections = {};
      }
      static disableConnectionAccounting() {
        connectionAccounting = false;
        connectionAccountingSpy = void 0;
      }
      static connections() {
        return connections;
      }
      get address() {
        return `${this.host}:${this.port}`;
      }
      /**
       * Unref this connection
       * @method
       * @return {boolean}
       * @deprecated This function is deprecated and will be removed in the next major version.
       */
      unref() {
        if (this.socket == null) {
          this.once("connect", () => this.socket.unref());
          return;
        }
        this.socket.unref();
      }
      /**
       * Flush all work Items on this connection
       *
       * @param {*} err The error to propagate to the flushed work items
       */
      flush(err) {
        while (this.workItems.length > 0) {
          const workItem = this.workItems.shift();
          if (workItem.cb) {
            workItem.cb(err);
          }
        }
      }
      /**
       * Destroy connection
       * @method
       */
      destroy(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = Object.assign({ force: false }, options);
        if (connectionAccounting) {
          deleteConnection(this.id);
        }
        if (this.socket == null) {
          this.destroyed = true;
          return;
        }
        if (options.force || this.timedOut) {
          this.socket.destroy();
          this.destroyed = true;
          if (typeof callback === "function")
            callback(null, null);
          return;
        }
        this.socket.end((err) => {
          this.destroyed = true;
          if (typeof callback === "function")
            callback(err, null);
        });
      }
      /**
       * Write to connection
       * @method
       * @param {Command} command Command to write out need to implement toBin and toBinUnified
       */
      write(buffer) {
        if (this.logger.isDebug()) {
          if (!Array.isArray(buffer)) {
            this.logger.debug(`writing buffer [ ${buffer.length} ] to ${this.address}`);
          } else {
            for (let i = 0; i < buffer.length; i++)
              this.logger.debug(`writing buffer [ ${buffer[i].length} ] to ${this.address}`);
          }
        }
        if (this.socket.destroyed === false) {
          if (!Array.isArray(buffer)) {
            this.socket.write(buffer, "binary");
            return true;
          }
          for (let i = 0; i < buffer.length; i++) {
            this.socket.write(buffer[i], "binary");
          }
          return true;
        }
        return false;
      }
      /**
       * Return id of connection as a string
       * @method
       * @return {string}
       */
      toString() {
        return "" + this.id;
      }
      /**
       * Return json object of connection
       * @method
       * @return {object}
       */
      toJSON() {
        return { id: this.id, host: this.host, port: this.port };
      }
      /**
       * Is the connection connected
       * @method
       * @return {boolean}
       */
      isConnected() {
        if (this.destroyed)
          return false;
        return !this.socket.destroyed && this.socket.writable;
      }
      /**
       * @ignore
       */
      command(ns, command, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        const conn = this;
        const socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
        const bson = conn.options.bson;
        const query = new Query(bson, ns, command, {
          numberToSkip: 0,
          numberToReturn: 1
        });
        const noop = () => {
        };
        function _callback(err, result) {
          callback(err, result);
          callback = noop;
        }
        function errorHandler2(err) {
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          if (err == null) {
            err = new MongoError(`runCommand failed for connection to '${conn.address}'`);
          }
          conn.on("error", noop);
          _callback(err);
        }
        function messageHandler(msg) {
          if (msg.responseTo !== query.requestId) {
            return;
          }
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          msg.parse({ promoteValues: true });
          const response = msg.documents[0];
          if (response.ok === 0 || response.$err || response.errmsg || response.code) {
            _callback(new MongoError(response));
            return;
          }
          _callback(void 0, new CommandResult(response, this, msg));
        }
        conn.setSocketTimeout(socketTimeout);
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.once(eventName, errorHandler2));
        conn.on("message", messageHandler);
        conn.write(query.toBin());
      }
    };
    var CONNECTION_ERROR_EVENTS = ["error", "close", "timeout", "parseError"];
    function deleteConnection(id) {
      delete connections[id];
      if (connectionAccountingSpy) {
        connectionAccountingSpy.deleteConnection(id);
      }
    }
    function addConnection(id, connection) {
      connections[id] = connection;
      if (connectionAccountingSpy) {
        connectionAccountingSpy.addConnection(id, connection);
      }
    }
    function errorHandler(conn) {
      return function(err) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(
            `connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`
          );
        }
        conn.emit("error", new MongoNetworkError(err), conn);
      };
    }
    function timeoutHandler(conn) {
      return function() {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);
        }
        conn.timedOut = true;
        conn.emit(
          "timeout",
          new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {
            beforeHandshake: conn.ismaster == null
          }),
          conn
        );
      };
    }
    function closeHandler(conn) {
      return function(hadError) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);
        }
        if (!hadError) {
          conn.emit(
            "close",
            new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`),
            conn
          );
        }
      };
    }
    function processMessage(conn, message) {
      const msgHeader = parseHeader(message);
      if (msgHeader.opCode !== OP_COMPRESSED) {
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
        conn.emit(
          "message",
          new ResponseConstructor(
            conn.bson,
            message,
            msgHeader,
            message.slice(MESSAGE_HEADER_SIZE),
            conn.responseOptions
          ),
          conn
        );
        return;
      }
      msgHeader.fromCompressed = true;
      let index = MESSAGE_HEADER_SIZE;
      msgHeader.opCode = message.readInt32LE(index);
      index += 4;
      msgHeader.length = message.readInt32LE(index);
      index += 4;
      const compressorID = message[index];
      index++;
      decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {
        if (err) {
          conn.emit("error", err);
          return;
        }
        if (decompressedMsgBody.length !== msgHeader.length) {
          conn.emit(
            "error",
            new MongoError(
              "Decompressing a compressed message from the server failed. The message is corrupt."
            )
          );
          return;
        }
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;
        conn.emit(
          "message",
          new ResponseConstructor(
            conn.bson,
            message,
            msgHeader,
            decompressedMsgBody,
            conn.responseOptions
          ),
          conn
        );
      });
    }
    function dataHandler(conn) {
      return function(data) {
        while (data.length > 0) {
          if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {
            const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;
            if (remainingBytesToRead > data.length) {
              data.copy(conn.buffer, conn.bytesRead);
              conn.bytesRead = conn.bytesRead + data.length;
              data = Buffer2.alloc(0);
            } else {
              data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);
              data = data.slice(remainingBytesToRead);
              const emitBuffer = conn.buffer;
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
              processMessage(conn, emitBuffer);
            }
          } else {
            if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {
              if (conn.stubBuffer.length + data.length > 4) {
                const newData = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newData, 0);
                data.copy(newData, conn.stubBuffer.length);
                data = newData;
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
              } else {
                const newStubBuffer = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newStubBuffer, 0);
                data.copy(newStubBuffer, conn.stubBuffer.length);
                data = Buffer2.alloc(0);
              }
            } else {
              if (data.length > 4) {
                const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
                if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: "",
                    bin: conn.buffer,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: conn.bytesRead,
                      stubBuffer: conn.stubBuffer
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  return;
                }
                if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {
                  conn.buffer = Buffer2.alloc(sizeOfMessage);
                  data.copy(conn.buffer, 0);
                  conn.bytesRead = data.length;
                  conn.sizeOfMessage = sizeOfMessage;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {
                  const emitBuffer = data;
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                  processMessage(conn, emitBuffer);
                } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: null,
                    bin: data,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: 0,
                      buffer: null,
                      stubBuffer: null
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else {
                  const emitBuffer = data.slice(0, sizeOfMessage);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = data.slice(sizeOfMessage);
                  processMessage(conn, emitBuffer);
                }
              } else {
                conn.stubBuffer = Buffer2.alloc(data.length);
                data.copy(conn.stubBuffer, 0);
                data = Buffer2.alloc(0);
              }
            }
          }
        }
      };
    }
    module2.exports = Connection2;
  }
});

// node_modules/mongodb/lib/command_utils.js
var require_command_utils = __commonJS({
  "node_modules/mongodb/lib/command_utils.js"(exports2, module2) {
    "use strict";
    var Msg = require_msg().Msg;
    var KillCursor = require_commands().KillCursor;
    var GetMore = require_commands().GetMore;
    var deepCopy = require_utils().deepCopy;
    var SENSITIVE_COMMANDS = /* @__PURE__ */ new Set([
      "authenticate",
      "saslStart",
      "saslContinue",
      "getnonce",
      "createUser",
      "updateUser",
      "copydbgetnonce",
      "copydbsaslstart",
      "copydb"
    ]);
    var HELLO_COMMANDS = /* @__PURE__ */ new Set(["hello", "ismaster", "isMaster"]);
    var LEGACY_FIND_QUERY_MAP = {
      $query: "filter",
      $orderby: "sort",
      $hint: "hint",
      $comment: "comment",
      $maxScan: "maxScan",
      $max: "max",
      $min: "min",
      $returnKey: "returnKey",
      $showDiskLoc: "showRecordId",
      $maxTimeMS: "maxTimeMS",
      $snapshot: "snapshot"
    };
    var LEGACY_FIND_OPTIONS_MAP = {
      numberToSkip: "skip",
      numberToReturn: "batchSize",
      returnFieldsSelector: "projection"
    };
    var OP_QUERY_KEYS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "partial",
      "exhaust"
    ];
    var collectionName = (command) => command.ns.split(".")[1];
    var shouldRedactCommand = (commandName, cmd) => SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && !!cmd.speculativeAuthenticate;
    var extractCommand = (command) => {
      let extractedCommand;
      if (command instanceof GetMore) {
        extractedCommand = {
          getMore: deepCopy(command.cursorId),
          collection: collectionName(command),
          batchSize: command.numberToReturn
        };
      } else if (command instanceof KillCursor) {
        extractedCommand = {
          killCursors: collectionName(command),
          cursors: deepCopy(command.cursorIds)
        };
      } else if (command instanceof Msg) {
        extractedCommand = deepCopy(command.command);
      } else if (command.query && command.query.$query) {
        let result;
        if (command.ns === "admin.$cmd") {
          result = Object.assign({}, command.query.$query);
        } else {
          result = { find: collectionName(command) };
          Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
            if (typeof command.query[key] !== "undefined")
              result[LEGACY_FIND_QUERY_MAP[key]] = deepCopy(command.query[key]);
          });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
          if (typeof command[key] !== "undefined")
            result[LEGACY_FIND_OPTIONS_MAP[key]] = deepCopy(command[key]);
        });
        OP_QUERY_KEYS.forEach((key) => {
          if (command[key])
            result[key] = command[key];
        });
        if (typeof command.pre32Limit !== "undefined") {
          result.limit = command.pre32Limit;
        }
        if (command.query.$explain) {
          extractedCommand = { explain: result };
        } else {
          extractedCommand = result;
        }
      } else {
        extractedCommand = deepCopy(command.query || command);
      }
      const commandName = Object.keys(extractedCommand)[0];
      return {
        cmd: extractedCommand,
        name: commandName,
        shouldRedact: shouldRedactCommand(commandName, extractedCommand)
      };
    };
    module2.exports = {
      extractCommand
    };
  }
});

// node_modules/mongodb/lib/core/connection/apm.js
var require_apm = __commonJS({
  "node_modules/mongodb/lib/core/connection/apm.js"(exports2, module2) {
    "use strict";
    var KillCursor = require_commands().KillCursor;
    var GetMore = require_commands().GetMore;
    var calculateDurationInMs = require_utils().calculateDurationInMs;
    var extractCommand = require_command_utils().extractCommand;
    var namespace = (command) => command.ns;
    var databaseName = (command) => command.ns.split(".")[0];
    var generateConnectionId = (pool) => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;
    var isLegacyPool = (pool) => pool.s && pool.queue;
    var extractReply = (command, reply) => {
      if (command instanceof GetMore) {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            nextBatch: reply.message.documents
          }
        };
      }
      if (command instanceof KillCursor) {
        return {
          ok: 1,
          cursorsUnknown: command.cursorIds
        };
      }
      if (command.query && typeof command.query.$query !== "undefined") {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            firstBatch: reply.message.documents
          }
        };
      }
      return reply && reply.result ? reply.result : reply;
    };
    var extractConnectionDetails = (pool) => {
      if (isLegacyPool(pool)) {
        return {
          connectionId: generateConnectionId(pool)
        };
      }
      const connection = pool;
      return {
        address: connection.address,
        connectionId: connection.id
      };
    };
    var CommandStartedEvent = class {
      /**
       * Create a started event
       *
       * @param {Pool} pool the pool that originated the command
       * @param {Object} command the command
       */
      constructor(pool, command) {
        const extractedCommand = extractCommand(command);
        const commandName = extractedCommand.name;
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          databaseName: databaseName(command),
          commandName,
          command: extractedCommand.shouldRedact ? {} : extractedCommand.cmd
        });
      }
    };
    var CommandSucceededEvent = class {
      /**
       * Create a succeeded event
       *
       * @param {Pool} pool the pool that originated the command
       * @param {Object} command the command
       * @param {Object} reply the reply for this command from the server
       * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration
       */
      constructor(pool, command, reply, started) {
        const extractedCommand = extractCommand(command);
        const commandName = extractedCommand.name;
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          reply: extractedCommand.shouldRedact ? {} : extractReply(command, reply)
        });
      }
    };
    var CommandFailedEvent = class {
      /**
       * Create a failure event
       *
       * @param {Pool} pool the pool that originated the command
       * @param {Object} command the command
       * @param {MongoError|Object} error the generated error or a server error response
       * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration
       */
      constructor(pool, command, error, started) {
        const extractedCommand = extractCommand(command);
        const commandName = extractedCommand.name;
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          failure: extractedCommand.shouldRedact ? {} : error
        });
      }
    };
    module2.exports = {
      CommandStartedEvent,
      CommandSucceededEvent,
      CommandFailedEvent
    };
  }
});

// node_modules/mongodb/lib/core/auth/auth_provider.js
var require_auth_provider = __commonJS({
  "node_modules/mongodb/lib/core/auth/auth_provider.js"(exports2, module2) {
    "use strict";
    var AuthContext = class {
      constructor(connection, credentials, options) {
        this.connection = connection;
        this.credentials = credentials;
        this.options = options;
      }
    };
    var AuthProvider = class {
      constructor(bson) {
        this.bson = bson;
      }
      /**
       * Prepare the handshake document before the initial handshake.
       *
       * @param {object} handshakeDoc The document used for the initial handshake on a connection
       * @param {AuthContext} authContext Context for authentication flow
       * @param {function} callback
       */
      prepare(handshakeDoc, context, callback) {
        callback(void 0, handshakeDoc);
      }
      /**
       * Authenticate
       *
       * @param {AuthContext} context A shared context for authentication flow
       * @param {authResultCallback} callback The callback to return the result from the authentication
       */
      auth(context, callback) {
        callback(new TypeError("`auth` method must be overridden by subclass"));
      }
    };
    module2.exports = { AuthContext, AuthProvider };
  }
});

// node_modules/mongodb/lib/core/auth/mongocr.js
var require_mongocr = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongocr.js"(exports2, module2) {
    "use strict";
    var crypto = __require("crypto");
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCR = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const source = credentials.source;
        connection.command(`${source}.$cmd`, { getnonce: 1 }, (err, result) => {
          let nonce = null;
          let key = null;
          if (err == null) {
            const r = result.result;
            nonce = r.nonce;
            let md5 = crypto.createHash("md5");
            md5.update(username + ":mongo:" + password, "utf8");
            const hash_password = md5.digest("hex");
            md5 = crypto.createHash("md5");
            md5.update(nonce + username + hash_password, "utf8");
            key = md5.digest("hex");
          }
          const authenticateCommand = {
            authenticate: 1,
            user: username,
            nonce,
            key
          };
          connection.command(`${source}.$cmd`, authenticateCommand, callback);
        });
      }
    };
    module2.exports = MongoCR;
  }
});

// node_modules/mongodb/lib/core/auth/x509.js
var require_x509 = __commonJS({
  "node_modules/mongodb/lib/core/auth/x509.js"(exports2, module2) {
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var X509 = class extends AuthProvider {
      prepare(handshakeDoc, authContext, callback) {
        const credentials = authContext.credentials;
        Object.assign(handshakeDoc, {
          speculativeAuthenticate: x509AuthenticateCommand(credentials)
        });
        callback(void 0, handshakeDoc);
      }
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const response = authContext.response;
        if (response.speculativeAuthenticate) {
          return callback();
        }
        connection.command("$external.$cmd", x509AuthenticateCommand(credentials), callback);
      }
    };
    function x509AuthenticateCommand(credentials) {
      const command = { authenticate: 1, mechanism: "MONGODB-X509" };
      if (credentials.username) {
        Object.assign(command, { user: credentials.username });
      }
      return command;
    }
    module2.exports = X509;
  }
});

// node_modules/mongodb/lib/core/auth/plain.js
var require_plain = __commonJS({
  "node_modules/mongodb/lib/core/auth/plain.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils4().retrieveBSON;
    var AuthProvider = require_auth_provider().AuthProvider;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var Plain = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const payload = new Binary2(`\0${username}\0${password}`);
        const command = {
          saslStart: 1,
          mechanism: "PLAIN",
          payload,
          autoAuthorize: 1
        };
        connection.command("$external.$cmd", command, callback);
      }
    };
    module2.exports = Plain;
  }
});

// node_modules/mongodb/lib/core/auth/gssapi.js
var require_gssapi = __commonJS({
  "node_modules/mongodb/lib/core/auth/gssapi.js"(exports2, module2) {
    "use strict";
    var dns = __require("dns");
    var AuthProvider = require_auth_provider().AuthProvider;
    var retrieveKerberos = require_utils3().retrieveKerberos;
    var MongoError = require_error().MongoError;
    var kerberos;
    var GSSAPI = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (credentials == null)
          return callback(new MongoError("credentials required"));
        const username = credentials.username;
        function externalCommand(command, cb) {
          return connection.command("$external.$cmd", command, cb);
        }
        makeKerberosClient(authContext, (err, client) => {
          if (err)
            return callback(err);
          if (client == null)
            return callback(new MongoError("gssapi client missing"));
          client.step("", (err2, payload) => {
            if (err2)
              return callback(err2);
            externalCommand(saslStart(payload), (err3, response) => {
              if (err3)
                return callback(err3);
              const result = response.result;
              negotiate(client, 10, result.payload, (err4, payload2) => {
                if (err4)
                  return callback(err4);
                externalCommand(saslContinue(payload2, result.conversationId), (err5, response2) => {
                  if (err5)
                    return callback(err5);
                  const result2 = response2.result;
                  finalize(client, username, result2.payload, (err6, payload3) => {
                    if (err6)
                      return callback(err6);
                    externalCommand(
                      {
                        saslContinue: 1,
                        conversationId: result2.conversationId,
                        payload: payload3
                      },
                      (err7, result3) => {
                        if (err7)
                          return callback(err7);
                        callback(void 0, result3);
                      }
                    );
                  });
                });
              });
            });
          });
        });
      }
    };
    module2.exports = GSSAPI;
    function makeKerberosClient(authContext, callback) {
      const host = authContext.options.host;
      const port = authContext.options.port;
      const credentials = authContext.credentials;
      if (!host || !port || !credentials) {
        return callback(
          new MongoError(
            `Connection must specify: ${host ? "host" : ""}, ${port ? "port" : ""}, ${credentials ? "host" : "credentials"}.`
          )
        );
      }
      if (kerberos == null) {
        try {
          kerberos = retrieveKerberos();
        } catch (e) {
          return callback(e);
        }
      }
      const username = credentials.username;
      const password = credentials.password;
      const mechanismProperties = credentials.mechanismProperties;
      const serviceName = mechanismProperties["gssapiservicename"] || mechanismProperties["gssapiServiceName"] || "mongodb";
      performGssapiCanonicalizeHostName(host, mechanismProperties, (err, host2) => {
        if (err)
          return callback(err);
        const initOptions = {};
        if (password != null) {
          Object.assign(initOptions, { user: username, password });
        }
        kerberos.initializeClient(
          `${serviceName}${process.platform === "win32" ? "/" : "@"}${host2}`,
          initOptions,
          (err2, client) => {
            if (err2)
              return callback(new MongoError(err2));
            callback(null, client);
          }
        );
      });
    }
    function saslStart(payload) {
      return {
        saslStart: 1,
        mechanism: "GSSAPI",
        payload,
        autoAuthorize: 1
      };
    }
    function saslContinue(payload, conversationId) {
      return {
        saslContinue: 1,
        conversationId,
        payload
      };
    }
    function negotiate(client, retries, payload, callback) {
      client.step(payload, (err, response) => {
        if (err && retries === 0)
          return callback(err);
        if (err)
          return negotiate(client, retries - 1, payload, callback);
        callback(void 0, response || "");
      });
    }
    function finalize(client, user, payload, callback) {
      client.unwrap(payload, (err, response) => {
        if (err)
          return callback(err);
        client.wrap(response || "", { user }, (err2, wrapped) => {
          if (err2)
            return callback(err2);
          callback(void 0, wrapped);
        });
      });
    }
    function performGssapiCanonicalizeHostName(host, mechanismProperties, callback) {
      const canonicalizeHostName = typeof mechanismProperties.gssapiCanonicalizeHostName === "boolean" ? mechanismProperties.gssapiCanonicalizeHostName : false;
      if (!canonicalizeHostName)
        return callback(void 0, host);
      dns.resolveCname(host, (err, r) => {
        if (err)
          return callback(err);
        if (Array.isArray(r) && r.length > 0) {
          return callback(void 0, r[0]);
        }
        callback(void 0, host);
      });
    }
  }
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "node_modules/memory-pager/index.js"(exports2, module2) {
    module2.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager))
        return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page) {
      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
        page.deduplicate++;
        if (page.deduplicate === this.deduplicate.length) {
          page.deduplicate = 0;
          if (page.buffer.equals && page.buffer.equals(this.deduplicate))
            page.buffer = this.deduplicate;
          break;
        }
      }
      if (page.updated || !this.updates)
        return;
      page.updated = true;
      this.updates.push(page);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length)
        return null;
      var page = this.updates.pop();
      page.updated = false;
      return page;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate)
          return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate)
            return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page = arr && arr[first];
      if (!page && !noAllocate) {
        page = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length)
          this.length = i + 1;
      }
      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page.buffer = copy(page.buffer);
        page.deduplicate = 0;
      }
      return page;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length)
        this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page)
        page.buffer = b;
      else
        arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list = new Array(this.length);
      var empty = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list.length; i++) {
          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
        }
      }
      return Buffer.concat(list);
    };
    function grow(pager, index) {
      while (pager.maxPages < index) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len)
        return buf;
      if (buf.length > len)
        return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc)
        return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "node_modules/sparse-bitfield/index.js"(exports2, module2) {
    var pager = require_memory_pager();
    module2.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield))
        return new Bitfield(opts);
      if (!opts)
        opts = {};
      if (Buffer.isBuffer(opts))
        opts = { buffer: opts };
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize))
        throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, true);
      return page ? page.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next)
          next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, false);
      o += this.pageOffset;
      if (page.buffer[o] === b)
        return false;
      page.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates)
        this.pages.updated(page);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc)
        return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// node_modules/saslprep/lib/memory-code-points.js
var require_memory_code_points = __commonJS({
  "node_modules/saslprep/lib/memory-code-points.js"(exports2, module2) {
    "use strict";
    var fs2 = __require("fs");
    var path2 = __require("path");
    var bitfield = require_sparse_bitfield();
    var memory = fs2.readFileSync(path2.resolve(__dirname, "../code-points.mem"));
    var offset = 0;
    function read() {
      const size = memory.readUInt32BE(offset);
      offset += 4;
      const codepoints = memory.slice(offset, offset + size);
      offset += size;
      return bitfield({ buffer: codepoints });
    }
    var unassigned_code_points = read();
    var commonly_mapped_to_nothing = read();
    var non_ASCII_space_characters = read();
    var prohibited_characters = read();
    var bidirectional_r_al = read();
    var bidirectional_l = read();
    module2.exports = {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    };
  }
});

// node_modules/saslprep/index.js
var require_saslprep = __commonJS({
  "node_modules/saslprep/index.js"(exports2, module2) {
    "use strict";
    var {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    } = require_memory_code_points();
    module2.exports = saslprep;
    var mapping2space = non_ASCII_space_characters;
    var mapping2nothing = commonly_mapped_to_nothing;
    var getCodePoint = (character) => character.codePointAt(0);
    var first = (x) => x[0];
    var last = (x) => x[x.length - 1];
    function toCodePoints(input) {
      const codepoints = [];
      const size = input.length;
      for (let i = 0; i < size; i += 1) {
        const before = input.charCodeAt(i);
        if (before >= 55296 && before <= 56319 && size > i + 1) {
          const next = input.charCodeAt(i + 1);
          if (next >= 56320 && next <= 57343) {
            codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
            i += 1;
            continue;
          }
        }
        codepoints.push(before);
      }
      return codepoints;
    }
    function saslprep(input, opts = {}) {
      if (typeof input !== "string") {
        throw new TypeError("Expected string.");
      }
      if (input.length === 0) {
        return "";
      }
      const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
      const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
      const normalized_map = toCodePoints(normalized_input);
      const hasProhibited = normalized_map.some(
        (character) => prohibited_characters.get(character)
      );
      if (hasProhibited) {
        throw new Error(
          "Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3"
        );
      }
      if (opts.allowUnassigned !== true) {
        const hasUnassigned = normalized_map.some(
          (character) => unassigned_code_points.get(character)
        );
        if (hasUnassigned) {
          throw new Error(
            "Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5"
          );
        }
      }
      const hasBidiRAL = normalized_map.some(
        (character) => bidirectional_r_al.get(character)
      );
      const hasBidiL = normalized_map.some(
        (character) => bidirectional_l.get(character)
      );
      if (hasBidiRAL && hasBidiL) {
        throw new Error(
          "String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6"
        );
      }
      const isFirstBidiRAL = bidirectional_r_al.get(
        getCodePoint(first(normalized_input))
      );
      const isLastBidiRAL = bidirectional_r_al.get(
        getCodePoint(last(normalized_input))
      );
      if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error(
          "Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6"
        );
      }
      return normalized_input;
    }
  }
});

// node_modules/mongodb/lib/core/auth/scram.js
var require_scram = __commonJS({
  "node_modules/mongodb/lib/core/auth/scram.js"(exports2, module2) {
    "use strict";
    var crypto = __require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    var retrieveBSON = require_utils4().retrieveBSON;
    var MongoError = require_error().MongoError;
    var AuthProvider = require_auth_provider().AuthProvider;
    var emitWarningOnce = require_utils().emitWarning;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var saslprep;
    try {
      saslprep = require_saslprep();
    } catch (e) {
    }
    var ScramSHA = class extends AuthProvider {
      constructor(bson, cryptoMethod) {
        super(bson);
        this.cryptoMethod = cryptoMethod || "sha1";
      }
      prepare(handshakeDoc, authContext, callback) {
        const cryptoMethod = this.cryptoMethod;
        if (cryptoMethod === "sha256" && typeof saslprep !== "function") {
          emitWarningOnce("Warning: no saslprep library specified. Passwords will not be sanitized");
        }
        crypto.randomBytes(24, (err, nonce) => {
          if (err) {
            return callback(err);
          }
          Object.assign(authContext, { nonce });
          const credentials = authContext.credentials;
          const request = Object.assign({}, handshakeDoc, {
            speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
              db: credentials.source
            })
          });
          callback(void 0, request);
        });
      }
      auth(authContext, callback) {
        const response = authContext.response;
        if (response && response.speculativeAuthenticate) {
          continueScramConversation(
            this.cryptoMethod,
            response.speculativeAuthenticate,
            authContext,
            callback
          );
          return;
        }
        executeScram(this.cryptoMethod, authContext, callback);
      }
    };
    function cleanUsername(username) {
      return username.replace("=", "=3D").replace(",", "=2C");
    }
    function clientFirstMessageBare(username, nonce) {
      return Buffer2.concat([
        Buffer2.from("n=", "utf8"),
        Buffer2.from(username, "utf8"),
        Buffer2.from(",r=", "utf8"),
        Buffer2.from(nonce.toString("base64"), "utf8")
      ]);
    }
    function makeFirstMessage(cryptoMethod, credentials, nonce) {
      const username = cleanUsername(credentials.username);
      const mechanism = cryptoMethod === "sha1" ? "SCRAM-SHA-1" : "SCRAM-SHA-256";
      return {
        saslStart: 1,
        mechanism,
        payload: new Binary2(
          Buffer2.concat([Buffer2.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])
        ),
        autoAuthorize: 1,
        options: { skipEmptyExchange: true }
      };
    }
    function executeScram(cryptoMethod, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
      connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        continueScramConversation(cryptoMethod, result.result, authContext, callback);
      });
    }
    function continueScramConversation(cryptoMethod, response, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const username = cleanUsername(credentials.username);
      const password = credentials.password;
      let processedPassword;
      if (cryptoMethod === "sha256") {
        processedPassword = typeof saslprep === "function" ? saslprep(password) : password;
      } else {
        try {
          processedPassword = passwordDigest(username, password);
        } catch (e) {
          return callback(e);
        }
      }
      const payload = Buffer2.isBuffer(response.payload) ? new Binary2(response.payload) : response.payload;
      const dict = parsePayload(payload.value());
      const iterations = parseInt(dict.i, 10);
      if (iterations && iterations < 4096) {
        callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);
        return;
      }
      const salt = dict.s;
      const rnonce = dict.r;
      if (rnonce.startsWith("nonce")) {
        callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);
        return;
      }
      const withoutProof = `c=biws,r=${rnonce}`;
      const saltedPassword = HI(
        processedPassword,
        Buffer2.from(salt, "base64"),
        iterations,
        cryptoMethod
      );
      const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
      const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
      const storedKey = H(cryptoMethod, clientKey);
      const authMessage = [
        clientFirstMessageBare(username, nonce),
        payload.value().toString("base64"),
        withoutProof
      ].join(",");
      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
      const clientProof = `p=${xor(clientKey, clientSignature)}`;
      const clientFinal = [withoutProof, clientProof].join(",");
      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
      const saslContinueCmd = {
        saslContinue: 1,
        conversationId: response.conversationId,
        payload: new Binary2(Buffer2.from(clientFinal))
      };
      connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        const r = result.result;
        const parsedResponse = parsePayload(r.payload.value());
        if (!compareDigest(Buffer2.from(parsedResponse.v, "base64"), serverSignature)) {
          callback(new MongoError("Server returned an invalid signature"));
          return;
        }
        if (!r || r.done !== false) {
          return callback(err, r);
        }
        const retrySaslContinueCmd = {
          saslContinue: 1,
          conversationId: r.conversationId,
          payload: Buffer2.alloc(0)
        };
        connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);
      });
    }
    function parsePayload(payload) {
      const dict = {};
      const parts = payload.split(",");
      for (let i = 0; i < parts.length; i++) {
        const valueParts = parts[i].split("=");
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    }
    function passwordDigest(username, password) {
      if (typeof username !== "string") {
        throw new MongoError("username must be a string");
      }
      if (typeof password !== "string") {
        throw new MongoError("password must be a string");
      }
      if (password.length === 0) {
        throw new MongoError("password cannot be empty");
      }
      const md5 = crypto.createHash("md5");
      md5.update(`${username}:mongo:${password}`, "utf8");
      return md5.digest("hex");
    }
    function xor(a, b) {
      if (!Buffer2.isBuffer(a)) {
        a = Buffer2.from(a);
      }
      if (!Buffer2.isBuffer(b)) {
        b = Buffer2.from(b);
      }
      const length = Math.max(a.length, b.length);
      const res = [];
      for (let i = 0; i < length; i += 1) {
        res.push(a[i] ^ b[i]);
      }
      return Buffer2.from(res).toString("base64");
    }
    function H(method, text) {
      return crypto.createHash(method).update(text).digest();
    }
    function HMAC(method, key, text) {
      return crypto.createHmac(method, key).update(text).digest();
    }
    var _hiCache = {};
    var _hiCacheCount = 0;
    function _hiCachePurge() {
      _hiCache = {};
      _hiCacheCount = 0;
    }
    var hiLengthMap = {
      sha256: 32,
      sha1: 20
    };
    function HI(data, salt, iterations, cryptoMethod) {
      const key = [data, salt.toString("base64"), iterations].join("_");
      if (_hiCache[key] !== void 0) {
        return _hiCache[key];
      }
      const saltedData = crypto.pbkdf2Sync(
        data,
        salt,
        iterations,
        hiLengthMap[cryptoMethod],
        cryptoMethod
      );
      if (_hiCacheCount >= 200) {
        _hiCachePurge();
      }
      _hiCache[key] = saltedData;
      _hiCacheCount += 1;
      return saltedData;
    }
    function compareDigest(lhs, rhs) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      if (typeof crypto.timingSafeEqual === "function") {
        return crypto.timingSafeEqual(lhs, rhs);
      }
      let result = 0;
      for (let i = 0; i < lhs.length; i++) {
        result |= lhs[i] ^ rhs[i];
      }
      return result === 0;
    }
    function resolveError(err, result) {
      if (err)
        return err;
      const r = result.result;
      if (r.$err || r.errmsg)
        return new MongoError(r);
    }
    var ScramSHA1 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha1");
      }
    };
    var ScramSHA256 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha256");
      }
    };
    module2.exports = { ScramSHA1, ScramSHA256 };
  }
});

// node_modules/mongodb/lib/core/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongo_credentials.js"(exports2, module2) {
    "use strict";
    function getDefaultAuthMechanism(ismaster) {
      if (ismaster) {
        if (Array.isArray(ismaster.saslSupportedMechs)) {
          return ismaster.saslSupportedMechs.indexOf("SCRAM-SHA-256") >= 0 ? "scram-sha-256" : "scram-sha-1";
        }
        if (ismaster.maxWireVersion >= 3) {
          return "scram-sha-1";
        }
      }
      return "mongocr";
    }
    var MongoCredentials = class _MongoCredentials {
      /**
       * Creates a new MongoCredentials object
       * @param {object} [options]
       * @param {string} [options.username] The username used for authentication
       * @param {string} [options.password] The password used for authentication
       * @param {string} [options.source] The database that the user should authenticate against
       * @param {string} [options.mechanism] The method used to authenticate
       * @param {object} [options.mechanismProperties] Special properties used by some types of auth mechanisms
       */
      constructor(options) {
        options = options || {};
        this.username = options.username;
        this.password = options.password;
        this.source = options.source || options.db;
        this.mechanism = options.mechanism || "default";
        this.mechanismProperties = options.mechanismProperties || {};
        if (/MONGODB-AWS/i.test(this.mechanism)) {
          if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
            this.username = process.env.AWS_ACCESS_KEY_ID;
          }
          if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
            this.password = process.env.AWS_SECRET_ACCESS_KEY;
          }
          if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
            this.mechanismProperties.AWS_SESSION_TOKEN = process.env.AWS_SESSION_TOKEN;
          }
        }
        Object.freeze(this.mechanismProperties);
        Object.freeze(this);
      }
      /**
       * Determines if two MongoCredentials objects are equivalent
       * @param {MongoCredentials} other another MongoCredentials object
       * @returns {boolean} true if the two objects are equal.
       */
      equals(other) {
        return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
      }
      /**
       * If the authentication mechanism is set to "default", resolves the authMechanism
       * based on the server version and server supported sasl mechanisms.
       *
       * @param {Object} [ismaster] An ismaster response from the server
       * @returns {MongoCredentials}
       */
      resolveAuthMechanism(ismaster) {
        if (/DEFAULT/i.test(this.mechanism)) {
          return new _MongoCredentials({
            username: this.username,
            password: this.password,
            source: this.source,
            mechanism: getDefaultAuthMechanism(ismaster),
            mechanismProperties: this.mechanismProperties
          });
        }
        return this;
      }
    };
    module2.exports = { MongoCredentials };
  }
});

// node_modules/mongodb/lib/core/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongodb_aws.js"(exports2, module2) {
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCredentials = require_mongo_credentials().MongoCredentials;
    var MongoError = require_error().MongoError;
    var crypto = __require("crypto");
    var http = __require("http");
    var maxWireVersion = require_utils3().maxWireVersion;
    var url = __require("url");
    var aws4;
    try {
      aws4 = __require("aws4");
    } catch (e) {
    }
    var ASCII_N = 110;
    var AWS_RELATIVE_URI = "http://169.254.170.2";
    var AWS_EC2_URI = "http://169.254.169.254";
    var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
    var MongoDBAWS = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (maxWireVersion(connection) < 9) {
          callback(new MongoError("MONGODB-AWS authentication requires MongoDB version 4.4 or later"));
          return;
        }
        if (aws4 == null) {
          callback(
            new MongoError(
              "MONGODB-AWS authentication requires the `aws4` module, please install it as a dependency of your project"
            )
          );
          return;
        }
        if (credentials.username == null) {
          makeTempCredentials(credentials, (err, tempCredentials) => {
            if (err)
              return callback(err);
            authContext.credentials = tempCredentials;
            this.auth(authContext, callback);
          });
          return;
        }
        const db = credentials.source;
        const bson = this.bson;
        const accessKeyId = credentials.username;
        const secretAccessKey = credentials.password;
        const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;
        const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? { accessKeyId, secretAccessKey, sessionToken } : accessKeyId && secretAccessKey ? { accessKeyId, secretAccessKey } : void 0;
        crypto.randomBytes(32, (err, nonce) => {
          if (err) {
            callback(err);
            return;
          }
          const saslStart = {
            saslStart: 1,
            mechanism: "MONGODB-AWS",
            payload: bson.serialize({ r: nonce, p: ASCII_N })
          };
          connection.command(`${db}.$cmd`, saslStart, (err2, result) => {
            if (err2)
              return callback(err2);
            const res = result.result;
            const serverResponse = bson.deserialize(res.payload.buffer);
            const host = serverResponse.h;
            const serverNonce = serverResponse.s.buffer;
            if (serverNonce.length !== 64) {
              callback(
                new MongoError(`Invalid server nonce length ${serverNonce.length}, expected 64`)
              );
              return;
            }
            if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
              callback(new MongoError("Server nonce does not begin with client nonce"));
              return;
            }
            if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
              callback(new MongoError(`Server returned an invalid host: "${host}"`));
              return;
            }
            const body = "Action=GetCallerIdentity&Version=2011-06-15";
            const options = aws4.sign(
              {
                method: "POST",
                host,
                region: deriveRegion(serverResponse.h),
                service: "sts",
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded",
                  "Content-Length": body.length,
                  "X-MongoDB-Server-Nonce": serverNonce.toString("base64"),
                  "X-MongoDB-GS2-CB-Flag": "n"
                },
                path: "/",
                body
              },
              awsCredentials
            );
            const authorization = options.headers.Authorization;
            const date = options.headers["X-Amz-Date"];
            const payload = { a: authorization, d: date };
            if (sessionToken) {
              payload.t = sessionToken;
            }
            const saslContinue = {
              saslContinue: 1,
              conversationId: 1,
              payload: bson.serialize(payload)
            };
            connection.command(`${db}.$cmd`, saslContinue, (err3) => {
              if (err3)
                return callback(err3);
              callback();
            });
          });
        });
      }
    };
    function makeTempCredentials(credentials, callback) {
      function done(creds) {
        if (creds.AccessKeyId == null || creds.SecretAccessKey == null || creds.Token == null) {
          callback(new MongoError("Could not obtain temporary MONGODB-AWS credentials"));
          return;
        }
        callback(
          void 0,
          new MongoCredentials({
            username: creds.AccessKeyId,
            password: creds.SecretAccessKey,
            source: credentials.source,
            mechanism: "MONGODB-AWS",
            mechanismProperties: {
              AWS_SESSION_TOKEN: creds.Token
            }
          })
        );
      }
      if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        request(
          `${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`,
          void 0,
          (err, res) => {
            if (err)
              return callback(err);
            done(res);
          }
        );
        return;
      }
      request(
        `${AWS_EC2_URI}/latest/api/token`,
        { method: "PUT", json: false, headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 } },
        (err, token) => {
          if (err)
            return callback(err);
          request(
            `${AWS_EC2_URI}/${AWS_EC2_PATH}`,
            { json: false, headers: { "X-aws-ec2-metadata-token": token } },
            (err2, roleName) => {
              if (err2)
                return callback(err2);
              request(
                `${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`,
                { headers: { "X-aws-ec2-metadata-token": token } },
                (err3, creds) => {
                  if (err3)
                    return callback(err3);
                  done(creds);
                }
              );
            }
          );
        }
      );
    }
    function deriveRegion(host) {
      const parts = host.split(".");
      if (parts.length === 1 || parts[1] === "amazonaws") {
        return "us-east-1";
      }
      return parts[1];
    }
    function request(uri, options, callback) {
      options = Object.assign(
        {
          method: "GET",
          timeout: 1e4,
          json: true
        },
        url.parse(uri),
        options
      );
      const req = http.request(options, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d) => data += d);
        res.on("end", () => {
          if (options.json === false) {
            callback(void 0, data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            callback(void 0, parsed);
          } catch (err) {
            callback(new MongoError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.on("error", (err) => callback(err));
      req.end();
    }
    module2.exports = MongoDBAWS;
  }
});

// node_modules/mongodb/lib/core/auth/defaultAuthProviders.js
var require_defaultAuthProviders = __commonJS({
  "node_modules/mongodb/lib/core/auth/defaultAuthProviders.js"(exports2, module2) {
    "use strict";
    var MongoCR = require_mongocr();
    var X509 = require_x509();
    var Plain = require_plain();
    var GSSAPI = require_gssapi();
    var ScramSHA1 = require_scram().ScramSHA1;
    var ScramSHA256 = require_scram().ScramSHA256;
    var MongoDBAWS = require_mongodb_aws();
    function defaultAuthProviders(bson) {
      return {
        "mongodb-aws": new MongoDBAWS(bson),
        mongocr: new MongoCR(bson),
        x509: new X509(bson),
        plain: new Plain(bson),
        gssapi: new GSSAPI(bson),
        "scram-sha-1": new ScramSHA1(bson),
        "scram-sha-256": new ScramSHA256(bson)
      };
    }
    module2.exports = { defaultAuthProviders };
  }
});

// node_modules/mongodb/lib/core/connection/connect.js
var require_connect = __commonJS({
  "node_modules/mongodb/lib/core/connection/connect.js"(exports2, module2) {
    "use strict";
    var net = __require("net");
    var tls = __require("tls");
    var Connection2 = require_connection();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var defaultAuthProviders = require_defaultAuthProviders().defaultAuthProviders;
    var AuthContext = require_auth_provider().AuthContext;
    var WIRE_CONSTANTS = require_constants();
    var makeClientMetadata = require_utils3().makeClientMetadata;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var AUTH_PROVIDERS;
    function connect(options, cancellationToken, callback) {
      if (typeof cancellationToken === "function") {
        callback = cancellationToken;
        cancellationToken = void 0;
      }
      const ConnectionType = options && options.connectionType ? options.connectionType : Connection2;
      if (AUTH_PROVIDERS == null) {
        AUTH_PROVIDERS = defaultAuthProviders(options.bson);
      }
      const family = options.family !== void 0 ? options.family : 0;
      makeConnection(family, options, cancellationToken, (err, socket) => {
        if (err) {
          callback(err, socket);
          return;
        }
        performInitialHandshake(new ConnectionType(socket, options), options, callback);
      });
    }
    function isModernConnectionType(conn) {
      return !(conn instanceof Connection2);
    }
    function checkSupportedServer(ismaster, options) {
      const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === "number" && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;
      const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === "number" && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;
      if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
          return null;
        }
        const message2 = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        return new MongoError(message2);
      }
      const message = `Server at ${options.host}:${options.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;
      return new MongoError(message);
    }
    function performInitialHandshake(conn, options, _callback) {
      const callback = function(err, ret) {
        if (err && conn) {
          conn.destroy();
        }
        _callback(err, ret);
      };
      const credentials = options.credentials;
      if (credentials) {
        if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {
          callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));
          return;
        }
      }
      const authContext = new AuthContext(conn, credentials, options);
      prepareHandshakeDocument(authContext, (err, handshakeDoc) => {
        if (err) {
          return callback(err);
        }
        const handshakeOptions = Object.assign({}, options);
        if (options.connectTimeoutMS || options.connectionTimeout) {
          handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;
        }
        handshakeDoc.helloOk = !!options.useUnifiedTopology;
        const start = (/* @__PURE__ */ new Date()).getTime();
        conn.command("admin.$cmd", handshakeDoc, handshakeOptions, (err2, result) => {
          if (err2) {
            callback(err2);
            return;
          }
          const response = result.result;
          if (response.ok === 0) {
            callback(new MongoError(response));
            return;
          }
          if ("isWritablePrimary" in response) {
            response.ismaster = response.isWritablePrimary;
          }
          if (options.useUnifiedTopology && response.helloOk) {
            conn.helloOk = true;
          }
          const supportedServerErr = checkSupportedServer(response, options);
          if (supportedServerErr) {
            callback(supportedServerErr);
            return;
          }
          if (!isModernConnectionType(conn)) {
            if (response.compression) {
              const agreedCompressors = handshakeDoc.compression.filter(
                (compressor) => response.compression.indexOf(compressor) !== -1
              );
              if (agreedCompressors.length) {
                conn.agreedCompressor = agreedCompressors[0];
              }
              if (options.compression && options.compression.zlibCompressionLevel) {
                conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;
              }
            }
          }
          conn.ismaster = response;
          conn.lastIsMasterMS = (/* @__PURE__ */ new Date()).getTime() - start;
          if (!response.arbiterOnly && credentials) {
            Object.assign(authContext, { response });
            const resolvedCredentials = credentials.resolveAuthMechanism(response);
            const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];
            authProvider.auth(authContext, (err3) => {
              if (err3)
                return callback(err3);
              callback(void 0, conn);
            });
            return;
          }
          callback(void 0, conn);
        });
      });
    }
    function prepareHandshakeDocument(authContext, callback) {
      const options = authContext.options;
      const serverApi = authContext.connection.serverApi;
      const compressors = options.compression && options.compression.compressors ? options.compression.compressors : [];
      const handshakeDoc = {
        [serverApi ? "hello" : "ismaster"]: true,
        client: options.metadata || makeClientMetadata(options),
        compression: compressors
      };
      const credentials = authContext.credentials;
      if (credentials) {
        if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {
          Object.assign(handshakeDoc, {
            saslSupportedMechs: `${credentials.source}.${credentials.username}`
          });
          AUTH_PROVIDERS["scram-sha-256"].prepare(handshakeDoc, authContext, callback);
          return;
        }
        const authProvider = AUTH_PROVIDERS[credentials.mechanism];
        if (authProvider == null) {
          return callback(new MongoError(`No AuthProvider for ${credentials.mechanism} defined.`));
        }
        authProvider.prepare(handshakeDoc, authContext, callback);
        return;
      }
      callback(void 0, handshakeDoc);
    }
    var LEGAL_SSL_SOCKET_OPTIONS = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "NPNProtocols",
      "ALPNProtocols",
      "servername",
      "ecdhCurve",
      "secureProtocol",
      "secureContext",
      "session",
      "minDHSize",
      "crl",
      "rejectUnauthorized"
    ];
    function parseConnectOptions(family, options) {
      const host = typeof options.host === "string" ? options.host : "localhost";
      if (host.indexOf("/") !== -1) {
        return { path: host };
      }
      const result = {
        family,
        host,
        port: typeof options.port === "number" ? options.port : 27017,
        rejectUnauthorized: false
      };
      return result;
    }
    function parseSslOptions(family, options) {
      const result = parseConnectOptions(family, options);
      for (const name in options) {
        if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {
          result[name] = options[name];
        }
      }
      if (options.checkServerIdentity === false) {
        result.checkServerIdentity = function() {
          return void 0;
        };
      } else if (typeof options.checkServerIdentity === "function") {
        result.checkServerIdentity = options.checkServerIdentity;
      }
      if (result.servername == null && !net.isIP(result.host)) {
        result.servername = result.host;
      }
      return result;
    }
    var SOCKET_ERROR_EVENTS = /* @__PURE__ */ new Set(["error", "close", "timeout", "parseError"]);
    function makeConnection(family, options, cancellationToken, _callback) {
      const useSsl = typeof options.ssl === "boolean" ? options.ssl : false;
      const keepAlive = typeof options.keepAlive === "boolean" ? options.keepAlive : true;
      let keepAliveInitialDelay = typeof options.keepAliveInitialDelay === "number" ? options.keepAliveInitialDelay : 12e4;
      const noDelay = typeof options.noDelay === "boolean" ? options.noDelay : true;
      const connectionTimeout = typeof options.connectionTimeout === "number" ? options.connectionTimeout : typeof options.connectTimeoutMS === "number" ? options.connectTimeoutMS : 3e4;
      const socketTimeoutMS = typeof options.socketTimeoutMS === "number" ? options.socketTimeoutMS : typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
      const rejectUnauthorized = typeof options.rejectUnauthorized === "boolean" ? options.rejectUnauthorized : true;
      if (keepAliveInitialDelay > socketTimeoutMS) {
        keepAliveInitialDelay = Math.round(socketTimeoutMS / 2);
      }
      let socket;
      const callback = function(err, ret) {
        if (err && socket) {
          socket.destroy();
        }
        _callback(err, ret);
      };
      try {
        if (useSsl) {
          socket = tls.connect(parseSslOptions(family, options));
          if (typeof socket.disableRenegotiation === "function") {
            socket.disableRenegotiation();
          }
        } else {
          socket = net.createConnection(parseConnectOptions(family, options));
        }
      } catch (err) {
        return callback(err);
      }
      socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
      socket.setTimeout(connectionTimeout);
      socket.setNoDelay(noDelay);
      const connectEvent = useSsl ? "secureConnect" : "connect";
      let cancellationHandler;
      function errorHandler(eventName) {
        return (err) => {
          SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
          if (cancellationHandler) {
            cancellationToken.removeListener("cancel", cancellationHandler);
          }
          socket.removeListener(connectEvent, connectHandler);
          callback(connectionFailureError(eventName, err));
        };
      }
      function connectHandler() {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler) {
          cancellationToken.removeListener("cancel", cancellationHandler);
        }
        if (socket.authorizationError && rejectUnauthorized) {
          return callback(socket.authorizationError);
        }
        socket.setTimeout(socketTimeoutMS);
        callback(null, socket);
      }
      SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
      if (cancellationToken) {
        cancellationHandler = errorHandler("cancel");
        cancellationToken.once("cancel", cancellationHandler);
      }
      socket.once(connectEvent, connectHandler);
    }
    function connectionFailureError(type, err) {
      switch (type) {
        case "error":
          return new MongoNetworkError(err);
        case "timeout":
          return new MongoNetworkTimeoutError(`connection timed out`);
        case "close":
          return new MongoNetworkError(`connection closed`);
        case "cancel":
          return new MongoNetworkError(`connection establishment was cancelled`);
        default:
          return new MongoNetworkError(`unknown network error`);
      }
    }
    module2.exports = connect;
  }
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS({
  "node_modules/mongodb/lib/read_concern.js"(exports2, module2) {
    "use strict";
    var ReadConcern = class _ReadConcern {
      /**
       * Constructs a ReadConcern from the read concern properties.
       * @param {string} [level] The read concern level ({'local'|'available'|'majority'|'linearizable'|'snapshot'})
       */
      constructor(level) {
        if (level != null) {
          this.level = level;
        }
      }
      /**
       * Construct a ReadConcern given an options object.
       *
       * @param {object} options The options object from which to extract the write concern.
       * @return {ReadConcern}
       */
      static fromOptions(options) {
        if (options == null) {
          return;
        }
        if (options.readConcern) {
          if (options.readConcern instanceof _ReadConcern) {
            return options.readConcern;
          }
          return new _ReadConcern(options.readConcern.level);
        }
        if (options.level) {
          return new _ReadConcern(options.level);
        }
      }
      static get MAJORITY() {
        return "majority";
      }
      static get AVAILABLE() {
        return "available";
      }
      static get LINEARIZABLE() {
        return "linearizable";
      }
      static get SNAPSHOT() {
        return "snapshot";
      }
    };
    module2.exports = ReadConcern;
  }
});

// node_modules/mongodb/lib/core/transactions.js
var require_transactions = __commonJS({
  "node_modules/mongodb/lib/core/transactions.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var ReadPreference = require_read_preference();
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var TxnState;
    var stateMachine;
    (() => {
      const NO_TRANSACTION = "NO_TRANSACTION";
      const STARTING_TRANSACTION = "STARTING_TRANSACTION";
      const TRANSACTION_IN_PROGRESS = "TRANSACTION_IN_PROGRESS";
      const TRANSACTION_COMMITTED = "TRANSACTION_COMMITTED";
      const TRANSACTION_COMMITTED_EMPTY = "TRANSACTION_COMMITTED_EMPTY";
      const TRANSACTION_ABORTED = "TRANSACTION_ABORTED";
      TxnState = {
        NO_TRANSACTION,
        STARTING_TRANSACTION,
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        TRANSACTION_ABORTED
      };
      stateMachine = {
        [NO_TRANSACTION]: [NO_TRANSACTION, STARTING_TRANSACTION],
        [STARTING_TRANSACTION]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_IN_PROGRESS]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_COMMITTED]: [
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          STARTING_TRANSACTION,
          NO_TRANSACTION
        ],
        [TRANSACTION_ABORTED]: [STARTING_TRANSACTION, NO_TRANSACTION],
        [TRANSACTION_COMMITTED_EMPTY]: [TRANSACTION_COMMITTED_EMPTY, NO_TRANSACTION]
      };
    })();
    var Transaction = class {
      /**
       * Create a transaction
       *
       * @ignore
       * @param {TransactionOptions} [options] Optional settings
       */
      constructor(options) {
        options = options || {};
        this.state = TxnState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = WriteConcern.fromOptions(options);
        if (writeConcern) {
          if (writeConcern.w <= 0) {
            throw new MongoError("Transactions do not support unacknowledged write concern");
          }
          this.options.writeConcern = writeConcern;
        }
        if (options.readConcern) {
          this.options.readConcern = ReadConcern.fromOptions(options);
        }
        if (options.readPreference) {
          this.options.readPreference = ReadPreference.fromOptions(options);
        }
        if (options.maxCommitTimeMS) {
          this.options.maxTimeMS = options.maxCommitTimeMS;
        }
        this._pinnedServer = void 0;
        this._recoveryToken = void 0;
      }
      get server() {
        return this._pinnedServer;
      }
      get recoveryToken() {
        return this._recoveryToken;
      }
      get isPinned() {
        return !!this.server;
      }
      /**
       * @ignore
       * @return Whether this session is presently in a transaction
       */
      get isActive() {
        return [TxnState.STARTING_TRANSACTION, TxnState.TRANSACTION_IN_PROGRESS].indexOf(this.state) !== -1;
      }
      /**
       * Transition the transaction in the state machine
       * @ignore
       * @param {TxnState} state The new state to transition to
       */
      transition(nextState) {
        const nextStates = stateMachine[this.state];
        if (nextStates && nextStates.indexOf(nextState) !== -1) {
          this.state = nextState;
          if (this.state === TxnState.NO_TRANSACTION || this.state === TxnState.STARTING_TRANSACTION || this.state === TxnState.TRANSACTION_ABORTED) {
            this.unpinServer();
          }
          return;
        }
        throw new MongoError(
          `Attempted illegal state transition from [${this.state}] to [${nextState}]`
        );
      }
      pinServer(server) {
        if (this.isActive) {
          this._pinnedServer = server;
        }
      }
      unpinServer() {
        this._pinnedServer = void 0;
      }
    };
    function isTransactionCommand(command) {
      return !!(command.commitTransaction || command.abortTransaction);
    }
    module2.exports = { TxnState, Transaction, isTransactionCommand };
  }
});

// node_modules/mongodb/lib/core/topologies/shared.js
var require_shared2 = __commonJS({
  "node_modules/mongodb/lib/core/topologies/shared.js"(exports2, module2) {
    "use strict";
    var MONGODB_ERROR_CODES = require_error_codes().MONGODB_ERROR_CODES;
    var ReadPreference = require_read_preference();
    var TopologyType = require_common().TopologyType;
    var MongoError = require_error().MongoError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var maxWireVersion = require_utils3().maxWireVersion;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    function createCompressionInfo(options) {
      if (!options.compression || !options.compression.compressors) {
        return [];
      }
      options.compression.compressors.forEach(function(compressor) {
        if (compressor !== "snappy" && compressor !== "zlib") {
          throw new Error("compressors must be at least one of snappy or zlib");
        }
      });
      return options.compression.compressors;
    }
    function clone(object2) {
      return JSON.parse(JSON.stringify(object2));
    }
    var getPreviousDescription = function(self2) {
      if (!self2.s.serverDescription) {
        self2.s.serverDescription = {
          address: self2.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: "Unknown"
        };
      }
      return self2.s.serverDescription;
    };
    var emitServerDescriptionChanged = function(self2, description) {
      if (self2.listeners("serverDescriptionChanged").length > 0) {
        self2.emit("serverDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var getPreviousTopologyDescription = function(self2) {
      if (!self2.s.topologyDescription) {
        self2.s.topologyDescription = {
          topologyType: "Unknown",
          servers: [
            {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            }
          ]
        };
      }
      return self2.s.topologyDescription;
    };
    var emitTopologyDescriptionChanged = function(self2, description) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        self2.emit("topologyDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousTopologyDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var changedIsMaster = function(self2, currentIsmaster, ismaster) {
      var currentType = getTopologyType(self2, currentIsmaster);
      var newType = getTopologyType(self2, ismaster);
      if (newType !== currentType)
        return true;
      return false;
    };
    var getTopologyType = function(self2, ismaster) {
      if (!ismaster) {
        ismaster = self2.ismaster;
      }
      if (!ismaster)
        return "Unknown";
      if (ismaster.ismaster && ismaster.msg === "isdbgrid")
        return "Mongos";
      if (ismaster.ismaster && !ismaster.hosts)
        return "Standalone";
      if (ismaster.ismaster)
        return "RSPrimary";
      if (ismaster.secondary)
        return "RSSecondary";
      if (ismaster.arbiterOnly)
        return "RSArbiter";
      return "Unknown";
    };
    var inquireServerState = function(self2) {
      return function(callback) {
        if (self2.s.state === "destroyed")
          return;
        var start = (/* @__PURE__ */ new Date()).getTime();
        emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: self2.name });
        self2.command("admin.$cmd", { ismaster: true }, { monitoring: true }, function(err, r) {
          if (!err) {
            self2.emit("ismaster", r, self2);
            var latencyMS = (/* @__PURE__ */ new Date()).getTime() - start;
            emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: self2.name
            });
            if (changedIsMaster(self2, self2.s.ismaster, r.result)) {
              emitServerDescriptionChanged(self2, {
                address: self2.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: !self2.s.inTopology ? "Standalone" : getTopologyType(self2)
              });
            }
            self2.s.ismaster = r.result;
            self2.s.isMasterLatencyMS = latencyMS;
          } else {
            emitSDAMEvent(self2, "serverHeartbeatFailed", {
              durationMS: latencyMS,
              failure: err,
              connectionId: self2.name
            });
          }
          if (typeof callback === "function") {
            return callback(err, r);
          }
          self2.s.inquireServerStateTimeout = setTimeout(inquireServerState(self2), self2.s.haInterval);
        });
      };
    };
    var cloneOptions = function(options) {
      var opts = {};
      for (var name in options) {
        opts[name] = options[name];
      }
      return opts;
    };
    function Interval(fn, time) {
      var timer = false;
      this.start = function() {
        if (!this.isRunning()) {
          timer = setInterval(fn, time);
        }
        return this;
      };
      this.stop = function() {
        clearInterval(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function Timeout(fn, time) {
      var timer = false;
      var func = () => {
        if (timer) {
          clearTimeout(timer);
          timer = false;
          fn();
        }
      };
      this.start = function() {
        if (!this.isRunning()) {
          timer = setTimeout(func, time);
        }
        return this;
      };
      this.stop = function() {
        clearTimeout(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function diff(previous, current) {
      var diff2 = {
        servers: []
      };
      if (!previous) {
        previous = { servers: [] };
      }
      for (var i = 0; i < previous.servers.length; i++) {
        var found = false;
        for (var j = 0; j < current.servers.length; j++) {
          if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: previous.servers[i].address,
            from: previous.servers[i].type,
            to: "Unknown"
          });
        }
      }
      for (j = 0; j < current.servers.length; j++) {
        found = false;
        for (i = 0; i < previous.servers.length; i++) {
          if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: current.servers[j].address,
            from: "Unknown",
            to: current.servers[j].type
          });
        }
      }
      for (i = 0; i < previous.servers.length; i++) {
        var prevServer = previous.servers[i];
        for (j = 0; j < current.servers.length; j++) {
          var currServer = current.servers[j];
          if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {
            if (prevServer.type !== currServer.type) {
              diff2.servers.push({
                address: prevServer.address,
                from: prevServer.type,
                to: currServer.type
              });
            }
          }
        }
      }
      return diff2;
    }
    function resolveClusterTime(topology, $clusterTime) {
      if (topology.clusterTime == null) {
        topology.clusterTime = $clusterTime;
      } else {
        if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {
          topology.clusterTime = $clusterTime;
        }
      }
    }
    var SessionMixins = {
      endSessions: function(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command(
          "admin.$cmd",
          { endSessions: sessions },
          { readPreference: ReadPreference.primaryPreferred },
          () => {
            if (typeof callback === "function")
              callback();
          }
        );
      }
    };
    function topologyType(topology) {
      if (topology.description) {
        return topology.description.type;
      }
      if (topology.type === "mongos") {
        return TopologyType.Sharded;
      } else if (topology.type === "replset") {
        return TopologyType.ReplicaSetWithPrimary;
      }
      return TopologyType.Single;
    }
    var RETRYABLE_WIRE_VERSION = 6;
    var isRetryableWritesSupported = function(topology) {
      const maxWireVersion2 = topology.lastIsMaster().maxWireVersion;
      if (maxWireVersion2 < RETRYABLE_WIRE_VERSION) {
        return false;
      }
      if (!topology.logicalSessionTimeoutMinutes) {
        return false;
      }
      if (topologyType(topology) === TopologyType.Single) {
        return false;
      }
      return true;
    };
    var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
    function getMMAPError(err) {
      if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes("Transaction numbers")) {
        return err;
      }
      const newErr = new MongoError({
        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        originalError: err
      });
      return newErr;
    }
    function legacyIsRetryableWriteError(err, topology) {
      if (!(err instanceof MongoError)) {
        return false;
      }
      if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {
        err.addErrorLabel("RetryableWriteError");
      }
      return err.hasErrorLabel("RetryableWriteError");
    }
    module2.exports = {
      SessionMixins,
      resolveClusterTime,
      inquireServerState,
      getTopologyType,
      emitServerDescriptionChanged,
      emitTopologyDescriptionChanged,
      cloneOptions,
      createCompressionInfo,
      clone,
      diff,
      Interval,
      Timeout,
      isRetryableWritesSupported,
      getMMAPError,
      topologyType,
      legacyIsRetryableWriteError
    };
  }
});

// node_modules/mongodb/lib/core/sessions.js
var require_sessions = __commonJS({
  "node_modules/mongodb/lib/core/sessions.js"(exports2, module2) {
    "use strict";
    var retrieveBSON = require_utils4().retrieveBSON;
    var EventEmitter = __require("events");
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var uuidV4 = require_utils3().uuidV4;
    var MongoError = require_error().MongoError;
    var isRetryableError = require_error().isRetryableError;
    var isRetryableEndTransactionError = require_error().isRetryableEndTransactionError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Transaction = require_transactions().Transaction;
    var TxnState = require_transactions().TxnState;
    var isPromiseLike = require_utils3().isPromiseLike;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils().maybePromise;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils3().maxWireVersion;
    var now = require_utils().now;
    var calculateDurationInMs = require_utils().calculateDurationInMs;
    var minWireVersionForShardedTransactions = 8;
    function assertAlive(session, callback) {
      if (session.serverSession == null) {
        const error = new MongoError("Cannot use a session that has ended");
        if (typeof callback === "function") {
          callback(error, null);
          return false;
        }
        throw error;
      }
      return true;
    }
    var kServerSession = Symbol("serverSession");
    var ClientSession = class _ClientSession extends EventEmitter {
      /**
       * Create a client session.
       * WARNING: not meant to be instantiated directly
       *
       * @param {Topology} topology The current client's topology (Internal Class)
       * @param {ServerSessionPool} sessionPool The server session pool (Internal Class)
       * @param {SessionOptions} [options] Optional settings
       * @param {Object} [clientOptions] Optional settings provided when creating a client in the porcelain driver
       */
      constructor(topology, sessionPool, options, clientOptions) {
        super();
        if (topology == null) {
          throw new Error("ClientSession requires a topology");
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
          throw new Error("ClientSession requires a ServerSessionPool");
        }
        options = options || {};
        clientOptions = clientOptions || {};
        this.topology = topology;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this[kServerSession] = void 0;
        this.supports = {
          causalConsistency: typeof options.causalConsistency !== "undefined" ? options.causalConsistency : true
        };
        this.clusterTime = options.initialClusterTime;
        this.operationTime = null;
        this.explicit = !!options.explicit;
        this.owner = options.owner;
        this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
        this.transaction = new Transaction();
      }
      /**
       * The server id associated with this session
       * @type {SessionId}
       */
      get id() {
        return this.serverSession.id;
      }
      get serverSession() {
        if (this[kServerSession] == null) {
          this[kServerSession] = this.sessionPool.acquire();
        }
        return this[kServerSession];
      }
      /**
       * Ends this session on the server
       *
       * @param {Object} [options] Optional settings. Currently reserved for future use
       * @param {Function} [callback] Optional callback for completion of this operation
       */
      endSession(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options || {};
        const session = this;
        return maybePromise(this, callback, (done) => {
          if (session.hasEnded) {
            return done();
          }
          function completeEndSession() {
            session.sessionPool.release(session.serverSession);
            session[kServerSession] = void 0;
            session.hasEnded = true;
            session.emit("ended", session);
            done();
          }
          if (session.serverSession && session.inTransaction()) {
            session.abortTransaction((err) => {
              if (err)
                return done(err);
              completeEndSession();
            });
            return;
          }
          completeEndSession();
        });
      }
      /**
       * Advances the operationTime for a ClientSession.
       *
       * @param {Timestamp} operationTime the `BSON.Timestamp` of the operation type it is desired to advance to
       */
      advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
          this.operationTime = operationTime;
          return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
          this.operationTime = operationTime;
        }
      }
      /**
       * Used to determine if this session equals another
       * @param {ClientSession} session
       * @return {boolean} true if the sessions are equal
       */
      equals(session) {
        if (!(session instanceof _ClientSession)) {
          return false;
        }
        return this.id.id.buffer.equals(session.id.id.buffer);
      }
      /**
       * Increment the transaction number on the internal ServerSession
       */
      incrementTransactionNumber() {
        this.serverSession.txnNumber++;
      }
      /**
       * @returns {boolean} whether this session is currently in a transaction or not
       */
      inTransaction() {
        return this.transaction.isActive;
      }
      /**
       * Starts a new transaction with the given options.
       *
       * @param {TransactionOptions} options Options for the transaction
       */
      startTransaction(options) {
        assertAlive(this);
        if (this.inTransaction()) {
          throw new MongoError("Transaction already in progress");
        }
        const topologyMaxWireVersion = maxWireVersion(this.topology);
        if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
          throw new MongoError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
        }
        this.incrementTransactionNumber();
        this.transaction = new Transaction(
          Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions)
        );
        this.transaction.transition(TxnState.STARTING_TRANSACTION);
      }
      /**
       * Commits the currently active transaction in this session.
       *
       * @param {Function} [callback] optional callback for completion of this operation
       * @return {Promise} A promise is returned if no callback is provided
       */
      commitTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "commitTransaction", done));
      }
      /**
       * Aborts the currently active transaction in this session.
       *
       * @param {Function} [callback] optional callback for completion of this operation
       * @return {Promise} A promise is returned if no callback is provided
       */
      abortTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "abortTransaction", done));
      }
      /**
       * This is here to ensure that ClientSession is never serialized to BSON.
       * @ignore
       */
      toBSON() {
        throw new Error("ClientSession cannot be serialized to BSON.");
      }
      /**
       * A user provided function to be run within a transaction
       *
       * @callback WithTransactionCallback
       * @param {ClientSession} session The parent session of the transaction running the operation. This should be passed into each operation within the lambda.
       * @returns {Promise} The resulting Promise of operations run within this transaction
       */
      /**
       * Runs a provided lambda within a transaction, retrying either the commit operation
       * or entire transaction as needed (and when the error permits) to better ensure that
       * the transaction can complete successfully.
       *
       * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not
       * return a Promise will result in undefined behavior.
       *
       * @param {WithTransactionCallback} fn
       * @param {TransactionOptions} [options] Optional settings for the transaction
       */
      withTransaction(fn, options) {
        const startTime = now();
        return attemptTransaction(this, startTime, fn, options);
      }
    };
    var MAX_WITH_TRANSACTION_TIMEOUT = 12e4;
    var UNSATISFIABLE_WRITE_CONCERN_CODE = 100;
    var UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;
    var MAX_TIME_MS_EXPIRED_CODE = 50;
    var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = /* @__PURE__ */ new Set([
      "CannotSatisfyWriteConcern",
      "UnknownReplWriteConcern",
      "UnsatisfiableWriteConcern"
    ]);
    function hasNotTimedOut(startTime, max) {
      return calculateDurationInMs(startTime) < max;
    }
    function isUnknownTransactionCommitResult(err) {
      return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;
    }
    function isMaxTimeMSExpiredError(err) {
      if (err == null)
        return false;
      return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;
    }
    function attemptTransactionCommit(session, startTime, fn, options) {
      return session.commitTransaction().catch((err) => {
        if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
          if (err.hasErrorLabel("UnknownTransactionCommitResult")) {
            return attemptTransactionCommit(session, startTime, fn, options);
          }
          if (err.hasErrorLabel("TransientTransactionError")) {
            return attemptTransaction(session, startTime, fn, options);
          }
        }
        throw err;
      });
    }
    var USER_EXPLICIT_TXN_END_STATES = /* @__PURE__ */ new Set([
      TxnState.NO_TRANSACTION,
      TxnState.TRANSACTION_COMMITTED,
      TxnState.TRANSACTION_ABORTED
    ]);
    function userExplicitlyEndedTransaction(session) {
      return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
    }
    function attemptTransaction(session, startTime, fn, options) {
      session.startTransaction(options);
      let promise;
      try {
        promise = fn(session);
      } catch (err) {
        promise = Promise.reject(err);
      }
      if (!isPromiseLike(promise)) {
        session.abortTransaction();
        throw new TypeError("Function provided to `withTransaction` must return a Promise");
      }
      return promise.then(() => {
        if (userExplicitlyEndedTransaction(session)) {
          return;
        }
        return attemptTransactionCommit(session, startTime, fn, options);
      }).catch((err) => {
        function maybeRetryOrThrow(err2) {
          if (err2 instanceof MongoError && err2.hasErrorLabel("TransientTransactionError") && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
            return attemptTransaction(session, startTime, fn, options);
          }
          if (isMaxTimeMSExpiredError(err2)) {
            err2.addErrorLabel("UnknownTransactionCommitResult");
          }
          throw err2;
        }
        if (session.transaction.isActive) {
          return session.abortTransaction().then(() => maybeRetryOrThrow(err));
        }
        return maybeRetryOrThrow(err);
      });
    }
    function endTransaction(session, commandName, callback) {
      if (!assertAlive(session, callback)) {
        return;
      }
      let txnState = session.transaction.state;
      if (txnState === TxnState.NO_TRANSACTION) {
        callback(new MongoError("No transaction started"));
        return;
      }
      if (commandName === "commitTransaction") {
        if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call commitTransaction after calling abortTransaction"));
          return;
        }
      } else {
        if (txnState === TxnState.STARTING_TRANSACTION) {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call abortTransaction twice"));
          return;
        }
        if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          callback(new MongoError("Cannot call abortTransaction after calling commitTransaction"));
          return;
        }
      }
      const command = { [commandName]: 1 };
      let writeConcern;
      if (session.transaction.options.writeConcern) {
        writeConcern = Object.assign({}, session.transaction.options.writeConcern);
      } else if (session.clientOptions && session.clientOptions.w) {
        writeConcern = { w: session.clientOptions.w };
      }
      if (txnState === TxnState.TRANSACTION_COMMITTED) {
        writeConcern = Object.assign({ wtimeout: 1e4 }, writeConcern, { w: "majority" });
      }
      if (writeConcern) {
        Object.assign(command, { writeConcern });
      }
      if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });
      }
      function commandHandler(e, r) {
        if (commandName === "commitTransaction") {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED);
          if (e) {
            if (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e)) {
              if (isUnknownTransactionCommitResult(e)) {
                e.addErrorLabel("UnknownTransactionCommitResult");
                session.transaction.unpinServer();
              }
            } else if (e.hasErrorLabel("TransientTransactionError")) {
              session.transaction.unpinServer();
            }
          }
        } else {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
        }
        callback(e, r);
      }
      function transactionError(err) {
        return commandName === "commitTransaction" ? err : null;
      }
      if (
        // Assumption here that commandName is "commitTransaction" or "abortTransaction"
        session.transaction.recoveryToken && supportsRecoveryToken(session)
      ) {
        command.recoveryToken = session.transaction.recoveryToken;
      }
      session.topology.command("admin.$cmd", command, { session }, (err, reply) => {
        if (err && isRetryableEndTransactionError(err)) {
          if (command.commitTransaction) {
            session.transaction.unpinServer();
            command.writeConcern = Object.assign({ wtimeout: 1e4 }, command.writeConcern, {
              w: "majority"
            });
          }
          return session.topology.command(
            "admin.$cmd",
            command,
            { session },
            (_err, _reply) => commandHandler(transactionError(_err), _reply)
          );
        }
        commandHandler(transactionError(err), reply);
      });
    }
    function supportsRecoveryToken(session) {
      const topology = session.topology;
      return !!topology.s.options.useRecoveryToken;
    }
    var ServerSession = class {
      constructor() {
        this.id = { id: new Binary2(uuidV4(), Binary2.SUBTYPE_UUID) };
        this.lastUse = now();
        this.txnNumber = 0;
        this.isDirty = false;
      }
      /**
       * Determines if the server session has timed out.
       * @ignore
       * @param {Date} sessionTimeoutMinutes The server's "logicalSessionTimeoutMinutes"
       * @return {boolean} true if the session has timed out.
       */
      hasTimedOut(sessionTimeoutMinutes) {
        const idleTimeMinutes = Math.round(
          calculateDurationInMs(this.lastUse) % 864e5 % 36e5 / 6e4
        );
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
      }
    };
    var ServerSessionPool = class {
      constructor(topology) {
        if (topology == null) {
          throw new Error("ServerSessionPool requires a topology");
        }
        this.topology = topology;
        this.sessions = [];
      }
      /**
       * Ends all sessions in the session pool.
       * @ignore
       */
      endAllPooledSessions(callback) {
        if (this.sessions.length) {
          this.topology.endSessions(
            this.sessions.map((session) => session.id),
            () => {
              this.sessions = [];
              if (typeof callback === "function") {
                callback();
              }
            }
          );
          return;
        }
        if (typeof callback === "function") {
          callback();
        }
      }
      /**
       * Acquire a Server Session from the pool.
       * Iterates through each session in the pool, removing any stale sessions
       * along the way. The first non-stale session found is removed from the
       * pool and returned. If no non-stale session is found, a new ServerSession
       * is created.
       * @ignore
       * @returns {ServerSession}
       */
      acquire() {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const session = this.sessions.shift();
          if (!session.hasTimedOut(sessionTimeoutMinutes)) {
            return session;
          }
        }
        return new ServerSession();
      }
      /**
       * Release a session to the session pool
       * Adds the session back to the session pool if the session has not timed out yet.
       * This method also removes any stale sessions from the pool.
       * @ignore
       * @param {ServerSession} session The session to release to the pool
       */
      release(session) {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const pooledSession = this.sessions[this.sessions.length - 1];
          if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
            this.sessions.pop();
          } else {
            break;
          }
        }
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          if (session.isDirty) {
            return;
          }
          this.sessions.unshift(session);
        }
      }
    };
    function commandSupportsReadConcern(command, options) {
      if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {
        return true;
      }
      if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === "inline")) {
        return true;
      }
      return false;
    }
    function applySession(session, command, options) {
      if (session.hasEnded) {
        return new MongoError("Cannot use a session that has ended");
      }
      if (options && options.writeConcern && options.writeConcern.w === 0) {
        return;
      }
      const serverSession = session.serverSession;
      serverSession.lastUse = now();
      command.lsid = serverSession.id;
      const inTransaction = session.inTransaction() || isTransactionCommand(command);
      const isRetryableWrite = options.willRetryWrite;
      const shouldApplyReadConcern = commandSupportsReadConcern(command, options);
      if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {
        command.txnNumber = BSON2.Long.fromNumber(serverSession.txnNumber);
      }
      if (!inTransaction) {
        if (session.transaction.state !== TxnState.NO_TRANSACTION) {
          session.transaction.transition(TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
        return;
      }
      if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {
        return new MongoError(
          `Read preference in a transaction must be primary, not: ${options.readPreference.mode}`
        );
      }
      command.autocommit = false;
      if (session.transaction.state === TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;
        if (readConcern) {
          command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
      }
    }
    function updateSessionFromResponse(session, document) {
      if (document.$clusterTime) {
        resolveClusterTime(session, document.$clusterTime);
      }
      if (document.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document.operationTime);
      }
      if (document.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document.recoveryToken;
      }
    }
    module2.exports = {
      ClientSession,
      ServerSession,
      ServerSessionPool,
      TxnState,
      applySession,
      updateSessionFromResponse,
      commandSupportsReadConcern
    };
  }
});

// node_modules/mongodb/lib/core/connection/pool.js
var require_pool = __commonJS({
  "node_modules/mongodb/lib/core/connection/pool.js"(exports2, module2) {
    "use strict";
    var inherits = __require("util").inherits;
    var EventEmitter = __require("events").EventEmitter;
    var MongoError = require_error().MongoError;
    var MongoTimeoutError = require_error().MongoTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Logger = require_logger();
    var f = __require("util").format;
    var Msg = require_msg().Msg;
    var CommandResult = require_command_result();
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var apm = require_apm();
    var Buffer2 = require_safe_buffer().Buffer;
    var connect = require_connect();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var eachAsync = require_utils3().eachAsync;
    var makeStateMachine = require_utils3().makeStateMachine;
    var now = require_utils().now;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var DRAINING = "draining";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    var stateTransition = makeStateMachine({
      [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],
      [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],
      [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],
      [DRAINING]: [DRAINING, DESTROYING, DESTROYED],
      [DESTROYING]: [DESTROYING, DESTROYED],
      [DESTROYED]: [DESTROYED]
    });
    var CONNECTION_EVENTS = /* @__PURE__ */ new Set([
      "error",
      "close",
      "timeout",
      "parseError",
      "connect",
      "message"
    ]);
    var _id = 0;
    var Pool = function(topology, options) {
      EventEmitter.call(this);
      this.topology = topology;
      this.s = {
        state: DISCONNECTED,
        cancellationToken: new EventEmitter()
      };
      this.s.cancellationToken.setMaxListeners(Infinity);
      this.options = Object.assign(
        {
          // Host and port settings
          host: "localhost",
          port: 27017,
          // Pool default max size
          size: 5,
          // Pool default min size
          minSize: 0,
          // socket settings
          connectionTimeout: 3e4,
          socketTimeout: 0,
          keepAlive: true,
          keepAliveInitialDelay: 12e4,
          noDelay: true,
          // SSL Settings
          ssl: false,
          checkServerIdentity: true,
          ca: null,
          crl: null,
          cert: null,
          key: null,
          passphrase: null,
          rejectUnauthorized: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false,
          // Reconnection options
          reconnect: true,
          reconnectInterval: 1e3,
          reconnectTries: 30,
          // Enable domains
          domainsEnabled: false,
          // feature flag for determining if we are running with the unified topology or not
          legacyCompatMode: true
        },
        options
      );
      this.id = _id++;
      this.retriesLeft = this.options.reconnectTries;
      this.reconnectId = null;
      this.reconnectError = null;
      if (!options.bson || options.bson && (typeof options.bson.serialize !== "function" || typeof options.bson.deserialize !== "function")) {
        throw new Error("must pass in valid bson parser");
      }
      this.logger = Logger("Pool", options);
      this.availableConnections = [];
      this.inUseConnections = [];
      this.connectingConnections = 0;
      this.executing = false;
      this.queue = [];
      this.numberOfConsecutiveTimeouts = 0;
      this.connectionIndex = 0;
      const pool = this;
      this._messageHandler = messageHandler(this);
      this._connectionCloseHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "close", err, connection);
      };
      this._connectionErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "error", err, connection);
      };
      this._connectionTimeoutHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "timeout", err, connection);
      };
      this._connectionParseErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "parseError", err, connection);
      };
    };
    inherits(Pool, EventEmitter);
    Object.defineProperty(Pool.prototype, "size", {
      enumerable: true,
      get: function() {
        return this.options.size;
      }
    });
    Object.defineProperty(Pool.prototype, "minSize", {
      enumerable: true,
      get: function() {
        return this.options.minSize;
      }
    });
    Object.defineProperty(Pool.prototype, "connectionTimeout", {
      enumerable: true,
      get: function() {
        return this.options.connectionTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "socketTimeout", {
      enumerable: true,
      get: function() {
        return this.options.socketTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "state", {
      enumerable: true,
      get: function() {
        return this.s.state;
      }
    });
    function resetPoolState(pool) {
      pool.inUseConnections = [];
      pool.availableConnections = [];
      pool.connectingConnections = 0;
      pool.executing = false;
      pool.numberOfConsecutiveTimeouts = 0;
      pool.connectionIndex = 0;
      pool.retriesLeft = pool.options.reconnectTries;
      pool.reconnectId = null;
    }
    function connectionFailureHandler(pool, event, err, conn) {
      if (conn) {
        if (conn._connectionFailHandled) {
          return;
        }
        conn._connectionFailHandled = true;
        conn.destroy();
        removeConnection(pool, conn);
        conn.flush(err);
      }
      if (event === "timeout") {
        pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;
        if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {
          pool.numberOfConsecutiveTimeouts = 0;
          pool.destroy(true);
          return pool.emit("close", pool);
        }
      }
      if (pool.socketCount() === 0) {
        if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {
          if (pool.options.reconnect) {
            stateTransition(pool, DISCONNECTED);
          }
        }
        event = event === "error" ? "close" : event;
        pool.emit(event, err);
      }
      if (!pool.reconnectId && pool.options.reconnect) {
        pool.reconnectError = err;
        pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);
      }
      const totalConnections = totalConnectionCount(pool);
      if (totalConnections < pool.minSize) {
        createConnection(pool);
      }
    }
    function attemptReconnect(pool, callback) {
      return function() {
        pool.emit("attemptReconnect", pool);
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Cannot create connection when pool is destroyed"));
          }
          return;
        }
        pool.retriesLeft = pool.retriesLeft - 1;
        if (pool.retriesLeft <= 0) {
          pool.destroy();
          const error = new MongoTimeoutError(
            `failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`,
            pool.reconnectError
          );
          pool.emit("reconnectFailed", error);
          if (typeof callback === "function") {
            callback(error);
          }
          return;
        }
        pool.reconnectId = null;
        createConnection(pool, (err, conn) => {
          if (err == null) {
            pool.reconnectId = null;
            pool.retriesLeft = pool.options.reconnectTries;
            pool.emit("reconnect", pool);
          }
          if (typeof callback === "function") {
            callback(err, conn);
          }
        });
      };
    }
    function moveConnectionBetween(connection, from, to) {
      var index = from.indexOf(connection);
      if (index !== -1) {
        from.splice(index, 1);
        to.push(connection);
      }
    }
    function messageHandler(self2) {
      return function(message, connection) {
        var workItem = null;
        for (var i = 0; i < connection.workItems.length; i++) {
          if (connection.workItems[i].requestId === message.responseTo) {
            workItem = connection.workItems[i];
            connection.workItems.splice(i, 1);
          }
        }
        if (workItem && workItem.monitoring) {
          moveConnectionBetween(connection, self2.inUseConnections, self2.availableConnections);
        }
        self2.numberOfConsecutiveTimeouts = 0;
        if (workItem && workItem.socketTimeout) {
          connection.resetSocketTimeout();
        }
        if (self2.logger.isDebug()) {
          self2.logger.debug(
            f(
              "message [ %s ] received from %s:%s",
              message.raw.length,
              self2.options.host,
              self2.options.port
            )
          );
        }
        function handleOperationCallback(self3, cb, err, result) {
          if (!self3.options.domainsEnabled) {
            return process.nextTick(function() {
              return cb(err, result);
            });
          }
          cb(err, result);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
        if (workItem && !workItem.immediateRelease) {
          try {
            message.parse(workItem);
          } catch (err) {
            return handleOperationCallback(self2, workItem.cb, new MongoError(err));
          }
          if (message.documents[0]) {
            const document = message.documents[0];
            const session = workItem.session;
            if (session) {
              updateSessionFromResponse(session, document);
            }
            if (self2.topology && document.$clusterTime) {
              self2.topology.clusterTime = document.$clusterTime;
            }
          }
          if (workItem.command && message.documents[0]) {
            const responseDoc = message.documents[0];
            if (responseDoc.writeConcernError) {
              const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);
              return handleOperationCallback(self2, workItem.cb, err);
            }
            if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {
              return handleOperationCallback(self2, workItem.cb, new MongoError(responseDoc));
            }
          }
          message.hashedName = connection.hashedName;
          handleOperationCallback(
            self2,
            workItem.cb,
            null,
            new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message)
          );
        }
      };
    }
    Pool.prototype.socketCount = function() {
      return this.availableConnections.length + this.inUseConnections.length;
    };
    function totalConnectionCount(pool) {
      return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;
    }
    Pool.prototype.allConnections = function() {
      return this.availableConnections.concat(this.inUseConnections);
    };
    Pool.prototype.get = function() {
      return this.allConnections()[0];
    };
    Pool.prototype.isConnected = function() {
      if (this.state === DESTROYED || this.state === DESTROYING) {
        return false;
      }
      var connections = this.availableConnections.concat(this.inUseConnections);
      for (var i = 0; i < connections.length; i++) {
        if (connections[i].isConnected())
          return true;
      }
      return false;
    };
    Pool.prototype.isDestroyed = function() {
      return this.state === DESTROYED || this.state === DESTROYING;
    };
    Pool.prototype.isDisconnected = function() {
      return this.state === DISCONNECTED;
    };
    Pool.prototype.connect = function(callback) {
      if (this.state !== DISCONNECTED) {
        throw new MongoError("connection in unlawful state " + this.state);
      }
      stateTransition(this, CONNECTING);
      createConnection(this, (err, conn) => {
        if (err) {
          if (typeof callback === "function") {
            this.destroy();
            callback(err);
            return;
          }
          if (this.state === CONNECTING) {
            this.emit("error", err);
          }
          this.destroy();
          return;
        }
        stateTransition(this, CONNECTED);
        if (this.minSize) {
          for (let i = 0; i < this.minSize; i++) {
            createConnection(this);
          }
        }
        if (typeof callback === "function") {
          callback(null, conn);
        } else {
          this.emit("connect", this, conn);
        }
      });
    };
    Pool.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.logout = function(dbName, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.unref = function() {
      var connections = this.availableConnections.concat(this.inUseConnections);
      connections.forEach(function(c) {
        c.unref();
      });
    };
    function destroy(self2, connections, options, callback) {
      stateTransition(self2, DESTROYING);
      self2.s.cancellationToken.emit("cancel");
      eachAsync(
        connections,
        (conn, cb) => {
          for (const eventName of CONNECTION_EVENTS) {
            conn.removeAllListeners(eventName);
          }
          conn.on("error", () => {
          });
          conn.destroy(options, cb);
        },
        (err) => {
          if (err) {
            if (typeof callback === "function")
              callback(err, null);
            return;
          }
          resetPoolState(self2);
          self2.queue = [];
          stateTransition(self2, DESTROYED);
          if (typeof callback === "function")
            callback(null, null);
        }
      );
    }
    Pool.prototype.destroy = function(force, callback) {
      var self2 = this;
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      if (this.state === DESTROYED || self2.state === DESTROYING) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DRAINING);
      if (force) {
        var connections = self2.availableConnections.concat(self2.inUseConnections);
        while (self2.queue.length > 0) {
          var workItem = self2.queue.shift();
          if (typeof workItem.cb === "function") {
            workItem.cb(new MongoError("Pool was force destroyed"));
          }
        }
        return destroy(self2, connections, { force: true }, callback);
      }
      if (this.reconnectId) {
        clearTimeout(this.reconnectId);
      }
      function checkStatus() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        flushMonitoringOperations(self2.queue);
        if (self2.queue.length === 0) {
          var connections2 = self2.availableConnections.concat(self2.inUseConnections);
          for (var i = 0; i < connections2.length; i++) {
            if (connections2[i].workItems.length > 0) {
              return setTimeout(checkStatus, 1);
            }
          }
          destroy(self2, connections2, { force: false }, callback);
        } else {
          _execute(self2)();
          setTimeout(checkStatus, 1);
        }
      }
      checkStatus();
    };
    Pool.prototype.reset = function(callback) {
      if (this.s.state !== CONNECTED) {
        if (typeof callback === "function") {
          callback(new MongoError("pool is not connected, reset aborted"));
        }
        return;
      }
      this.s.cancellationToken.emit("cancel");
      const connections = this.availableConnections.concat(this.inUseConnections);
      eachAsync(
        connections,
        (conn, cb) => {
          for (const eventName of CONNECTION_EVENTS) {
            conn.removeAllListeners(eventName);
          }
          conn.destroy({ force: true }, cb);
        },
        (err) => {
          if (err) {
            if (typeof callback === "function") {
              callback(err, null);
              return;
            }
          }
          resetPoolState(this);
          createConnection(this, () => {
            if (typeof callback === "function") {
              callback(null, null);
            }
          });
        }
      );
    };
    function serializeCommand(self2, command, callback) {
      const originalCommandBuffer = command.toBin();
      const shouldCompress = !!self2.options.agreedCompressor;
      if (!shouldCompress || !canCompress(command)) {
        return callback(null, originalCommandBuffer);
      }
      const concatenatedOriginalCommandBuffer = Buffer2.concat(originalCommandBuffer);
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      compress(self2, messageToBeCompressed, function(err, compressedMessage) {
        if (err)
          return callback(err, null);
        const msgHeader = Buffer2.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(
          MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,
          0
        );
        msgHeader.writeInt32LE(command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
        const compressionDetails = Buffer2.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compressorIDs[self2.options.agreedCompressor], 8);
        return callback(null, [msgHeader, compressionDetails, compressedMessage]);
      });
    }
    Pool.prototype.write = function(command, options, cb) {
      var self2 = this;
      if (typeof options === "function") {
        cb = options;
      }
      options = options || {};
      if (!(typeof cb === "function") && !options.noResponse) {
        throw new MongoError("write method must provide a callback");
      }
      if (this.state === DESTROYED || this.state === DESTROYING) {
        cb(new MongoError("pool destroyed"));
        return;
      }
      if (this.state === DRAINING) {
        cb(new MongoError("pool is draining, new operations prohibited"));
        return;
      }
      if (this.options.domainsEnabled && process.domain && typeof cb === "function") {
        var oldCb = cb;
        cb = process.domain.bind(function() {
          var args = new Array(arguments.length);
          for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          process.nextTick(function() {
            oldCb.apply(null, args);
          });
        });
      }
      var operation = {
        cb,
        raw: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false,
        fullResult: false
      };
      operation.promoteLongs = typeof options.promoteLongs === "boolean" ? options.promoteLongs : true;
      operation.promoteValues = typeof options.promoteValues === "boolean" ? options.promoteValues : true;
      operation.promoteBuffers = typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false;
      operation.bsonRegExp = typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false;
      operation.raw = typeof options.raw === "boolean" ? options.raw : false;
      operation.immediateRelease = typeof options.immediateRelease === "boolean" ? options.immediateRelease : false;
      operation.documentsReturnedIn = options.documentsReturnedIn;
      operation.command = typeof options.command === "boolean" ? options.command : false;
      operation.fullResult = typeof options.fullResult === "boolean" ? options.fullResult : false;
      operation.noResponse = typeof options.noResponse === "boolean" ? options.noResponse : false;
      operation.session = options.session || null;
      operation.socketTimeout = options.socketTimeout;
      operation.monitoring = options.monitoring;
      operation.requestId = command.requestId;
      if (self2.options.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operation.started = now();
        operation.cb = (err, reply) => {
          if (err) {
            self2.emit(
              "commandFailed",
              new apm.CommandFailedEvent(this, command, err, operation.started)
            );
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              self2.emit(
                "commandFailed",
                new apm.CommandFailedEvent(this, command, reply.result, operation.started)
              );
            } else {
              self2.emit(
                "commandSucceeded",
                new apm.CommandSucceededEvent(this, command, reply, operation.started)
              );
            }
          }
          if (typeof cb === "function")
            cb(err, reply);
        };
      }
      serializeCommand(self2, command, (err, serializedBuffers) => {
        if (err)
          throw err;
        operation.buffer = serializedBuffers;
        if (options.monitoring) {
          self2.queue.unshift(operation);
        } else {
          self2.queue.push(operation);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
      });
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function remove(connection, connections) {
      for (var i = 0; i < connections.length; i++) {
        if (connections[i] === connection) {
          connections.splice(i, 1);
          return true;
        }
      }
    }
    function removeConnection(self2, connection) {
      if (remove(connection, self2.availableConnections))
        return;
      if (remove(connection, self2.inUseConnections))
        return;
    }
    function createConnection(pool, callback) {
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Cannot create connection when pool is destroyed"));
        }
        return;
      }
      pool.connectingConnections++;
      connect(pool.options, pool.s.cancellationToken, (err, connection) => {
        pool.connectingConnections--;
        if (err) {
          if (pool.logger.isDebug()) {
            pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          }
          if (!pool.reconnectId && pool.options.reconnect) {
            if (pool.state === CONNECTING && pool.options.legacyCompatMode) {
              callback(err);
              return;
            }
            pool.reconnectError = err;
            pool.reconnectId = setTimeout(
              attemptReconnect(pool, callback),
              pool.options.reconnectInterval
            );
            return;
          }
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Pool was destroyed after connection creation"));
          }
          connection.destroy();
          return;
        }
        connection.on("error", pool._connectionErrorHandler);
        connection.on("close", pool._connectionCloseHandler);
        connection.on("timeout", pool._connectionTimeoutHandler);
        connection.on("parseError", pool._connectionParseErrorHandler);
        connection.on("message", pool._messageHandler);
        pool.availableConnections.push(connection);
        if (typeof callback === "function") {
          callback(null, connection);
        }
        _execute(pool)();
      });
    }
    function flushMonitoringOperations(queue) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].monitoring) {
          var workItem = queue[i];
          queue.splice(i, 1);
          workItem.cb(
            new MongoError({ message: "no connection available for monitoring", driver: true })
          );
        }
      }
    }
    function _execute(self2) {
      return function() {
        if (self2.state === DESTROYED)
          return;
        if (self2.executing)
          return;
        self2.executing = true;
        if (self2.connectingConnections > 0) {
          self2.executing = false;
          return;
        }
        while (true) {
          const totalConnections = totalConnectionCount(self2);
          if (self2.availableConnections.length === 0) {
            flushMonitoringOperations(self2.queue);
            if (totalConnections < self2.options.size && self2.queue.length > 0) {
              createConnection(self2);
            }
            break;
          }
          if (self2.queue.length === 0) {
            break;
          }
          var connection = null;
          const connections = self2.availableConnections.filter((conn) => conn.workItems.length === 0);
          if (connections.length === 0) {
            connection = self2.availableConnections[self2.connectionIndex++ % self2.availableConnections.length];
          } else {
            connection = connections[self2.connectionIndex++ % connections.length];
          }
          if (!connection.isConnected()) {
            removeConnection(self2, connection);
            flushMonitoringOperations(self2.queue);
            break;
          }
          var workItem = self2.queue.shift();
          if (workItem.monitoring) {
            var foundValidConnection = false;
            for (let i = 0; i < self2.availableConnections.length; i++) {
              if (self2.availableConnections[i].isConnected() && self2.availableConnections[i].workItems.length === 0) {
                foundValidConnection = true;
                connection = self2.availableConnections[i];
                break;
              }
            }
            if (!foundValidConnection) {
              self2.queue.unshift(workItem);
              if (totalConnections < self2.options.size && self2.queue.length > 0) {
                createConnection(self2);
              }
              setTimeout(() => _execute(self2)(), 10);
              break;
            }
          }
          if (totalConnections < self2.options.size) {
            if (connection.workItems.length > 0) {
              self2.queue.unshift(workItem);
              createConnection(self2);
              break;
            }
          }
          var buffer = workItem.buffer;
          if (workItem.monitoring) {
            moveConnectionBetween(connection, self2.availableConnections, self2.inUseConnections);
          }
          if (!workItem.noResponse) {
            connection.workItems.push(workItem);
          }
          if (!workItem.immediateRelease && typeof workItem.socketTimeout === "number") {
            connection.setSocketTimeout(workItem.socketTimeout);
          }
          var writeSuccessful = true;
          if (Array.isArray(buffer)) {
            for (let i = 0; i < buffer.length; i++) {
              writeSuccessful = connection.write(buffer[i]);
            }
          } else {
            writeSuccessful = connection.write(buffer);
          }
          if (workItem.noResponse && typeof workItem.cb === "function") {
            workItem.cb(null, null);
          }
          if (writeSuccessful === false) {
            self2.queue.unshift(workItem);
            removeConnection(self2, connection);
            flushMonitoringOperations(self2.queue);
            break;
          }
        }
        self2.executing = false;
      };
    }
    Pool._execute = _execute;
    module2.exports = Pool;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/command.js
var require_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/command.js"(exports2, module2) {
    "use strict";
    var Query = require_commands().Query;
    var Msg = require_msg().Msg;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var isSharded = require_shared().isSharded;
    var databaseNamespace = require_shared().databaseNamespace;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var applySession = require_sessions().applySession;
    var MongoNetworkError = require_error().MongoNetworkError;
    var maxWireVersion = require_utils3().maxWireVersion;
    function isClientEncryptionEnabled(server) {
      const wireVersion = maxWireVersion(server);
      return wireVersion && server.autoEncrypter;
    }
    function command(server, ns, cmd, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (!isClientEncryptionEnabled(server)) {
        _command(server, ns, cmd, options, callback);
        return;
      }
      const wireVersion = maxWireVersion(server);
      if (typeof wireVersion !== "number" || wireVersion < 8) {
        callback(new MongoError("Auto-encryption requires a minimum MongoDB version of 4.2"));
        return;
      }
      _cryptCommand(server, ns, cmd, options, callback);
    }
    function _command(server, ns, cmd, options, callback) {
      const bson = server.s.bson;
      const pool = server.s.pool;
      const readPreference = getReadPreference(cmd, options);
      const shouldUseOpMsg = supportsOpMsg(server);
      const session = options.session;
      const serverClusterTime = server.clusterTime;
      let clusterTime = serverClusterTime;
      let finalCmd = Object.assign({}, cmd);
      const serverApi = options.serverApi;
      if (serverApi) {
        finalCmd.apiVersion = serverApi.version || serverApi;
        if (serverApi.strict != null) {
          finalCmd.apiStrict = serverApi.strict;
        }
        if (serverApi.deprecationErrors != null) {
          finalCmd.apiDeprecationErrors = serverApi.deprecationErrors;
        }
      }
      if (hasSessionSupport(server) && session) {
        const sessionClusterTime = session.clusterTime;
        if (serverClusterTime && serverClusterTime.clusterTime && sessionClusterTime && sessionClusterTime.clusterTime && sessionClusterTime.clusterTime.greaterThan(serverClusterTime.clusterTime)) {
          clusterTime = sessionClusterTime;
        }
        if (!session.transaction.isActive && session.transaction.isPinned && !finalCmd.startTransaction && !finalCmd.commitTransaction) {
          session.transaction.unpinServer();
        }
        const err = applySession(session, finalCmd, options);
        if (err) {
          return callback(err);
        }
      }
      if (clusterTime) {
        finalCmd.$clusterTime = clusterTime;
      }
      if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
        finalCmd = {
          $query: finalCmd,
          $readPreference: readPreference.toJSON()
        };
      }
      const commandOptions = Object.assign(
        {
          command: true,
          numberToSkip: 0,
          numberToReturn: -1,
          checkKeys: false
        },
        options
      );
      commandOptions.slaveOk = readPreference.slaveOk();
      const cmdNs = `${databaseNamespace(ns)}.$cmd`;
      const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);
      const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));
      const commandResponseHandler = inTransaction ? function(err) {
        if (err && err instanceof MongoNetworkError && !err.hasErrorLabel("TransientTransactionError")) {
          err.addErrorLabel("TransientTransactionError");
        }
        if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel("TransientTransactionError")) {
          session.transaction.unpinServer();
        }
        return callback.apply(null, arguments);
      } : callback;
      try {
        pool.write(message, commandOptions, commandResponseHandler);
      } catch (err) {
        commandResponseHandler(err);
      }
    }
    function hasSessionSupport(topology) {
      if (topology == null)
        return false;
      if (topology.description) {
        return topology.description.maxWireVersion >= 6;
      }
      return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;
    }
    function supportsOpMsg(topologyOrServer) {
      const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;
      if (description == null) {
        return false;
      }
      return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;
    }
    function _cryptCommand(server, ns, cmd, options, callback) {
      const autoEncrypter = server.autoEncrypter;
      function commandResponseHandler(err, response) {
        if (err || response == null) {
          callback(err, response);
          return;
        }
        autoEncrypter.decrypt(response.result, options, (err2, decrypted) => {
          if (err2) {
            callback(err2, null);
            return;
          }
          response.result = decrypted;
          response.message.documents = [decrypted];
          callback(null, response);
        });
      }
      autoEncrypter.encrypt(ns, cmd, options, (err, encrypted) => {
        if (err) {
          callback(err, null);
          return;
        }
        _command(server, ns, encrypted, options, commandResponseHandler);
      });
    }
    module2.exports = command;
  }
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS({
  "node_modules/mongodb/lib/explain.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var Explain = class _Explain {
      /**
       * Constructs an Explain from the explain verbosity.
       *
       * For backwards compatibility, true is interpreted as "allPlansExecution"
       * and false as "queryPlanner". Prior to server version 3.6, aggregate()
       * ignores the verbosity parameter and executes in "queryPlanner".
       *
       * @param {string|boolean} [verbosity] The verbosity mode for the explain output.
       */
      constructor(verbosity) {
        if (typeof verbosity === "boolean") {
          this.verbosity = verbosity ? "allPlansExecution" : "queryPlanner";
        } else {
          this.verbosity = verbosity;
        }
      }
      /**
       * Construct an Explain given an options object.
       *
       * @param {object} [options] The options object from which to extract the explain.
       * @param {string|boolean} [options.explain] The verbosity mode for the explain output.
       * @return {Explain}
       */
      static fromOptions(options) {
        if (options == null || options.explain === void 0) {
          return;
        }
        const explain = options.explain;
        if (typeof explain === "boolean" || typeof explain === "string") {
          return new _Explain(options.explain);
        }
        throw new MongoError(`explain must be a string or a boolean`);
      }
    };
    module2.exports = { Explain };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/write_command.js
var require_write_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/write_command.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var collectionNamespace = require_shared().collectionNamespace;
    var command = require_command();
    var decorateWithExplain = require_utils().decorateWithExplain;
    var Explain = require_explain().Explain;
    function writeCommand(server, type, opsField, ns, ops, options, callback) {
      if (ops.length === 0)
        throw new MongoError(`${type} must contain at least one document`);
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const writeConcern = options.writeConcern;
      let writeCommand2 = {};
      writeCommand2[type] = collectionNamespace(ns);
      writeCommand2[opsField] = ops;
      writeCommand2.ordered = ordered;
      if (writeConcern && Object.keys(writeConcern).length > 0) {
        writeCommand2.writeConcern = writeConcern;
      }
      if (options.collation) {
        for (let i = 0; i < writeCommand2[opsField].length; i++) {
          if (!writeCommand2[opsField][i].collation) {
            writeCommand2[opsField][i].collation = options.collation;
          }
        }
      }
      if (options.bypassDocumentValidation === true) {
        writeCommand2.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      const explain = Explain.fromOptions(options);
      if (explain) {
        writeCommand2 = decorateWithExplain(writeCommand2, explain);
      }
      const commandOptions = Object.assign(
        {
          checkKeys: type === "insert",
          numberToReturn: 1
        },
        options
      );
      command(server, ns, writeCommand2, commandOptions, callback);
    }
    module2.exports = writeCommand;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js
var require_kill_cursors = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js"(exports2, module2) {
    "use strict";
    var KillCursor = require_commands().KillCursor;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils3().maxWireVersion;
    var emitWarning = require_utils3().emitWarning;
    var command = require_command();
    function killCursors(server, ns, cursorState, defaultOptions, callback) {
      if (typeof defaultOptions === "function") {
        callback = defaultOptions;
        defaultOptions = {};
      }
      callback = typeof callback === "function" ? callback : () => {
      };
      const cursorId = cursorState.cursorId;
      if (maxWireVersion(server) < 4) {
        const bson = server.s.bson;
        const pool = server.s.pool;
        const killCursor = new KillCursor(bson, ns, [cursorId]);
        const options2 = {
          immediateRelease: true,
          noResponse: true
        };
        if (typeof cursorState.session === "object") {
          options2.session = cursorState.session;
        }
        if (pool && pool.isConnected()) {
          try {
            pool.write(killCursor, options2, callback);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err, null);
            } else {
              emitWarning(err);
            }
          }
        }
        return;
      }
      const killCursorCmd = {
        killCursors: collectionNamespace(ns),
        cursors: [cursorId]
      };
      const options = defaultOptions || {};
      if (typeof cursorState.session === "object")
        options.session = cursorState.session;
      command(server, ns, killCursorCmd, options, (err, result) => {
        if (err) {
          return callback(err);
        }
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (!Array.isArray(response.documents) || response.documents.length === 0) {
          return callback(
            new MongoError(`invalid killCursors result returned for cursor id ${cursorId}`)
          );
        }
        callback(null, response.documents[0]);
      });
    }
    module2.exports = killCursors;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/get_more.js
var require_get_more = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/get_more.js"(exports2, module2) {
    "use strict";
    var GetMore = require_commands().GetMore;
    var retrieveBSON = require_utils4().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils3().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    function getMore(server, ns, cursorState, batchSize, options, callback) {
      options = options || {};
      const wireVersion = maxWireVersion(server);
      function queryCallback(err, result) {
        if (err)
          return callback(err);
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (wireVersion < 4) {
          const cursorId3 = typeof response.cursorId === "number" ? Long2.fromNumber(response.cursorId) : response.cursorId;
          cursorState.documents = response.documents;
          cursorState.cursorId = cursorId3;
          callback(null, null, response.connection);
          return;
        }
        if (response.documents[0].ok === 0) {
          return callback(new MongoError(response.documents[0]));
        }
        const cursorId2 = typeof response.documents[0].cursor.id === "number" ? Long2.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;
        cursorState.documents = response.documents[0].cursor.nextBatch;
        cursorState.cursorId = cursorId2;
        callback(null, response.documents[0], response.connection);
      }
      if (wireVersion < 4) {
        const bson = server.s.bson;
        const getMoreOp = new GetMore(bson, ns, cursorState.cursorId, { numberToReturn: batchSize });
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        server.s.pool.write(getMoreOp, queryOptions, queryCallback);
        return;
      }
      const cursorId = cursorState.cursorId instanceof Long2 ? cursorState.cursorId : Long2.fromNumber(cursorState.cursorId);
      const getMoreCmd = {
        getMore: cursorId,
        collection: collectionNamespace(ns),
        batchSize: Math.abs(batchSize)
      };
      if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
      }
      const commandOptions = Object.assign(
        {
          returnFieldSelector: null,
          documentsReturnedIn: "nextBatch"
        },
        options
      );
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, getMoreCmd, commandOptions, queryCallback);
    }
    module2.exports = getMore;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/query.js
var require_query = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/query.js"(exports2, module2) {
    "use strict";
    var Query = require_commands().Query;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var collectionNamespace = require_shared().collectionNamespace;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils3().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    var decorateWithExplain = require_utils().decorateWithExplain;
    var Explain = require_explain().Explain;
    function query(server, ns, cmd, cursorState, options, callback) {
      options = options || {};
      if (cursorState.cursorId != null) {
        return callback();
      }
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (maxWireVersion(server) < 4) {
        const query2 = prepareLegacyFindQuery(server, ns, cmd, cursorState, options);
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        if (typeof query2.documentsReturnedIn === "string") {
          queryOptions.documentsReturnedIn = query2.documentsReturnedIn;
        }
        server.s.pool.write(query2, queryOptions, callback);
        return;
      }
      const readPreference = getReadPreference(cmd, options);
      let findCmd = prepareFindCommand(server, ns, cmd, cursorState, options);
      try {
        const explain = Explain.fromOptions(options);
        if (explain) {
          findCmd = decorateWithExplain(findCmd, explain);
        }
      } catch (err) {
        return callback(err);
      }
      cmd.virtual = false;
      const commandOptions = Object.assign(
        {
          documentsReturnedIn: "firstBatch",
          numberToReturn: 1,
          slaveOk: readPreference.slaveOk()
        },
        options
      );
      if (cmd.readPreference) {
        commandOptions.readPreference = readPreference;
      }
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, findCmd, commandOptions, callback);
    }
    function prepareFindCommand(server, ns, cmd, cursorState) {
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      const findCmd = {
        find: collectionNamespace(ns)
      };
      if (cmd.query) {
        if (cmd.query["$query"]) {
          findCmd.filter = cmd.query["$query"];
        } else {
          findCmd.filter = cmd.query;
        }
      }
      let sortValue = cmd.sort;
      if (Array.isArray(sortValue)) {
        const sortObject = {};
        if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {
          let sortDirection = sortValue[1];
          if (sortDirection === "asc") {
            sortDirection = 1;
          } else if (sortDirection === "desc") {
            sortDirection = -1;
          }
          sortObject[sortValue[0]] = sortDirection;
        } else {
          for (let i = 0; i < sortValue.length; i++) {
            let sortDirection = sortValue[i][1];
            if (sortDirection === "asc") {
              sortDirection = 1;
            } else if (sortDirection === "desc") {
              sortDirection = -1;
            }
            sortObject[sortValue[i][0]] = sortDirection;
          }
        }
        sortValue = sortObject;
      }
      if (typeof cmd.allowDiskUse === "boolean") {
        findCmd.allowDiskUse = cmd.allowDiskUse;
      }
      if (cmd.sort)
        findCmd.sort = sortValue;
      if (cmd.fields)
        findCmd.projection = cmd.fields;
      if (cmd.hint)
        findCmd.hint = cmd.hint;
      if (cmd.skip)
        findCmd.skip = cmd.skip;
      if (cmd.limit)
        findCmd.limit = cmd.limit;
      if (cmd.limit < 0) {
        findCmd.limit = Math.abs(cmd.limit);
        findCmd.singleBatch = true;
      }
      if (typeof cmd.batchSize === "number") {
        if (cmd.batchSize < 0) {
          if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {
            findCmd.limit = Math.abs(cmd.batchSize);
          }
          findCmd.singleBatch = true;
        }
        findCmd.batchSize = Math.abs(cmd.batchSize);
      }
      if (cmd.comment)
        findCmd.comment = cmd.comment;
      if (cmd.maxScan)
        findCmd.maxScan = cmd.maxScan;
      if (cmd.maxTimeMS)
        findCmd.maxTimeMS = cmd.maxTimeMS;
      if (cmd.min)
        findCmd.min = cmd.min;
      if (cmd.max)
        findCmd.max = cmd.max;
      if (typeof cmd.returnKey === "boolean")
        findCmd.returnKey = cmd.returnKey;
      if (typeof cmd.showDiskLoc === "boolean")
        findCmd.showRecordId = cmd.showDiskLoc;
      if (cmd.snapshot)
        findCmd.snapshot = cmd.snapshot;
      if (cmd.tailable)
        findCmd.tailable = cmd.tailable;
      if (cmd.oplogReplay)
        findCmd.oplogReplay = cmd.oplogReplay;
      if (cmd.noCursorTimeout)
        findCmd.noCursorTimeout = cmd.noCursorTimeout;
      if (cmd.awaitData)
        findCmd.awaitData = cmd.awaitData;
      if (cmd.awaitdata)
        findCmd.awaitData = cmd.awaitdata;
      if (cmd.partial)
        findCmd.partial = cmd.partial;
      if (cmd.collation)
        findCmd.collation = cmd.collation;
      if (cmd.readConcern)
        findCmd.readConcern = cmd.readConcern;
      return findCmd;
    }
    function prepareLegacyFindQuery(server, ns, cmd, cursorState, options) {
      options = options || {};
      const bson = server.s.bson;
      const readPreference = getReadPreference(cmd, options);
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      let numberToReturn = 0;
      if (cursorState.limit < 0 || cursorState.limit !== 0 && cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize === 0) {
        numberToReturn = cursorState.limit;
      } else {
        numberToReturn = cursorState.batchSize;
      }
      const numberToSkip = cursorState.skip || 0;
      const findCmd = {};
      if (isSharded(server) && readPreference) {
        findCmd["$readPreference"] = readPreference.toJSON();
      }
      if (cmd.sort)
        findCmd["$orderby"] = cmd.sort;
      if (cmd.hint)
        findCmd["$hint"] = cmd.hint;
      if (cmd.snapshot)
        findCmd["$snapshot"] = cmd.snapshot;
      if (typeof cmd.returnKey !== "undefined")
        findCmd["$returnKey"] = cmd.returnKey;
      if (cmd.maxScan)
        findCmd["$maxScan"] = cmd.maxScan;
      if (cmd.min)
        findCmd["$min"] = cmd.min;
      if (cmd.max)
        findCmd["$max"] = cmd.max;
      if (typeof cmd.showDiskLoc !== "undefined")
        findCmd["$showDiskLoc"] = cmd.showDiskLoc;
      if (cmd.comment)
        findCmd["$comment"] = cmd.comment;
      if (cmd.maxTimeMS)
        findCmd["$maxTimeMS"] = cmd.maxTimeMS;
      if (options.explain !== void 0) {
        numberToReturn = -Math.abs(cmd.limit || 0);
        findCmd["$explain"] = true;
      }
      findCmd["$query"] = cmd.query;
      if (cmd.readConcern && cmd.readConcern.level !== "local") {
        throw new MongoError(
          `server find command does not support a readConcern level of ${cmd.readConcern.level}`
        );
      }
      if (cmd.readConcern) {
        cmd = Object.assign({}, cmd);
        delete cmd["readConcern"];
      }
      const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      const query2 = new Query(bson, ns, findCmd, {
        numberToSkip,
        numberToReturn,
        pre32Limit: typeof cmd.limit !== "undefined" ? cmd.limit : void 0,
        checkKeys: false,
        returnFieldSelector: cmd.fields,
        serializeFunctions,
        ignoreUndefined
      });
      if (typeof cmd.tailable === "boolean")
        query2.tailable = cmd.tailable;
      if (typeof cmd.oplogReplay === "boolean")
        query2.oplogReplay = cmd.oplogReplay;
      if (typeof cmd.noCursorTimeout === "boolean")
        query2.noCursorTimeout = cmd.noCursorTimeout;
      if (typeof cmd.awaitData === "boolean")
        query2.awaitData = cmd.awaitData;
      if (typeof cmd.partial === "boolean")
        query2.partial = cmd.partial;
      query2.slaveOk = readPreference.slaveOk();
      return query2;
    }
    module2.exports = query;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/index.js
var require_wireprotocol = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/index.js"(exports2, module2) {
    "use strict";
    var writeCommand = require_write_command();
    module2.exports = {
      insert: function insert(server, ns, ops, options, callback) {
        writeCommand(server, "insert", "documents", ns, ops, options, callback);
      },
      update: function update(server, ns, ops, options, callback) {
        writeCommand(server, "update", "updates", ns, ops, options, callback);
      },
      remove: function remove(server, ns, ops, options, callback) {
        writeCommand(server, "delete", "deletes", ns, ops, options, callback);
      },
      killCursors: require_kill_cursors(),
      getMore: require_get_more(),
      query: require_query(),
      command: require_command()
    };
  }
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS({
  "node_modules/mongodb/lib/operations/operation.js"(exports2, module2) {
    "use strict";
    var Explain = require_explain().Explain;
    var MongoError = require_error().MongoError;
    var Aspect = {
      READ_OPERATION: Symbol("READ_OPERATION"),
      WRITE_OPERATION: Symbol("WRITE_OPERATION"),
      RETRYABLE: Symbol("RETRYABLE"),
      EXECUTE_WITH_SELECTION: Symbol("EXECUTE_WITH_SELECTION"),
      NO_INHERIT_OPTIONS: Symbol("NO_INHERIT_OPTIONS"),
      EXPLAINABLE: Symbol("EXPLAINABLE")
    };
    var OperationBase = class {
      constructor(options) {
        this.options = Object.assign({}, options);
        if (this.hasAspect(Aspect.EXPLAINABLE)) {
          this.explain = Explain.fromOptions(options);
        } else if (this.options.explain !== void 0) {
          throw new MongoError(`explain is not supported on this command`);
        }
      }
      hasAspect(aspect) {
        if (this.constructor.aspects == null) {
          return false;
        }
        return this.constructor.aspects.has(aspect);
      }
      set session(session) {
        Object.assign(this.options, { session });
      }
      get session() {
        return this.options.session;
      }
      clearSession() {
        delete this.options.session;
      }
      get canRetryRead() {
        return true;
      }
      execute() {
        throw new TypeError("`execute` must be implemented for OperationBase subclasses");
      }
    };
    function defineAspects(operation, aspects) {
      if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
      }
      aspects = new Set(aspects);
      Object.defineProperty(operation, "aspects", {
        value: aspects,
        writable: false
      });
      return aspects;
    }
    module2.exports = {
      Aspect,
      defineAspects,
      OperationBase
    };
  }
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS({
  "node_modules/mongodb/lib/operations/execute_operation.js"(exports2, module2) {
    "use strict";
    var maybePromise = require_utils().maybePromise;
    var MongoError = require_error().MongoError;
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_read_preference();
    var isRetryableError = require_error().isRetryableError;
    var maxWireVersion = require_utils3().maxWireVersion;
    var isUnifiedTopology = require_utils3().isUnifiedTopology;
    function executeOperation(topology, operation, cb) {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!(operation instanceof OperationBase)) {
        throw new TypeError("This method requires a valid operation instance");
      }
      return maybePromise(topology, cb, (callback) => {
        if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {
          return selectServerForSessionSupport(topology, operation, callback);
        }
        let session, owner;
        if (topology.hasSessionSupport()) {
          if (operation.session == null) {
            owner = Symbol();
            session = topology.startSession({ owner });
            operation.session = session;
          } else if (operation.session.hasEnded) {
            return callback(new MongoError("Use of expired sessions is not permitted"));
          }
        } else if (operation.session) {
          return callback(new MongoError("Current topology does not support sessions"));
        }
        function executeCallback(err, result) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(err, result);
        }
        try {
          if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {
            executeWithServerSelection(topology, operation, executeCallback);
          } else {
            operation.execute(executeCallback);
          }
        } catch (error) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(error);
        }
      });
    }
    function supportsRetryableReads(server) {
      return maxWireVersion(server) >= 6;
    }
    function executeWithServerSelection(topology, operation, callback) {
      const readPreference = operation.readPreference || ReadPreference.primary;
      const inTransaction = operation.session && operation.session.inTransaction();
      if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
        callback(
          new MongoError(
            `Read preference in a transaction must be primary, not: ${readPreference.mode}`
          )
        );
        return;
      }
      const serverSelectionOptions = {
        readPreference,
        session: operation.session
      };
      function callbackWithRetry(err, result) {
        if (err == null) {
          return callback(null, result);
        }
        if (!isRetryableError(err)) {
          return callback(err);
        }
        topology.selectServer(serverSelectionOptions, (err2, server) => {
          if (err2 || !supportsRetryableReads(server)) {
            callback(err2, null);
            return;
          }
          operation.execute(server, callback);
        });
      }
      topology.selectServer(serverSelectionOptions, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;
        if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {
          operation.execute(server, callbackWithRetry);
          return;
        }
        operation.execute(server, callback);
      });
    }
    function selectServerForSessionSupport(topology, operation, callback) {
      topology.selectServer(ReadPreference.primaryPreferred, (err) => {
        if (err) {
          return callback(err);
        }
        executeOperation(topology, operation, callback);
      });
    }
    module2.exports = executeOperation;
  }
});

// node_modules/mongodb/lib/core/cursor.js
var require_cursor = __commonJS({
  "node_modules/mongodb/lib/core/cursor.js"(exports2, module2) {
    "use strict";
    var Logger = require_logger();
    var retrieveBSON = require_utils4().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collationNotSupported = require_utils3().collationNotSupported;
    var ReadPreference = require_read_preference();
    var isUnifiedTopology = require_utils3().isUnifiedTopology;
    var executeOperation = require_execute_operation();
    var Readable = __require("stream").Readable;
    var SUPPORTS = require_utils().SUPPORTS;
    var MongoDBNamespace = require_utils().MongoDBNamespace;
    var mergeOptions = require_utils().mergeOptions;
    var OperationBase = require_operation().OperationBase;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var CursorState = {
      INIT: 0,
      OPEN: 1,
      CLOSED: 2,
      GET_MORE: 3
    };
    function handleCallback(callback, err, result) {
      try {
        callback(err, result);
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
      }
    }
    var CoreCursor = class extends Readable {
      /**
       * Create a new core `Cursor` instance.
       * **NOTE** Not to be instantiated directly
       *
       * @param {object} topology The server topology instance.
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {{object}|Long} cmd The selector (can be a command or a cursorId)
       * @param {object} [options=null] Optional settings.
       * @param {object} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/| find command documentation} and {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.
       * @param {array} [options.documents=[]] Initial documents list for cursor
       * @param {object} [options.transforms=null] Transform methods for the cursor results
       * @param {function} [options.transforms.query] Transform the value returned from the initial query
       * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype._next
       */
      constructor(topology, ns, cmd, options) {
        super({ objectMode: true });
        options = options || {};
        if (ns instanceof OperationBase) {
          this.operation = ns;
          ns = this.operation.ns.toString();
          options = this.operation.options;
          cmd = this.operation.cmd ? this.operation.cmd : {};
        }
        this.pool = null;
        this.server = null;
        this.disconnectHandler = options.disconnectHandler;
        this.bson = topology.s.bson;
        this.ns = ns;
        this.namespace = MongoDBNamespace.fromString(ns);
        this.cmd = cmd;
        this.options = options;
        this.topology = topology;
        this.cursorState = {
          cursorId: null,
          cmd,
          documents: options.documents || [],
          cursorIndex: 0,
          dead: false,
          killed: false,
          init: false,
          notified: false,
          limit: options.limit || cmd.limit || 0,
          skip: options.skip || cmd.skip || 0,
          batchSize: options.batchSize || cmd.batchSize || 1e3,
          currentLimit: 0,
          // Result field name if not a cursor (contains the array of results)
          transforms: options.transforms,
          raw: options.raw || cmd && cmd.raw
        };
        if (typeof options.session === "object") {
          this.cursorState.session = options.session;
        }
        const topologyOptions = topology.s.options;
        if (typeof topologyOptions.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = topologyOptions.promoteLongs;
        } else if (typeof options.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = options.promoteLongs;
        }
        if (typeof topologyOptions.promoteValues === "boolean") {
          this.cursorState.promoteValues = topologyOptions.promoteValues;
        } else if (typeof options.promoteValues === "boolean") {
          this.cursorState.promoteValues = options.promoteValues;
        }
        if (typeof topologyOptions.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
        } else if (typeof options.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = options.promoteBuffers;
        }
        if (typeof topologyOptions.bsonRegExp === "boolean") {
          this.cursorState.bsonRegExp = topologyOptions.bsonRegExp;
        } else if (typeof options.bsonRegExp === "boolean") {
          this.cursorState.bsonRegExp = options.bsonRegExp;
        }
        if (topologyOptions.reconnect) {
          this.cursorState.reconnect = topologyOptions.reconnect;
        }
        this.logger = Logger("Cursor", topologyOptions);
        if (typeof cmd === "number") {
          this.cursorState.cursorId = Long2.fromNumber(cmd);
          this.cursorState.lastCursorId = this.cursorState.cursorId;
        } else if (cmd instanceof Long2) {
          this.cursorState.cursorId = cmd;
          this.cursorState.lastCursorId = cmd;
        }
        if (this.operation) {
          this.operation.cursorState = this.cursorState;
        }
      }
      setCursorBatchSize(value2) {
        this.cursorState.batchSize = value2;
      }
      cursorBatchSize() {
        return this.cursorState.batchSize;
      }
      setCursorLimit(value2) {
        this.cursorState.limit = value2;
      }
      cursorLimit() {
        return this.cursorState.limit;
      }
      setCursorSkip(value2) {
        this.cursorState.skip = value2;
      }
      cursorSkip() {
        return this.cursorState.skip;
      }
      /**
       * Retrieve the next document from the cursor
       * @method
       * @param {resultCallback} callback A callback function
       */
      _next(callback) {
        nextFunction(this, callback);
      }
      /**
       * Clone the cursor
       * @method
       * @return {Cursor}
       */
      clone() {
        const clonedOptions = mergeOptions({}, this.options);
        delete clonedOptions.session;
        return this.topology.cursor(this.ns, this.cmd, clonedOptions);
      }
      /**
       * Checks if the cursor is dead
       * @method
       * @return {boolean} A boolean signifying if the cursor is dead or not
       */
      isDead() {
        return this.cursorState.dead === true;
      }
      /**
       * Checks if the cursor was killed by the application
       * @method
       * @return {boolean} A boolean signifying if the cursor was killed by the application
       */
      isKilled() {
        return this.cursorState.killed === true;
      }
      /**
       * Checks if the cursor notified it's caller about it's death
       * @method
       * @return {boolean} A boolean signifying if the cursor notified the callback
       */
      isNotified() {
        return this.cursorState.notified === true;
      }
      /**
       * Returns current buffered documents length
       * @method
       * @return {number} The number of items in the buffered documents
       */
      bufferedCount() {
        return this.cursorState.documents.length - this.cursorState.cursorIndex;
      }
      /**
       * Returns current buffered documents
       * @method
       * @return {Array} An array of buffered documents
       */
      readBufferedDocuments(number) {
        const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
        const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
        let elements = this.cursorState.documents.slice(
          this.cursorState.cursorIndex,
          this.cursorState.cursorIndex + length
        );
        if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === "function") {
          for (let i = 0; i < elements.length; i++) {
            elements[i] = this.cursorState.transforms.doc(elements[i]);
          }
        }
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {
          elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
          this.kill();
        }
        this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
        this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
        return elements;
      }
      /**
       * Resets local state for this cursor instance, and issues a `killCursors` command to the server
       *
       * @param {resultCallback} callback A callback function
       */
      kill(callback) {
        this.cursorState.dead = true;
        this.cursorState.killed = true;
        this.cursorState.documents = [];
        if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {
          if (callback)
            callback(null, null);
          return;
        }
        this.server.killCursors(this.ns, this.cursorState, callback);
      }
      /**
       * Resets the cursor
       */
      rewind() {
        if (this.cursorState.init) {
          if (!this.cursorState.dead) {
            this.kill();
          }
          this.cursorState.currentLimit = 0;
          this.cursorState.init = false;
          this.cursorState.dead = false;
          this.cursorState.killed = false;
          this.cursorState.notified = false;
          this.cursorState.documents = [];
          this.cursorState.cursorId = null;
          this.cursorState.cursorIndex = 0;
        }
      }
      // Internal methods
      _read() {
        if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {
          return this.push(null);
        }
        this._next((err, result) => {
          if (err) {
            if (this.listeners("error") && this.listeners("error").length > 0) {
              this.emit("error", err);
            }
            if (!this.isDead())
              this.close();
            this.emit("end");
            return this.emit("finish");
          }
          if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === "function" && result != null) {
            return this.push(this.cursorState.streamOptions.transform(result));
          }
          this.push(result);
          if (result === null && this.isDead()) {
            this.once("end", () => {
              this.close();
              this.emit("finish");
            });
          }
        });
      }
      _endSession(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const session = this.cursorState.session;
        if (session && (options.force || session.owner === this)) {
          this.cursorState.session = void 0;
          if (this.operation) {
            this.operation.clearSession();
          }
          session.endSession(callback);
          return true;
        }
        if (callback) {
          callback();
        }
        return false;
      }
      _getMore(callback) {
        if (this.logger.isDebug()) {
          this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);
        }
        let batchSize = this.cursorState.batchSize;
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {
          batchSize = this.cursorState.limit - this.cursorState.currentLimit;
        }
        const cursorState = this.cursorState;
        this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            this._endSession();
          }
          callback(err, result, conn);
        });
      }
      _initializeCursor(callback) {
        const cursor = this;
        if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {
          cursor.topology.selectServer(ReadPreference.primaryPreferred, (err) => {
            if (err) {
              callback(err);
              return;
            }
            this._initializeCursor(callback);
          });
          return;
        }
        function done(err, result) {
          const cursorState = cursor.cursorState;
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            cursor._endSession();
          }
          if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {
            return setCursorNotified(cursor, callback);
          }
          callback(err, result);
        }
        const queryCallback = (err, r) => {
          if (err) {
            return done(err);
          }
          const result = r.message;
          if (Array.isArray(result.documents) && result.documents.length === 1) {
            const document = result.documents[0];
            if (result.queryFailure) {
              return done(new MongoError(document), null);
            }
            if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {
              if (document.$err || document.errmsg) {
                return done(new MongoError(document), null);
              }
              if (document.cursor != null && typeof document.cursor !== "string") {
                const id = document.cursor.id;
                if (document.cursor.ns) {
                  cursor.ns = document.cursor.ns;
                }
                cursor.cursorState.cursorId = typeof id === "number" ? Long2.fromNumber(id) : id;
                cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;
                cursor.cursorState.operationTime = document.operationTime;
                if (Array.isArray(document.cursor.firstBatch)) {
                  cursor.cursorState.documents = document.cursor.firstBatch;
                }
                return done(null, result);
              }
            }
          }
          const cursorId = result.cursorId || 0;
          cursor.cursorState.cursorId = cursorId instanceof Long2 ? cursorId : Long2.fromNumber(cursorId);
          cursor.cursorState.documents = result.documents;
          cursor.cursorState.lastCursorId = result.cursorId;
          if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === "function") {
            cursor.cursorState.documents = cursor.cursorState.transforms.query(result);
          }
          done(null, result);
        };
        if (cursor.operation) {
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(
              `issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(
                cursor.query
              )}]`
            );
          }
          executeOperation(cursor.topology, cursor.operation, (err, result) => {
            if (err) {
              done(err);
              return;
            }
            cursor.server = cursor.operation.server;
            cursor.cursorState.init = true;
            if (cursor.cursorState.cursorId != null) {
              return done();
            }
            queryCallback(err, result);
          });
          return;
        }
        const serverSelectOptions = {};
        if (cursor.cursorState.session) {
          serverSelectOptions.session = cursor.cursorState.session;
        }
        if (cursor.operation) {
          serverSelectOptions.readPreference = cursor.operation.readPreference;
        } else if (cursor.options.readPreference) {
          serverSelectOptions.readPreference = cursor.options.readPreference;
        }
        return cursor.topology.selectServer(serverSelectOptions, (err, server) => {
          if (err) {
            const disconnectHandler = cursor.disconnectHandler;
            if (disconnectHandler != null) {
              return disconnectHandler.addObjectAndMethod(
                "cursor",
                cursor,
                "next",
                [callback],
                callback
              );
            }
            return callback(err);
          }
          cursor.server = server;
          cursor.cursorState.init = true;
          if (collationNotSupported(cursor.server, cursor.cmd)) {
            return callback(new MongoError(`server ${cursor.server.name} does not support collation`));
          }
          if (cursor.cursorState.cursorId != null) {
            return done();
          }
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(
              `issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(
                cursor.query
              )}]`
            );
          }
          if (cursor.cmd.find != null) {
            server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);
            return;
          }
          const commandOptions = Object.assign({ session: cursor.cursorState.session }, cursor.options);
          server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);
        });
      }
    };
    if (SUPPORTS.ASYNC_ITERATOR) {
      CoreCursor.prototype[Symbol.asyncIterator] = require_async_iterator().asyncIterator;
    }
    function isConnectionDead(self2, callback) {
      if (self2.pool && self2.pool.isDestroyed()) {
        self2.cursorState.killed = true;
        const err = new MongoNetworkError(
          `connection to host ${self2.pool.host}:${self2.pool.port} was destroyed`
        );
        _setCursorNotifiedImpl(self2, () => callback(err));
        return true;
      }
      return false;
    }
    function isCursorDeadButNotkilled(self2, callback) {
      if (self2.cursorState.dead && !self2.cursorState.killed) {
        self2.cursorState.killed = true;
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function isCursorDeadAndKilled(self2, callback) {
      if (self2.cursorState.dead && self2.cursorState.killed) {
        handleCallback(callback, new MongoError("cursor is dead"));
        return true;
      }
      return false;
    }
    function isCursorKilled(self2, callback) {
      if (self2.cursorState.killed) {
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function setCursorDeadAndNotified(self2, callback) {
      self2.cursorState.dead = true;
      setCursorNotified(self2, callback);
    }
    function setCursorNotified(self2, callback) {
      _setCursorNotifiedImpl(self2, () => handleCallback(callback, null, null));
    }
    function _setCursorNotifiedImpl(self2, callback) {
      self2.cursorState.notified = true;
      self2.cursorState.documents = [];
      self2.cursorState.cursorIndex = 0;
      if (self2.cursorState.session) {
        self2._endSession(callback);
        return;
      }
      return callback();
    }
    function nextFunction(self2, callback) {
      if (self2.cursorState.notified) {
        return callback(new Error("cursor is exhausted"));
      }
      if (isCursorKilled(self2, callback))
        return;
      if (isCursorDeadButNotkilled(self2, callback))
        return;
      if (isCursorDeadAndKilled(self2, callback))
        return;
      if (!self2.cursorState.init) {
        if (!self2.topology.isConnected(self2.options)) {
          if (self2.topology._type === "server" && !self2.topology.s.options.reconnect) {
            return callback(new MongoError("no connection available"));
          }
          if (self2.disconnectHandler != null) {
            if (self2.topology.isDestroyed()) {
              return callback(new MongoError("Topology was destroyed"));
            }
            self2.disconnectHandler.addObjectAndMethod("cursor", self2, "next", [callback], callback);
            return;
          }
        }
        self2._initializeCursor((err, result) => {
          if (err || result === null) {
            callback(err, result);
            return;
          }
          nextFunction(self2, callback);
        });
        return;
      }
      if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
        self2.kill(
          () => (
            // Set cursor in dead and notified state
            setCursorDeadAndNotified(self2, callback)
          )
        );
      } else if (self2.cursorState.cursorIndex === self2.cursorState.documents.length && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
        self2.cursorState.documents = [];
        self2.cursorState.cursorIndex = 0;
        if (self2.topology.isDestroyed())
          return callback(
            new MongoNetworkError("connection destroyed, not possible to instantiate cursor")
          );
        if (isConnectionDead(self2, callback))
          return;
        self2._getMore(function(err, doc, connection) {
          if (err) {
            return handleCallback(callback, err);
          }
          self2.connection = connection;
          if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return handleCallback(
              callback,
              new MongoError({
                message: "No more documents in tailed cursor",
                tailable: self2.cmd.tailable,
                awaitData: self2.cmd.awaitData
              })
            );
          } else if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return nextFunction(self2, callback);
          }
          if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
            return setCursorDeadAndNotified(self2, callback);
          }
          nextFunction(self2, callback);
        });
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        return handleCallback(
          callback,
          new MongoError({
            message: "No more documents in tailed cursor",
            tailable: self2.cmd.tailable,
            awaitData: self2.cmd.awaitData
          })
        );
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        setCursorDeadAndNotified(self2, callback);
      } else {
        if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
          self2.kill(
            () => (
              // Set cursor in dead and notified state
              setCursorDeadAndNotified(self2, callback)
            )
          );
          return;
        }
        self2.cursorState.currentLimit += 1;
        let doc = self2.cursorState.documents[self2.cursorState.cursorIndex++];
        if (!doc || doc.$err) {
          self2.kill(
            () => (
              // Set cursor in dead and notified state
              setCursorDeadAndNotified(self2, function() {
                handleCallback(callback, new MongoError(doc ? doc.$err : void 0));
              })
            )
          );
          return;
        }
        if (self2.cursorState.transforms && typeof self2.cursorState.transforms.doc === "function") {
          doc = self2.cursorState.transforms.doc(doc);
        }
        handleCallback(callback, null, doc);
      }
    }
    module2.exports = {
      CursorState,
      CoreCursor
    };
  }
});

// node_modules/mongodb/lib/core/topologies/server.js
var require_server = __commonJS({
  "node_modules/mongodb/lib/core/topologies/server.js"(exports2, module2) {
    "use strict";
    var inherits = __require("util").inherits;
    var f = __require("util").format;
    var EventEmitter = __require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var Logger = require_logger();
    var debugOptions = require_utils4().debugOptions;
    var retrieveBSON = require_utils4().retrieveBSON;
    var Pool = require_pool();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var wireProtocol = require_wireprotocol();
    var CoreCursor = require_cursor().CoreCursor;
    var sdam = require_shared2();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SessionMixins = require_shared2().SessionMixins;
    var extractCommand = require_command_utils().extractCommand;
    var relayEvents = require_utils3().relayEvents;
    var collationNotSupported = require_utils3().collationNotSupported;
    var makeClientMetadata = require_utils3().makeClientMetadata;
    var debugFields = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "servername"
    ];
    var id = 0;
    var serverAccounting = false;
    var servers = {};
    var BSON2 = retrieveBSON();
    function topologyId(server) {
      return server.s.parent == null ? server.id : server.s.parent.id;
    }
    var Server = function(options) {
      options = options || {};
      EventEmitter.call(this);
      this.id = id++;
      this.s = {
        // Options
        options: Object.assign({ metadata: makeClientMetadata(options) }, options),
        // Logger
        logger: Logger("Server", options),
        // Factory overrides
        Cursor: options.cursorFactory || CoreCursor,
        // BSON instance
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        // Pool
        pool: null,
        // Disconnect handler
        disconnectHandler: options.disconnectHandler,
        // Monitor thread (keeps the connection alive)
        monitoring: typeof options.monitoring === "boolean" ? options.monitoring : true,
        // Is the server in a topology
        inTopology: !!options.parent,
        // Monitoring timeout
        monitoringInterval: typeof options.monitoringInterval === "number" ? options.monitoringInterval : 5e3,
        compression: { compressors: createCompressionInfo(options) },
        // Optional parent topology
        parent: options.parent
      };
      if (!this.s.parent) {
        this.s.clusterTime = null;
      }
      this.ismaster = null;
      this.lastIsMasterMS = -1;
      this.monitoringProcessId = null;
      this.initialConnect = true;
      this._type = "server";
      this.lastUpdateTime = 0;
      this.lastWriteDate = 0;
      this.staleness = 0;
    };
    inherits(Server, EventEmitter);
    Object.assign(Server.prototype, SessionMixins);
    Object.defineProperty(Server.prototype, "type", {
      enumerable: true,
      get: function() {
        return this._type;
      }
    });
    Object.defineProperty(Server.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Server.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    Object.defineProperty(Server.prototype, "clientMetadata", {
      enumerable: true,
      get: function() {
        return this.s.options.metadata;
      }
    });
    Object.defineProperty(Server.prototype, "clusterTime", {
      enumerable: true,
      set: function(clusterTime) {
        const settings = this.s.parent ? this.s.parent : this.s;
        resolveClusterTime(settings, clusterTime);
      },
      get: function() {
        const settings = this.s.parent ? this.s.parent : this.s;
        return settings.clusterTime || null;
      }
    });
    Server.enableServerAccounting = function() {
      serverAccounting = true;
      servers = {};
    };
    Server.disableServerAccounting = function() {
      serverAccounting = false;
    };
    Server.servers = function() {
      return servers;
    };
    Object.defineProperty(Server.prototype, "name", {
      enumerable: true,
      get: function() {
        return this.s.options.host + ":" + this.s.options.port;
      }
    });
    function disconnectHandler(self2, type, ns, cmd, options, callback) {
      if (!self2.s.pool.isConnected() && self2.s.options.reconnect && self2.s.disconnectHandler != null && !options.monitoring) {
        self2.s.disconnectHandler.add(type, ns, cmd, options, callback);
        return true;
      }
      if (!self2.s.pool.isConnected()) {
        callback(new MongoError(f("no connection available to server %s", self2.name)));
        return true;
      }
    }
    function monitoringProcess(self2) {
      return function() {
        if (self2.s.pool.isDestroyed())
          return;
        self2.emit("monitoring", self2);
        var start = (/* @__PURE__ */ new Date()).getTime();
        self2.command(
          "admin.$cmd",
          { ismaster: true },
          {
            socketTimeout: typeof self2.s.options.connectionTimeout !== "number" ? 2e3 : self2.s.options.connectionTimeout,
            monitoring: true
          },
          (err, result) => {
            self2.lastIsMasterMS = (/* @__PURE__ */ new Date()).getTime() - start;
            if (self2.s.pool.isDestroyed())
              return;
            if (result) {
              self2.ismaster = result.result;
            }
            self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
          }
        );
      };
    }
    var eventHandler = function(self2, event) {
      return function(err, conn) {
        if (self2.s.logger.isInfo()) {
          var object2 = err instanceof MongoError ? JSON.stringify(err) : {};
          self2.s.logger.info(
            f("server %s fired event %s out with message %s", self2.name, event, object2)
          );
        }
        if (event === "connect") {
          self2.initialConnect = false;
          self2.ismaster = conn.ismaster;
          self2.lastIsMasterMS = conn.lastIsMasterMS;
          if (conn.agreedCompressor) {
            self2.s.pool.options.agreedCompressor = conn.agreedCompressor;
          }
          if (conn.zlibCompressionLevel) {
            self2.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
          }
          if (conn.ismaster.$clusterTime) {
            const $clusterTime = conn.ismaster.$clusterTime;
            self2.clusterTime = $clusterTime;
          }
          if (self2.ismaster.msg === "isdbgrid") {
            self2._type = "mongos";
          }
          if (self2.s.monitoring) {
            self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
          }
          sdam.emitServerDescriptionChanged(self2, {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: sdam.getTopologyType(self2)
          });
          if (!self2.s.inTopology) {
            sdam.emitTopologyDescriptionChanged(self2, {
              topologyType: "Single",
              servers: [
                {
                  address: self2.name,
                  arbiters: [],
                  hosts: [],
                  passives: [],
                  type: sdam.getTopologyType(self2)
                }
              ]
            });
          }
          if (self2.s.logger.isInfo()) {
            self2.s.logger.info(
              f("server %s connected with ismaster [%s]", self2.name, JSON.stringify(self2.ismaster))
            );
          }
          self2.emit("connect", self2);
        } else if (event === "error" || event === "parseError" || event === "close" || event === "timeout" || event === "reconnect" || event === "attemptReconnect" || event === "reconnectFailed") {
          if (serverAccounting && ["close", "timeout", "error", "parseError", "reconnectFailed"].indexOf(event) !== -1) {
            if (!self2.s.inTopology) {
              self2.emit("topologyOpening", { topologyId: self2.id });
            }
            delete servers[self2.id];
          }
          if (event === "close") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            });
          }
          if (event === "reconnectFailed") {
            self2.emit("reconnectFailed", err);
            if (self2.listeners("error").length > 0) {
              self2.emit("error", err);
            }
            return;
          }
          if (["disconnected", "connecting"].indexOf(self2.s.pool.state) !== -1 && self2.initialConnect && ["close", "timeout", "error", "parseError"].indexOf(event) !== -1) {
            self2.initialConnect = false;
            return self2.emit(
              "error",
              new MongoNetworkError(
                f("failed to connect to server [%s] on first connect [%s]", self2.name, err)
              )
            );
          }
          if (event === "reconnect") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: sdam.getTopologyType(self2)
            });
            return self2.emit(event, self2);
          }
          self2.emit(event, err);
        }
      };
    };
    Server.prototype.connect = function(options) {
      var self2 = this;
      options = options || {};
      if (serverAccounting)
        servers[this.id] = this;
      if (self2.s.pool && !self2.s.pool.isDisconnected() && !self2.s.pool.isDestroyed()) {
        throw new MongoError(f("server instance in invalid state %s", self2.s.pool.state));
      }
      self2.s.pool = new Pool(this, Object.assign(self2.s.options, options, { bson: this.s.bson }));
      self2.s.pool.on("close", eventHandler(self2, "close"));
      self2.s.pool.on("error", eventHandler(self2, "error"));
      self2.s.pool.on("timeout", eventHandler(self2, "timeout"));
      self2.s.pool.on("parseError", eventHandler(self2, "parseError"));
      self2.s.pool.on("connect", eventHandler(self2, "connect"));
      self2.s.pool.on("reconnect", eventHandler(self2, "reconnect"));
      self2.s.pool.on("reconnectFailed", eventHandler(self2, "reconnectFailed"));
      relayEvents(self2.s.pool, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
      if (!self2.s.inTopology) {
        this.emit("topologyOpening", { topologyId: topologyId(self2) });
      }
      self2.emit("serverOpening", { topologyId: topologyId(self2), address: self2.name });
      self2.s.pool.connect();
    };
    Server.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Server.prototype.getDescription = function() {
      var ismaster = this.ismaster || {};
      var description = {
        type: sdam.getTopologyType(this),
        address: this.name
      };
      if (ismaster.hosts)
        description.hosts = ismaster.hosts;
      if (ismaster.arbiters)
        description.arbiters = ismaster.arbiters;
      if (ismaster.passives)
        description.passives = ismaster.passives;
      if (ismaster.setName)
        description.setName = ismaster.setName;
      return description;
    };
    Server.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Server.prototype.unref = function() {
      this.s.pool.unref();
    };
    Server.prototype.isConnected = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isConnected();
    };
    Server.prototype.isDestroyed = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isDestroyed();
    };
    function basicWriteValidations(self2) {
      if (!self2.s.pool)
        return new MongoError("server instance is not connected");
      if (self2.s.pool.isDestroyed())
        return new MongoError("server instance pool was destroyed");
    }
    function basicReadValidations(self2, options) {
      basicWriteValidations(self2, options);
      if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
        throw new Error("readPreference must be an instance of ReadPreference");
      }
    }
    Server.prototype.command = function(ns, cmd, options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      var result = basicReadValidations(self2, options);
      if (result)
        return callback(result);
      options = Object.assign({}, options, { wireProtocolCommand: false });
      if (self2.s.logger.isDebug()) {
        const extractedCommand = extractCommand(cmd);
        self2.s.logger.debug(
          f(
            "executing command [%s] against %s",
            JSON.stringify({
              ns,
              cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,
              options: debugOptions(debugFields, options)
            }),
            self2.name
          )
        );
      }
      if (disconnectHandler(self2, "command", ns, cmd, options, callback))
        return;
      if (collationNotSupported(this, cmd)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      wireProtocol.command(self2, ns, cmd, options, callback);
    };
    Server.prototype.query = function(ns, cmd, cursorState, options, callback) {
      wireProtocol.query(this, ns, cmd, cursorState, options, callback);
    };
    Server.prototype.getMore = function(ns, cursorState, batchSize, options, callback) {
      wireProtocol.getMore(this, ns, cursorState, batchSize, options, callback);
    };
    Server.prototype.killCursors = function(ns, cursorState, callback) {
      wireProtocol.killCursors(this, ns, cursorState, callback);
    };
    Server.prototype.insert = function(ns, ops, options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      var result = basicWriteValidations(self2, options);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "insert", ns, ops, options, callback))
        return;
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.insert(self2, ns, ops, options, callback);
    };
    Server.prototype.update = function(ns, ops, options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      var result = basicWriteValidations(self2, options);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "update", ns, ops, options, callback))
        return;
      if (collationNotSupported(this, options)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.update(self2, ns, ops, options, callback);
    };
    Server.prototype.remove = function(ns, ops, options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      var result = basicWriteValidations(self2, options);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "remove", ns, ops, options, callback))
        return;
      if (collationNotSupported(this, options)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.remove(self2, ns, ops, options, callback);
    };
    Server.prototype.cursor = function(ns, cmd, options) {
      options = options || {};
      const topology = options.topology || this;
      var FinalCursor = options.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options);
    };
    Server.prototype.equals = function(server) {
      if (typeof server === "string")
        return this.name.toLowerCase() === server.toLowerCase();
      if (server.name)
        return this.name.toLowerCase() === server.name.toLowerCase();
      return false;
    };
    Server.prototype.connections = function() {
      return this.s.pool.allConnections();
    };
    Server.prototype.selectServer = function(selector, options, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options = {};
      if (typeof options === "function")
        callback = options, options = selector, selector = void 0;
      callback(null, this);
    };
    var listeners = ["close", "error", "timeout", "parseError", "connect"];
    Server.prototype.destroy = function(options, callback) {
      if (this._destroyed) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var self2 = this;
      if (serverAccounting)
        delete servers[this.id];
      if (this.monitoringProcessId) {
        clearTimeout(this.monitoringProcessId);
      }
      if (!self2.s.pool || this._destroyed) {
        this._destroyed = true;
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      this._destroyed = true;
      if (options.emitClose) {
        self2.emit("close", self2);
      }
      if (options.emitDestroy) {
        self2.emit("destroy", self2);
      }
      listeners.forEach(function(event) {
        self2.s.pool.removeAllListeners(event);
      });
      if (self2.listeners("serverClosed").length > 0)
        self2.emit("serverClosed", { topologyId: topologyId(self2), address: self2.name });
      if (self2.listeners("topologyClosed").length > 0 && !self2.s.inTopology) {
        self2.emit("topologyClosed", { topologyId: topologyId(self2) });
      }
      if (self2.s.logger.isDebug()) {
        self2.s.logger.debug(f("destroy called on server %s", self2.name));
      }
      this.s.pool.destroy(options.force, callback);
    };
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/core/topologies/replset_state.js
var require_replset_state = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset_state.js"(exports2, module2) {
    "use strict";
    var inherits = __require("util").inherits;
    var f = __require("util").format;
    var diff = require_shared2().diff;
    var EventEmitter = __require("events").EventEmitter;
    var Logger = require_logger();
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var Buffer2 = require_safe_buffer().Buffer;
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    var ReplSetState = function(options) {
      options = options || {};
      EventEmitter.call(this);
      this.topologyType = options.setName ? TopologyType.ReplicaSetNoPrimary : TopologyType.Unknown;
      this.setName = options.setName;
      this.set = {};
      this.id = options.id;
      this.setName = options.setName;
      this.logger = options.logger || Logger("ReplSet", options);
      this.index = 0;
      this.acceptableLatency = options.acceptableLatency || 15;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 1e4;
      this.primary = null;
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
      this.maxElectionId = null;
      this.maxSetVersion = 0;
      this.replicasetDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.logicalSessionTimeoutMinutes = void 0;
    };
    inherits(ReplSetState, EventEmitter);
    ReplSetState.prototype.hasPrimaryAndSecondary = function() {
      return this.primary != null && this.secondaries.length > 0;
    };
    ReplSetState.prototype.hasPrimaryOrSecondary = function() {
      return this.hasPrimary() || this.hasSecondary();
    };
    ReplSetState.prototype.hasPrimary = function() {
      return this.primary != null;
    };
    ReplSetState.prototype.hasSecondary = function() {
      return this.secondaries.length > 0;
    };
    ReplSetState.prototype.get = function(host) {
      var servers = this.allServers();
      for (var i = 0; i < servers.length; i++) {
        if (servers[i].name.toLowerCase() === host.toLowerCase()) {
          return servers[i];
        }
      }
      return null;
    };
    ReplSetState.prototype.allServers = function(options) {
      options = options || {};
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      if (!options.ignoreArbiters)
        servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      return servers;
    };
    ReplSetState.prototype.destroy = function(options, callback) {
      const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);
      if (this.primary)
        serversToDestroy.push(this.primary);
      let serverCount = serversToDestroy.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        this.secondaries = [];
        this.arbiters = [];
        this.passives = [];
        this.ghosts = [];
        this.unknownServers = [];
        this.set = {};
        this.primary = null;
        emitTopologyDescriptionChanged(this);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      serversToDestroy.forEach((server) => server.destroy(options, serverDestroyed));
    };
    ReplSetState.prototype.remove = function(server, options) {
      options = options || {};
      var serverName = server.name.toLowerCase();
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      for (var i = 0; i < servers.length; i++) {
        if (!options.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {
          return;
        }
      }
      if (this.set[serverName]) {
        this.set[serverName].type = ServerType.Unknown;
        this.set[serverName].electionId = null;
        this.set[serverName].setName = null;
        this.set[serverName].setVersion = null;
      }
      var removeType = null;
      if (this.primary && this.primary.equals(server)) {
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        removeType = "primary";
      }
      removeType = removeFrom(server, this.secondaries) ? "secondary" : removeType;
      removeType = removeFrom(server, this.arbiters) ? "arbiter" : removeType;
      removeType = removeFrom(server, this.passives) ? "secondary" : removeType;
      removeFrom(server, this.ghosts);
      removeFrom(server, this.unknownServers);
      this.unknownServers.push(serverName);
      if (removeType) {
        this.emit("left", removeType, server);
      }
    };
    var isArbiter = (ismaster) => ismaster.arbiterOnly && ismaster.setName;
    ReplSetState.prototype.update = function(server) {
      var self2 = this;
      const ismaster = server.lastIsMaster();
      if (ismaster && ismaster.isWritablePrimary)
        ismaster.ismaster = ismaster.isWritablePrimary;
      var serverName = server.name.toLowerCase();
      if (ismaster) {
        var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
        hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
        hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
        hosts = hosts.map(function(s) {
          return s.toLowerCase();
        });
        for (var i = 0; i < hosts.length; i++) {
          if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {
            this.unknownServers.push(hosts[i].toLowerCase());
          }
          if (!this.set[hosts[i]]) {
            this.set[hosts[i]] = {
              type: ServerType.Unknown,
              electionId: null,
              setName: null,
              setVersion: null
            };
          }
        }
      }
      if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
        self2.set[serverName] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.set[serverName].type = ServerType.Unknown;
        self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
        self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
        self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
        if (self2.unknownServers.indexOf(server.name) === -1) {
          self2.unknownServers.push(serverName);
        }
        return false;
      }
      if (ismaster.logicalSessionTimeoutMinutes !== void 0 && !isArbiter(ismaster)) {
        if (self2.logicalSessionTimeoutMinutes === void 0 || ismaster.logicalSessionTimeoutMinutes === null) {
          self2.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;
        } else {
          self2.logicalSessionTimeoutMinutes = Math.min(
            self2.logicalSessionTimeoutMinutes,
            ismaster.logicalSessionTimeoutMinutes
          );
        }
      }
      if (ismaster && ismaster.msg === "isdbgrid") {
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        return false;
      }
      if (ismaster.isreplicaset) {
        self2.set[serverName] = {
          type: ServerType.RSGhost,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
        }
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {
        self2.set[serverName] = {
          type: ServerType.RSOther,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster && ismaster.ismaster && !ismaster.setName) {
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {
        if (this.logger.isWarn()) {
          this.logger.warn(
            f(
              "the seedlist server was removed due to its address %s not matching its ismaster.me address %s",
              server.name,
              ismaster.me
            )
          );
        }
        delete this.set[serverName];
        removeFrom(server, self2.unknownServers);
        server.destroy({ force: true });
        if (this.primary && !this.primary.equals(server)) {
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        if (!this.primary && ismaster.primary) {
          this.set[ismaster.primary.toLowerCase()] = {
            type: ServerType.PossiblePrimary,
            setName: null,
            electionId: null,
            setVersion: null
          };
        }
        return false;
      }
      if (!this.primary && ismaster.ismaster && ismaster.setName) {
        var ismasterElectionId = server.lastIsMaster().electionId;
        if (this.setName && this.setName !== ismaster.setName) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return new MongoError(
            f(
              "setName from ismaster does not match provided connection setName [%s] != [%s]",
              ismaster.setName,
              this.setName
            )
          );
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          var ismasterSetVersion = server.lastIsMaster().setVersion;
          if (result === 1) {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
            return false;
          } else if (result === 0 && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              this.topologyType = TopologyType.ReplicaSetNoPrimary;
              return false;
            }
          }
          this.maxSetVersion = ismasterSetVersion;
          this.maxElectionId = ismasterElectionId;
        }
        var normalizedHosts = ismaster.hosts.map(function(x) {
          return x.toLowerCase();
        });
        var locationIndex = normalizedHosts.indexOf(serverName);
        if (locationIndex !== -1) {
          self2.primary = server;
          self2.set[serverName] = {
            type: ServerType.RSPrimary,
            setVersion: ismaster.setVersion,
            electionId: ismaster.electionId,
            setName: ismaster.setName
          };
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
          if (ismaster.setName)
            this.setName = ismaster.setName;
          removeFrom(server, self2.unknownServers);
          removeFrom(server, self2.secondaries);
          removeFrom(server, self2.passives);
          self2.emit("joined", "primary", server);
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        emitTopologyDescriptionChanged(self2);
        return true;
      } else if (ismaster.ismaster && ismaster.setName) {
        var currentElectionId = self2.set[self2.primary.name.toLowerCase()].electionId;
        var currentSetVersion = self2.set[self2.primary.name.toLowerCase()].setVersion;
        var currentSetName = self2.set[self2.primary.name.toLowerCase()].setName;
        ismasterElectionId = server.lastIsMaster().electionId;
        ismasterSetVersion = server.lastIsMaster().setVersion;
        var ismasterSetName = server.lastIsMaster().setName;
        if (this.primary.equals(server) && currentSetName === ismasterSetName) {
          return false;
        }
        if (currentSetName && currentSetName !== ismasterSetName) {
          if (!this.primary.equals(server)) {
            this.topologyType = TopologyType.ReplicaSetWithPrimary;
          } else {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
          }
          return false;
        }
        if (currentElectionId && ismasterElectionId) {
          result = compareObjectIds(currentElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion > ismasterSetVersion) {
            return false;
          }
        } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          } else {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          }
          this.maxElectionId = ismasterElectionId;
          this.maxSetVersion = ismasterSetVersion;
        } else {
          this.maxSetVersion = ismasterSetVersion;
        }
        self2.set[self2.primary.name.toLowerCase()] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.emit("left", "primary", this.primary);
        self2.primary.destroy({ force: true });
        self2.primary = server;
        self2.set[serverName] = {
          type: ServerType.RSPrimary,
          setVersion: ismaster.setVersion,
          electionId: ismaster.electionId,
          setName: ismaster.setName
        };
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        removeFrom(server, self2.secondaries);
        removeFrom(server, self2.passives);
        self2.emit("joined", "primary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (!this.primary && ismaster.primary) {
        self2.set[ismaster.primary.toLowerCase()] = {
          type: ServerType.PossiblePrimary,
          setVersion: null,
          electionId: null,
          setName: null
        };
      }
      if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.secondaries);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({ force: true });
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSArbiter, ismaster, server, this.arbiters);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        self2.emit("joined", "arbiter", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.passives);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({ force: true });
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {
        self2.emit("left", "primary", this.primary);
        this.primary.destroy({ force: true });
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return false;
      }
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      return false;
    };
    ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
      var max = 0;
      for (var i = 0; i < this.secondaries.length; i++) {
        max = Math.max(max, this.secondaries[i].lastWriteDate);
      }
      if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
        server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;
      } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
        server.staleness = max - server.lastWriteDate + haInterval;
      }
    };
    ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
      for (var i = 0; i < this.secondaries.length; i++) {
        this.updateServerMaxStaleness(this.secondaries[i], haInterval);
      }
    };
    ReplSetState.prototype.pickServer = function(readPreference) {
      readPreference = readPreference || ReadPreference.primary;
      if (readPreference.preference === "primary" && readPreference.maxStalenessSeconds != null) {
        return new MongoError("primary readPreference incompatible with maxStalenessSeconds");
      }
      var allservers = this.primary ? [this.primary] : [];
      allservers = allservers.concat(this.secondaries);
      if (readPreference.maxStalenessSeconds != null) {
        for (var i = 0; i < allservers.length; i++) {
          if (allservers[i].ismaster.maxWireVersion < 5) {
            return new MongoError(
              "maxStalenessSeconds not supported by at least one of the replicaset members"
            );
          }
        }
      }
      if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds == null) {
        return pickNearest(this, readPreference);
      } else if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds != null) {
        return pickNearestMaxStalenessSeconds(this, readPreference);
      }
      var secondaries = this.secondaries;
      if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {
        return new MongoError("no secondary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {
        return new MongoError("no secondary or primary server available");
      }
      if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
        return new MongoError("no primary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          var server = pickNearest(this, readPreference);
          if (server) {
            return server;
          }
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
          if (server) {
            return server;
          }
        }
        if (readPreference.equals(ReadPreference.secondaryPreferred)) {
          return this.primary;
        }
        return null;
      }
      if (readPreference.equals(ReadPreference.primaryPreferred)) {
        server = null;
        if (this.primary) {
          return this.primary;
        }
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          server = pickNearest(this, readPreference);
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
        }
        if (server)
          return server;
      }
      return this.primary;
    };
    var filterByTags = function(readPreference, servers) {
      if (readPreference.tags == null)
        return servers;
      var filteredServers = [];
      var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
      for (var j = 0; j < tagsArray.length; j++) {
        var tags = tagsArray[j];
        for (var i = 0; i < servers.length; i++) {
          var serverTag = servers[i].lastIsMaster().tags || {};
          var found = true;
          for (var name in tags) {
            if (serverTag[name] !== tags[name]) {
              found = false;
            }
          }
          if (found) {
            filteredServers.push(servers[i]);
          }
        }
      }
      return filteredServers;
    };
    function pickNearestMaxStalenessSeconds(self2, readPreference) {
      var servers = [];
      var maxStalenessMS = readPreference.maxStalenessSeconds * 1e3;
      if (maxStalenessMS < 90 * 1e3) {
        return new MongoError("maxStalenessSeconds must be set to at least 90 seconds");
      }
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (self2.primary && servers.length === 0 && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers = servers.filter(function(s) {
        return s.staleness <= maxStalenessMS;
      });
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function pickNearest(self2, readPreference) {
      var servers = [];
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (servers.length === 0 && self2.primary && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
      servers = servers.filter(function(s) {
        return s.lastIsMasterMS <= lowest + self2.acceptableLatency;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function inList(ismaster, server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      return false;
    }
    function addToList(self2, type, ismaster, server, list) {
      var serverName = server.name.toLowerCase();
      self2.set[serverName].type = type;
      self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
      self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
      self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
      list.push(server);
    }
    function compareObjectIds(id1, id2) {
      var a = Buffer2.from(id1.toHexString(), "hex");
      var b = Buffer2.from(id2.toHexString(), "hex");
      if (a === b) {
        return 0;
      }
      if (typeof Buffer2.compare === "function") {
        return Buffer2.compare(a, b);
      }
      var x = a.length;
      var y = b.length;
      var len = Math.min(x, y);
      for (var i = 0; i < len; i++) {
        if (a[i] !== b[i]) {
          break;
        }
      }
      if (i !== len) {
        x = a[i];
        y = b[i];
      }
      return x < y ? -1 : y < x ? 1 : 0;
    }
    function removeFrom(server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].equals && list[i].equals(server)) {
          list.splice(i, 1);
          return true;
        } else if (typeof list[i] === "string" && list[i].toLowerCase() === server.name.toLowerCase()) {
          list.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        var setName = self2.setName;
        if (self2.hasPrimaryAndSecondary()) {
          topology = "ReplicaSetWithPrimary";
        } else if (!self2.hasPrimary() && self2.hasSecondary()) {
          topology = "ReplicaSetNoPrimary";
        }
        var description = {
          topologyType: topology,
          setName,
          servers: []
        };
        if (self2.hasPrimary()) {
          var desc = self2.primary.getDescription();
          desc.type = "RSPrimary";
          description.servers.push(desc);
        }
        description.servers = description.servers.concat(
          self2.secondaries.map(function(x) {
            var description2 = x.getDescription();
            description2.type = "RSSecondary";
            return description2;
          })
        );
        description.servers = description.servers.concat(
          self2.arbiters.map(function(x) {
            var description2 = x.getDescription();
            description2.type = "RSArbiter";
            return description2;
          })
        );
        description.servers = description.servers.concat(
          self2.passives.map(function(x) {
            var description2 = x.getDescription();
            description2.type = "RSSecondary";
            return description2;
          })
        );
        var diffResult = diff(self2.replicasetDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.replicasetDescription,
          newDescription: description,
          diff: diffResult
        };
        self2.emit("topologyDescriptionChanged", result);
        self2.replicasetDescription = description;
      }
    }
    module2.exports = ReplSetState;
  }
});

// node_modules/mongodb/lib/core/topologies/replset.js
var require_replset = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset.js"(exports2, module2) {
    "use strict";
    var inherits = __require("util").inherits;
    var f = __require("util").format;
    var EventEmitter = __require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var CoreCursor = require_cursor().CoreCursor;
    var retrieveBSON = require_utils4().retrieveBSON;
    var Logger = require_logger();
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var ReplSetState = require_replset_state();
    var Timeout = require_shared2().Timeout;
    var Interval = require_shared2().Interval;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils3().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils3().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var now = require_utils().now;
    var calculateDurationInMs = require_utils().calculateDurationInMs;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(
          f(
            "Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]",
            self2.id,
            self2.state,
            newState,
            legalStates
          )
        );
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var ReplSet = function(seedlist, options) {
      var self2 = this;
      options = options || {};
      if (!Array.isArray(seedlist))
        throw new MongoError("seedlist must be an array");
      if (seedlist.length === 0)
        throw new MongoError("seedlist must contain at least one entry");
      seedlist.forEach(function(e) {
        if (typeof e.host !== "string" || typeof e.port !== "number")
          throw new MongoError("seedlist entry must contain a host and port");
      });
      EventEmitter.call(this);
      this.id = id++;
      var localThresholdMS = options.localThresholdMS || 15;
      if (options.acceptableLatency)
        localThresholdMS = options.acceptableLatency;
      var logger = Logger("ReplSet", options);
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options) }, options),
        // BSON instance
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        // Factory overrides
        Cursor: options.cursorFactory || CoreCursor,
        // Logger instance
        logger,
        // Seedlist
        seedlist,
        // Replicaset state
        replicaSetState: new ReplSetState({
          id: this.id,
          setName: options.setName,
          acceptableLatency: localThresholdMS,
          heartbeatFrequencyMS: options.haInterval ? options.haInterval : 1e4,
          logger
        }),
        // Current servers we are connecting to
        connectingServers: [],
        // Ha interval
        haInterval: options.haInterval ? options.haInterval : 1e4,
        // Minimum heartbeat frequency used if we detect a server close
        minHeartbeatFrequencyMS: 500,
        // Disconnect handler
        disconnectHandler: options.disconnectHandler,
        // Server selection index
        index: 0,
        // Connect function options passed in
        connectOptions: {},
        // Are we running in debug mode
        debug: typeof options.debug === "boolean" ? options.debug : false
      };
      this.s.replicaSetState.on("topologyDescriptionChanged", function(r) {
        self2.emit("topologyDescriptionChanged", r);
      });
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(
          f(
            "warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts",
            this.s.options.socketTimeout,
            this.s.haInterval
          )
        );
      }
      var types = ["joined", "left"];
      types.forEach(function(x) {
        self2.s.replicaSetState.on(x, function(t, s) {
          self2.emit(x, t, s);
        });
      });
      this.initialConnectState = {
        connect: false,
        fullsetup: false,
        all: false
      };
      this.state = DISCONNECTED;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.intervalIds = [];
      this.clusterTime = null;
    };
    inherits(ReplSet, EventEmitter);
    Object.assign(ReplSet.prototype, SessionMixins);
    Object.defineProperty(ReplSet.prototype, "type", {
      enumerable: true,
      get: function() {
        return "replset";
      }
    });
    Object.defineProperty(ReplSet.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(ReplSet.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;
      }
    });
    function rexecuteOperations(self2) {
      if (self2.s.replicaSetState.hasPrimaryAndSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute();
      } else if (self2.s.replicaSetState.hasPrimary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({ executePrimary: true });
      } else if (self2.s.replicaSetState.hasSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({ executeSecondary: true });
      }
    }
    function connectNewServers(self2, servers, callback) {
      if (servers.length === 0) {
        return callback();
      }
      var count = servers.length;
      var error = null;
      function done() {
        count = count - 1;
        if (count === 0) {
          callback(error);
        }
      }
      var _handleEvent = function(self3, event) {
        return function(err) {
          var _self = this;
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            this.destroy({ force: true });
            return done();
          }
          if (event === "connect") {
            var result = self3.s.replicaSetState.update(_self);
            if (result) {
              if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
                self3.ismaster = _self.lastIsMaster();
              }
              for (let i2 = 0; i2 < handlers.length; i2++) {
                _self.removeAllListeners(handlers[i2]);
              }
              _self.on("error", handleEvent(self3, "error"));
              _self.on("close", handleEvent(self3, "close"));
              _self.on("timeout", handleEvent(self3, "timeout"));
              _self.on("parseError", handleEvent(self3, "parseError"));
              monitorServer(_self.lastIsMaster().me, self3, {});
              rexecuteOperations(self3);
            } else {
              _self.destroy({ force: true });
            }
          } else if (event === "error") {
            error = err;
          }
          rexecuteOperations(self3);
          done();
        };
      };
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          const existingServerIdx = self2.s.connectingServers.findIndex((s) => s.name === _server);
          if (existingServerIdx >= 0) {
            const connectingServer = self2.s.connectingServers[existingServerIdx];
            connectingServer.destroy({ force: true });
            self2.s.connectingServers.splice(existingServerIdx, 1);
            return done();
          }
          var server = new Server(
            Object.assign({}, self2.s.options, {
              host: _server.split(":")[0],
              port: parseInt(_server.split(":")[1], 10),
              reconnect: false,
              monitoring: false,
              parent: self2
            })
          );
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.s.connectingServers.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < servers.length; i++) {
        execute(servers[i], i);
      }
    }
    var pingServer = function(self2, server, cb) {
      var start = (/* @__PURE__ */ new Date()).getTime();
      emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: server.name });
      server.command(
        "admin.$cmd",
        {
          ismaster: true
        },
        {
          monitoring: true,
          socketTimeout: self2.s.options.connectionTimeout || 2e3
        },
        function(err, r) {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            server.destroy({ force: true });
            return cb(err, r);
          }
          var latencyMS = (/* @__PURE__ */ new Date()).getTime() - start;
          server.lastUpdateTime = now();
          if (err) {
            emitSDAMEvent(self2, "serverHeartbeatFailed", {
              durationMS: latencyMS,
              failure: err,
              connectionId: server.name
            });
            self2.s.replicaSetState.remove(server);
          } else {
            server.ismaster = r.result;
            if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
              server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
            }
            if (server.lastIsMasterMS === -1) {
              server.lastIsMasterMS = latencyMS;
            } else if (server.lastIsMasterMS) {
              server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
            }
            if (self2.s.replicaSetState.update(server)) {
              if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
                self2.ismaster = server.lastIsMaster();
              }
            }
            emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: server.name
            });
          }
          self2.s.replicaSetState.updateServerMaxStaleness(server, self2.s.haInterval);
          cb(err, r);
        }
      );
    };
    var monitorServer = function(host, self2, options) {
      if (!options.haInterval) {
        for (var i = 0; i < self2.intervalIds.length; i++) {
          if (self2.intervalIds[i].__host === host) {
            return;
          }
        }
      }
      var _process = options.haInterval ? Timeout : Interval;
      var _haInterval = options.haInterval ? options.haInterval : self2.s.haInterval;
      var intervalId = new _process(function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          intervalId.stop();
          return;
        }
        var _server = self2.s.replicaSetState.get(host);
        if (_server) {
          return pingServer(self2, _server, function(err) {
            if (err) {
              return;
            }
            if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
              intervalId.stop();
              return;
            }
            self2.intervalIds = self2.intervalIds.filter(function(intervalId2) {
              return intervalId2.isRunning();
            });
            if (_process === Timeout) {
              if (self2.state === CONNECTING && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTED);
                process.nextTick(function() {
                  self2.emit("connect", self2);
                });
                topologyMonitor(self2, {});
              }
            } else {
              if (self2.state === DISCONNECTED && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTING);
                rexecuteOperations(self2);
                process.nextTick(function() {
                  self2.emit("reconnect", self2);
                });
              }
            }
            if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
              self2.initialConnectState.fullsetup = true;
              self2.initialConnectState.all = true;
              process.nextTick(function() {
                self2.emit("fullsetup", self2);
                self2.emit("all", self2);
              });
            }
          });
        }
      }, _haInterval);
      intervalId.start();
      intervalId.__host = host;
      self2.intervalIds.push(intervalId);
    };
    function topologyMonitor(self2, options) {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED)
        return;
      options = options || {};
      var servers = Object.keys(self2.s.replicaSetState.set);
      var _process = options.haInterval ? Timeout : Interval;
      var _haInterval = options.haInterval ? options.haInterval : self2.s.haInterval;
      if (_process === Timeout) {
        return connectNewServers(self2, self2.s.replicaSetState.unknownServers, function(err) {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          if (!self2.s.replicaSetState.hasPrimary() && !self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit(
              "error",
              new MongoError("no primary found in replicaset or invalid replica set name")
            );
            return self2.destroy({ force: true });
          } else if (!self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit(
              "error",
              new MongoError("no secondary found in replicaset or invalid replica set name")
            );
            return self2.destroy({ force: true });
          }
          for (var i2 = 0; i2 < servers.length; i2++) {
            monitorServer(servers[i2], self2, options);
          }
        });
      } else {
        for (var i = 0; i < servers.length; i++) {
          monitorServer(servers[i], self2, options);
        }
      }
      function executeReconnect(self3) {
        return function() {
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            return;
          }
          connectNewServers(self3, self3.s.replicaSetState.unknownServers, function() {
            var monitoringFrequencey = self3.s.replicaSetState.hasPrimary() ? _haInterval : self3.s.minHeartbeatFrequencyMS;
            self3.intervalIds.push(new Timeout(executeReconnect(self3), monitoringFrequencey).start());
          });
        };
      }
      var intervalTime = !self2.s.replicaSetState.hasPrimary() ? self2.s.minHeartbeatFrequencyMS : _haInterval;
      self2.intervalIds.push(new Timeout(executeReconnect(self2), intervalTime).start());
    }
    function addServerToList(list, server) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      list.push(server);
    }
    function handleEvent(self2, event) {
      return function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(
            f("handleEvent %s from server %s in replset with id %s", event, this.name, self2.id)
          );
        }
        self2.s.replicaSetState.remove(this);
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (!self2.s.replicaSetState.hasPrimary() && !self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
          stateTransition(self2, DISCONNECTED);
        } else if (!self2.s.replicaSetState.hasPrimary()) {
          stateTransition(self2, DISCONNECTED);
        }
        addServerToList(self2.s.connectingServers, this);
      };
    }
    function shouldTriggerConnect(self2) {
      const isConnecting = self2.state === CONNECTING;
      const hasPrimary = self2.s.replicaSetState.hasPrimary();
      const hasSecondary = self2.s.replicaSetState.hasSecondary();
      const secondaryOnlyConnectionAllowed = self2.s.options.secondaryOnlyConnectionAllowed;
      const readPreferenceSecondary = self2.s.connectOptions.readPreference && self2.s.connectOptions.readPreference.equals(ReadPreference.secondary);
      return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(
            f(
              "handleInitialConnectEvent %s from server %s in replset with id %s",
              event,
              this.name,
              self2.id
            )
          );
        }
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          return this.destroy({ force: true });
        }
        if (event === "connect") {
          var result = self2.s.replicaSetState.update(_this);
          if (result === true) {
            if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
              self2.ismaster = _this.lastIsMaster();
            }
            if (self2.s.logger.isDebug()) {
              self2.s.logger.debug(
                f(
                  "handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]",
                  event,
                  _this.name,
                  self2.id,
                  JSON.stringify(self2.s.replicaSetState.set)
                )
              );
            }
            for (let i2 = 0; i2 < handlers.length; i2++) {
              _this.removeAllListeners(handlers[i2]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            if (shouldTriggerConnect(self2)) {
              stateTransition(self2, CONNECTED);
              self2.initialConnectState.connect = true;
              process.nextTick(function() {
                self2.emit("connect", self2);
              });
              topologyMonitor(self2, {});
            }
          } else if (result instanceof MongoError) {
            _this.destroy({ force: true });
            self2.destroy({ force: true });
            return self2.emit("error", result);
          } else {
            _this.destroy({ force: true });
          }
        } else {
          self2.emit("failed", this);
          addServerToList(self2.s.connectingServers, this);
          self2.s.replicaSetState.remove(this);
        }
        if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
          self2.initialConnectState.fullsetup = true;
          self2.initialConnectState.all = true;
          process.nextTick(function() {
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          });
        }
        for (var i = 0; i < self2.s.connectingServers.length; i++) {
          if (self2.s.connectingServers[i].equals(this)) {
            self2.s.connectingServers.splice(i, 1);
          }
        }
        if (self2.s.connectingServers.length === 0 && self2.state === CONNECTING) {
          topologyMonitor(self2, { haInterval: 1 });
        }
      };
    }
    function connectServers(self2, servers) {
      self2.s.connectingServers = self2.s.connectingServers.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          if (self2.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self2.ismaster = server.lastIsMaster();
            }
          }
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      while (servers.length > 0) {
        connect(servers.shift(), timeoutInterval++);
      }
    }
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    ReplSet.prototype.connect = function(options) {
      var self2 = this;
      this.s.connectOptions = options || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        return new Server(
          Object.assign({}, self2.s.options, x, options, {
            reconnect: false,
            monitoring: false,
            parent: self2
          })
        );
      });
      if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {
        return self2.emit(
          "error",
          new MongoError(
            f(
              "haInterval [%s] MS must be set to less than socketTimeout [%s] MS",
              this.s.options.haInterval,
              this.s.options.socketTimeout
            )
          )
        );
      }
      emitSDAMEvent(this, "topologyOpening", { topologyId: this.id });
      connectServers(self2, servers);
    };
    ReplSet.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    ReplSet.prototype.destroy = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      let destroyCount = this.s.connectingServers.length + 1;
      const serverDestroyed = () => {
        destroyCount--;
        if (destroyCount > 0) {
          return;
        }
        emitSDAMEvent(this, "topologyClosed", { topologyId: this.id });
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (this.state === DESTROYED) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DESTROYED);
      if (this.haTimeoutId)
        clearTimeout(this.haTimeoutId);
      for (var i = 0; i < this.intervalIds.length; i++) {
        this.intervalIds[i].stop();
      }
      this.intervalIds = [];
      if (destroyCount === 0) {
        serverDestroyed();
        return;
      }
      this.s.replicaSetState.destroy(options, serverDestroyed);
      this.s.connectingServers.forEach(function(x) {
        x.destroy(options, serverDestroyed);
      });
    };
    ReplSet.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      this.s.replicaSetState.allServers().forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    ReplSet.prototype.lastIsMaster = function() {
      if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {
        return this.s.replicaSetState.secondaries[0].lastIsMaster();
      }
      return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
    };
    ReplSet.prototype.connections = function() {
      var servers = this.s.replicaSetState.allServers();
      var connections = [];
      for (var i = 0; i < servers.length; i++) {
        connections = connections.concat(servers[i].connections());
      }
      return connections;
    };
    ReplSet.prototype.isConnected = function(options) {
      options = options || {};
      if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {
        return this.s.replicaSetState.hasSecondary();
      }
      if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {
        return this.s.replicaSetState.hasPrimary();
      }
      if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
        return true;
      }
      return this.s.replicaSetState.hasPrimary();
    };
    ReplSet.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    var SERVER_SELECTION_TIMEOUT_MS = 1e4;
    var SERVER_SELECTION_INTERVAL_MS = 1e3;
    ReplSet.prototype.selectServer = function(selector, options, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options = {};
      if (typeof options === "function")
        callback = options, options = selector;
      options = options || {};
      let readPreference;
      if (selector instanceof ReadPreference) {
        readPreference = selector;
      } else {
        readPreference = options.readPreference || ReadPreference.primary;
      }
      let lastError;
      const start = now();
      const _selectServer = () => {
        if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {
          if (lastError != null) {
            callback(lastError, null);
          } else {
            callback(new MongoError("Server selection timed out"));
          }
          return;
        }
        const server = this.s.replicaSetState.pickServer(readPreference);
        if (server == null) {
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (!(server instanceof Server)) {
          lastError = server;
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (this.s.debug)
          this.emit("pickedServer", options.readPreference, server);
        callback(null, server);
      };
      _selectServer();
    };
    ReplSet.prototype.getServers = function() {
      return this.s.replicaSetState.allServers();
    };
    function executeWriteOperation(args, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      if (self2.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && options.explain === void 0;
      if (!self2.s.replicaSetState.hasPrimary()) {
        if (self2.s.disconnectHandler) {
          return self2.s.disconnectHandler.add(op, ns, ops, options, callback);
        } else if (!willRetryWrite) {
          return callback(new MongoError("no primary server found"));
        }
      }
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          err = getMMAPError(err);
          return callback(err);
        }
        if (willRetryWrite) {
          const newArgs = Object.assign({}, args, { retrying: true });
          return executeWriteOperation(newArgs, options, callback);
        }
        if (self2.s.replicaSetState.primary) {
          self2.s.replicaSetState.primary.destroy();
          self2.s.replicaSetState.remove(self2.s.replicaSetState.primary, { force: true });
        }
        return callback(err);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options.session.incrementTransactionNumber();
        options.willRetryWrite = willRetryWrite;
      }
      self2.s.replicaSetState.primary[op](ns, ops, options, handler);
    }
    ReplSet.prototype.insert = function(ns, ops, options, callback) {
      executeWriteOperation({ self: this, op: "insert", ns, ops }, options, callback);
    };
    ReplSet.prototype.update = function(ns, ops, options, callback) {
      executeWriteOperation({ self: this, op: "update", ns, ops }, options, callback);
    };
    ReplSet.prototype.remove = function(ns, ops, options, callback) {
      executeWriteOperation({ self: this, op: "remove", ns, ops }, options, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    ReplSet.prototype.command = function(ns, cmd, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED)
        return callback(new MongoError(f("topology was destroyed")));
      var self2 = this;
      var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;
      if (readPreference.preference === "primary" && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
      } else if (readPreference.preference === "secondary" && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
      } else if (readPreference.preference !== "primary" && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
      }
      var server = this.s.replicaSetState.pickServer(readPreference);
      if (!(server instanceof Server))
        return callback(server);
      if (self2.s.debug)
        self2.emit("pickedServer", ReadPreference.primary, server);
      if (server == null) {
        return callback(
          new MongoError(
            f("no server found that matches the provided readPreference %s", readPreference)
          )
        );
      }
      const willRetryWrite = !options.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, options, { retrying: true });
          return this.command(ns, cmd, newOptions, callback);
        }
        if (this.s.replicaSetState.primary) {
          this.s.replicaSetState.primary.destroy();
          this.s.replicaSetState.remove(this.s.replicaSetState.primary, { force: true });
        }
        return callback(err);
      };
      if (willRetryWrite) {
        options.session.incrementTransactionNumber();
        options.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, options, cb);
    };
    ReplSet.prototype.cursor = function(ns, cmd, options) {
      options = options || {};
      const topology = options.topology || this;
      var FinalCursor = options.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options);
    };
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/core/topologies/mongos.js
var require_mongos = __commonJS({
  "node_modules/mongodb/lib/core/topologies/mongos.js"(exports2, module2) {
    "use strict";
    var inherits = __require("util").inherits;
    var f = __require("util").format;
    var EventEmitter = __require("events").EventEmitter;
    var CoreCursor = require_cursor().CoreCursor;
    var Logger = require_logger();
    var retrieveBSON = require_utils4().retrieveBSON;
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var diff = require_shared2().diff;
    var cloneOptions = require_shared2().cloneOptions;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils3().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils3().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYING, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYING, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(
          f(
            "Mongos with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]",
            self2.id,
            self2.state,
            newState,
            legalStates
          )
        );
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var Mongos = function(seedlist, options) {
      options = options || {};
      this.id = id++;
      if (Array.isArray(seedlist)) {
        seedlist = seedlist.reduce((seeds, seed) => {
          if (seeds.find((s) => s.host === seed.host && s.port === seed.port)) {
            return seeds;
          }
          seeds.push(seed);
          return seeds;
        }, []);
      }
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options) }, options),
        // BSON instance
        bson: options.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        // Factory overrides
        Cursor: options.cursorFactory || CoreCursor,
        // Logger instance
        logger: Logger("Mongos", options),
        // Seedlist
        seedlist,
        // Ha interval
        haInterval: options.haInterval ? options.haInterval : 1e4,
        // Disconnect handler
        disconnectHandler: options.disconnectHandler,
        // Server selection index
        index: 0,
        // Connect function options passed in
        connectOptions: {},
        // Are we running in debug mode
        debug: typeof options.debug === "boolean" ? options.debug : false,
        // localThresholdMS
        localThresholdMS: options.localThresholdMS || 15
      };
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(
          f(
            "warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts",
            this.s.options.socketTimeout,
            this.s.haInterval
          )
        );
      }
      this.state = DISCONNECTED;
      this.connectingProxies = [];
      this.connectedProxies = [];
      this.disconnectedProxies = [];
      this.index = 0;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.topologyDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.clusterTime = null;
      EventEmitter.call(this);
    };
    inherits(Mongos, EventEmitter);
    Object.assign(Mongos.prototype, SessionMixins);
    Object.defineProperty(Mongos.prototype, "type", {
      enumerable: true,
      get: function() {
        return "mongos";
      }
    });
    Object.defineProperty(Mongos.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Mongos.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    var SERVER_EVENTS = ["serverDescriptionChanged", "error", "close", "timeout", "parseError"];
    function destroyServer(server, options, callback) {
      options = options || {};
      SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options, callback);
    }
    Mongos.prototype.connect = function(options) {
      var self2 = this;
      this.s.connectOptions = options || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        const server = new Server(
          Object.assign({}, self2.s.options, x, options, {
            reconnect: false,
            monitoring: false,
            parent: self2
          })
        );
        relayEvents(server, self2, ["serverDescriptionChanged"]);
        return server;
      });
      emitSDAMEvent(this, "topologyOpening", { topologyId: this.id });
      connectProxies(self2, servers);
    };
    Mongos.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    function handleEvent(self2) {
      return function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          return;
        }
        moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, this);
        emitTopologyDescriptionChanged(self2);
        self2.emit("left", "mongos", this);
        self2.emit("serverClosed", {
          topologyId: self2.id,
          address: this.name
        });
      };
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.state === DESTROYED) {
          emitTopologyDescriptionChanged(self2);
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          return this.destroy();
        }
        if (event === "connect") {
          self2.ismaster = _this.lastIsMaster();
          if (self2.ismaster.msg === "isdbgrid") {
            for (let i = 0; i < self2.connectedProxies.length; i++) {
              if (self2.connectedProxies[i].name === _this.name) {
                moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _this);
                emitTopologyDescriptionChanged(self2);
                _this.destroy();
                return self2.emit("failed", _this);
              }
            }
            for (let i = 0; i < handlers.length; i++) {
              _this.removeAllListeners(handlers[i]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            moveServerFrom(self2.connectingProxies, self2.connectedProxies, _this);
            self2.emit("joined", "mongos", _this);
          } else {
            if (self2.s.logger.isWarn()) {
              var message = "expected mongos proxy, but found replicaset member mongod for server %s";
              if (!self2.ismaster.hosts) {
                message = "expected mongos proxy, but found standalone mongod for server %s";
              }
              self2.s.logger.warn(f(message, _this.name));
            }
            _this.destroy(true);
            removeProxyFrom(self2.connectingProxies, _this);
            self2.emit("left", "server", _this);
            self2.emit("failed", _this);
          }
        } else {
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          self2.emit("left", "mongos", this);
          self2.emit("failed", this);
        }
        emitTopologyDescriptionChanged(self2);
        if (self2.connectingProxies.length === 0) {
          if (self2.connectedProxies.length > 0 && self2.state === CONNECTING) {
            stateTransition(self2, CONNECTED);
            self2.emit("connect", self2);
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          } else if (self2.disconnectedProxies.length === 0) {
            if (self2.s.logger.isWarn()) {
              self2.s.logger.warn(
                f("no mongos proxies found in seed list, did you mean to connect to a replicaset")
              );
            }
            return self2.emit("error", new MongoError("no mongos proxies found in seed list"));
          }
          topologyMonitor(self2, { firstConnect: true });
        }
      };
    }
    function connectProxies(self2, servers) {
      self2.connectingProxies = self2.connectingProxies.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          self2.emit("serverOpening", {
            topologyId: self2.id,
            address: server.name
          });
          emitTopologyDescriptionChanged(self2);
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      servers.forEach((server) => connect(server, timeoutInterval++));
    }
    function pickProxy(self2, session) {
      const transaction = session && session.transaction;
      if (transaction && transaction.server) {
        if (transaction.server.isConnected()) {
          return transaction.server;
        } else {
          transaction.unpinServer();
        }
      }
      var connectedProxies = self2.connectedProxies.slice(0);
      var lowerBoundLatency = Number.MAX_VALUE;
      for (var i = 0; i < connectedProxies.length; i++) {
        if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
          lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
        }
      }
      connectedProxies = connectedProxies.filter(function(server) {
        if (server.lastIsMasterMS <= lowerBoundLatency + self2.s.localThresholdMS && server.isConnected()) {
          return true;
        }
      });
      let proxy;
      if (connectedProxies.length === 0) {
        proxy = self2.connectedProxies[0];
      } else {
        proxy = connectedProxies[self2.index % connectedProxies.length];
        self2.index = (self2.index + 1) % connectedProxies.length;
      }
      if (transaction && transaction.isActive && proxy && proxy.isConnected()) {
        transaction.pinServer(proxy);
      }
      return proxy;
    }
    function moveServerFrom(from, to, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
      for (i = 0; i < to.length; i++) {
        if (to[i].name === proxy.name) {
          to.splice(i, 1);
        }
      }
      to.push(proxy);
    }
    function removeProxyFrom(from, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
    }
    function reconnectProxies(self2, proxies, callback) {
      var count = proxies.length;
      var _handleEvent = function(self3, event) {
        return function() {
          var _self = this;
          count = count - 1;
          if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            return this.destroy();
          }
          if (event === "connect") {
            if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
              moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
              return _self.destroy();
            }
            for (var i2 = 0; i2 < handlers.length; i2++) {
              _self.removeAllListeners(handlers[i2]);
            }
            _self.on("error", handleEvent(self3, "error"));
            _self.on("close", handleEvent(self3, "close"));
            _self.on("timeout", handleEvent(self3, "timeout"));
            _self.on("parseError", handleEvent(self3, "parseError"));
            moveServerFrom(self3.connectingProxies, self3.connectedProxies, _self);
            emitTopologyDescriptionChanged(self3);
            self3.emit("joined", "mongos", _self);
          } else {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            this.destroy();
          }
          if (count === 0) {
            callback();
          }
        };
      };
      if (count === 0) {
        return callback();
      }
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            return;
          }
          var server = new Server(
            Object.assign({}, self2.s.options, {
              host: _server.name.split(":")[0],
              port: parseInt(_server.name.split(":")[1], 10),
              reconnect: false,
              monitoring: false,
              parent: self2
            })
          );
          destroyServer(_server, { force: true });
          removeProxyFrom(self2.disconnectedProxies, _server);
          relayEvents(server, self2, ["serverDescriptionChanged"]);
          self2.emit("serverOpening", {
            topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self2.id,
            address: server.name
          });
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.connectingProxies.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < proxies.length; i++) {
        execute(proxies[i], i);
      }
    }
    function topologyMonitor(self2, options) {
      options = options || {};
      if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
        return;
      }
      self2.haTimeoutId = setTimeout(function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
          return;
        }
        if (self2.isConnected() && self2.s.disconnectHandler) {
          self2.s.disconnectHandler.execute();
        }
        var proxies = self2.connectedProxies.slice(0);
        var count = proxies.length;
        function pingServer(_self, _server, cb) {
          var start = (/* @__PURE__ */ new Date()).getTime();
          emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: _server.name });
          _server.command(
            "admin.$cmd",
            {
              ismaster: true
            },
            {
              monitoring: true,
              socketTimeout: self2.s.options.connectionTimeout || 2e3
            },
            function(err, r) {
              if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
                _server.destroy();
                return cb(err, r);
              }
              var latencyMS = (/* @__PURE__ */ new Date()).getTime() - start;
              if (err) {
                emitSDAMEvent(self2, "serverHeartbeatFailed", {
                  durationMS: latencyMS,
                  failure: err,
                  connectionId: _server.name
                });
                moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
              } else {
                _server.ismaster = r.result;
                _server.lastIsMasterMS = latencyMS;
                emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
                  durationMS: latencyMS,
                  reply: r.result,
                  connectionId: _server.name
                });
              }
              cb(err, r);
            }
          );
        }
        if (proxies.length === 0) {
          if (self2.listeners("close").length > 0 && self2.state === CONNECTING) {
            self2.emit("error", new MongoError("no mongos proxy available"));
          } else {
            self2.emit("close", self2);
          }
          return reconnectProxies(self2, self2.disconnectedProxies, function() {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              return;
            }
            if (self2.state === CONNECTING && options.firstConnect) {
              self2.emit("connect", self2);
              self2.emit("fullsetup", self2);
              self2.emit("all", self2);
            } else if (self2.isConnected()) {
              self2.emit("reconnect", self2);
            } else if (!self2.isConnected() && self2.listeners("close").length > 0) {
              self2.emit("close", self2);
            }
            topologyMonitor(self2);
          });
        }
        for (var i = 0; i < proxies.length; i++) {
          pingServer(self2, proxies[i], function() {
            count = count - 1;
            if (count === 0) {
              if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                return;
              }
              reconnectProxies(self2, self2.disconnectedProxies, function() {
                if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                  return;
                }
                topologyMonitor(self2);
              });
            }
          });
        }
      }, self2.s.haInterval);
    }
    Mongos.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Mongos.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      var proxies = this.connectedProxies.concat(this.connectingProxies);
      proxies.forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    Mongos.prototype.destroy = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      stateTransition(this, DESTROYING);
      if (this.haTimeoutId) {
        clearTimeout(this.haTimeoutId);
      }
      const proxies = this.connectedProxies.concat(this.connectingProxies);
      let serverCount = proxies.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        emitTopologyDescriptionChanged(this);
        emitSDAMEvent(this, "topologyClosed", { topologyId: this.id });
        stateTransition(this, DESTROYED);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      proxies.forEach((server) => {
        this.emit("serverClosed", {
          topologyId: this.id,
          address: server.name
        });
        destroyServer(server, options, serverDestroyed);
        moveServerFrom(this.connectedProxies, this.disconnectedProxies, server);
      });
    };
    Mongos.prototype.isConnected = function() {
      return this.connectedProxies.length > 0;
    };
    Mongos.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    function executeWriteOperation(args, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      let server = pickProxy(self2, options.session);
      if (!server)
        return callback(new MongoError("no mongos proxy available"));
      const willRetryWrite = !args.retrying && !!options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && options.explain === void 0;
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2) || !willRetryWrite) {
          err = getMMAPError(err);
          return callback(err);
        }
        server = pickProxy(self2, options.session);
        if (!server) {
          return callback(err);
        }
        const newArgs = Object.assign({}, args, { retrying: true });
        return executeWriteOperation(newArgs, options, callback);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options.session.incrementTransactionNumber();
        options.willRetryWrite = willRetryWrite;
      }
      server[op](ns, ops, options, handler);
    }
    Mongos.prototype.insert = function(ns, ops, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("insert", ns, ops, options, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "insert", ns, ops }, options, callback);
    };
    Mongos.prototype.update = function(ns, ops, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("update", ns, ops, options, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "update", ns, ops }, options, callback);
    };
    Mongos.prototype.remove = function(ns, ops, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("remove", ns, ops, options, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "remove", ns, ops }, options, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    Mongos.prototype.command = function(ns, cmd, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {}, options = options || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      var self2 = this;
      var server = pickProxy(self2, options.session);
      if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options, callback);
      }
      if (server == null) {
        return callback(new MongoError("no mongos proxy available"));
      }
      var clonedOptions = cloneOptions(options);
      clonedOptions.topology = self2;
      const willRetryWrite = !options.retrying && options.retryWrites && options.session && isRetryableWritesSupported(self2) && !options.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, clonedOptions, { retrying: true });
          return this.command(ns, cmd, newOptions, callback);
        }
        return callback(err);
      };
      if (willRetryWrite) {
        clonedOptions.session.incrementTransactionNumber();
        clonedOptions.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, clonedOptions, cb);
    };
    Mongos.prototype.cursor = function(ns, cmd, options) {
      options = options || {};
      const topology = options.topology || this;
      var FinalCursor = options.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options);
    };
    Mongos.prototype.selectServer = function(selector, options, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options = {};
      if (typeof options === "function")
        callback = options, options = selector, selector = void 0;
      options = options || {};
      const server = pickProxy(this, options.session);
      if (server == null) {
        callback(new MongoError("server selection failed"));
        return;
      }
      if (this.s.debug)
        this.emit("pickedServer", null, server);
      callback(null, server);
    };
    Mongos.prototype.connections = function() {
      var connections = [];
      for (var i = 0; i < this.connectedProxies.length; i++) {
        connections = connections.concat(this.connectedProxies[i].connections());
      }
      return connections;
    };
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        if (self2.connectedProxies.length > 0) {
          topology = "Sharded";
        }
        var description = {
          topologyType: topology,
          servers: []
        };
        var proxies = self2.disconnectedProxies.concat(self2.connectingProxies);
        description.servers = description.servers.concat(
          proxies.map(function(x) {
            var description2 = x.getDescription();
            description2.type = "Unknown";
            return description2;
          })
        );
        description.servers = description.servers.concat(
          self2.connectedProxies.map(function(x) {
            var description2 = x.getDescription();
            description2.type = "Mongos";
            return description2;
          })
        );
        var diffResult = diff(self2.topologyDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.topologyDescription,
          newDescription: description,
          diff: diffResult
        };
        if (diffResult.servers.length > 0) {
          self2.emit("topologyDescriptionChanged", result);
        }
        self2.topologyDescription = description;
      }
    }
    module2.exports = Mongos;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    "use strict";
    function Denque(array, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/mongodb/lib/core/sdam/events.js
var require_events = __commonJS({
  "node_modules/mongodb/lib/core/sdam/events.js"(exports2, module2) {
    "use strict";
    var ServerDescriptionChangedEvent = class {
      constructor(topologyId, address, previousDescription, newDescription) {
        Object.assign(this, { topologyId, address, previousDescription, newDescription });
      }
    };
    var ServerOpeningEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, { topologyId, address });
      }
    };
    var ServerClosedEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, { topologyId, address });
      }
    };
    var TopologyDescriptionChangedEvent = class {
      constructor(topologyId, previousDescription, newDescription) {
        Object.assign(this, { topologyId, previousDescription, newDescription });
      }
    };
    var TopologyOpeningEvent = class {
      constructor(topologyId) {
        Object.assign(this, { topologyId });
      }
    };
    var TopologyClosedEvent = class {
      constructor(topologyId) {
        Object.assign(this, { topologyId });
      }
    };
    var ServerHeartbeatStartedEvent = class {
      constructor(connectionId) {
        Object.assign(this, { connectionId });
      }
    };
    var ServerHeartbeatSucceededEvent = class {
      constructor(duration, reply, connectionId) {
        Object.assign(this, { connectionId, duration, reply });
      }
    };
    var ServerHeartbeatFailedEvent = class {
      constructor(duration, failure, connectionId) {
        Object.assign(this, { connectionId, duration, failure });
      }
    };
    module2.exports = {
      ServerDescriptionChangedEvent,
      ServerOpeningEvent,
      ServerClosedEvent,
      TopologyDescriptionChangedEvent,
      TopologyOpeningEvent,
      TopologyClosedEvent,
      ServerHeartbeatStartedEvent,
      ServerHeartbeatSucceededEvent,
      ServerHeartbeatFailedEvent
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = __require("stream");
  }
});

// node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = __require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = __require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = __require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = __require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object2) {
          if (realHasInstance.call(this, object2))
            return true;
          if (this !== Writable)
            return false;
          return object2 && object2._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object2) {
        return object2 instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value2) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value2;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value2) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value2;
        this._writableState.destroyed = value2;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer3 = __commonJS({
  "node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer3().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = __require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = __require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value2) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value2;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = __require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var util = __require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
      } else {
        this.append(callback);
      }
      DuplexStream.call(this);
    }
    util.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function _offset(offset) {
      var tot = 0, i = 0, _t;
      if (offset === 0)
        return [0, 0];
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length;
        if (offset < _t || i == this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      var bufferId = blOffset[0];
      var offset = blOffset[1];
      for (var i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.append = function append(buf) {
      var i = 0;
      if (Buffer2.isBuffer(buf)) {
        this._appendBuffer(buf);
      } else if (Array.isArray(buf)) {
        for (; i < buf.length; i++)
          this.append(buf[i]);
      } else if (buf instanceof BufferList) {
        for (; i < buf._bufs.length; i++)
          this.append(buf._bufs[i]);
      } else if (buf != null) {
        if (typeof buf == "number")
          buf = buf.toString();
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback == "function")
        callback();
    };
    BufferList.prototype._read = function _read(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      var offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start == "number" && start < 0)
        start += this.length;
      if (typeof end == "number" && end < 0)
        end += this.length;
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || Buffer2.alloc(0);
      if (srcEnd <= 0)
        return dst || Buffer2.alloc(0);
      var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy2 && dstStart || 0, start = off[1], l, i;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2)
        dst = Buffer2.allocUnsafe(len);
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start)
          start = 0;
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0)
        start += this.length;
      if (end < 0)
        end += this.length;
      if (start === end) {
        return new BufferList();
      }
      var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] == 0)
        buffers.pop();
      else
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      if (startOffset[1] != 0)
        buffers[0] = buffers[0].slice(startOffset[1]);
      return new BufferList(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      var i = 0, copy = new BufferList();
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i]);
      return copy;
    };
    BufferList.prototype.destroy = function destroy() {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (search instanceof BufferList) {
        search = search.slice();
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      var blOffset = this._offset(offset);
      var blIndex = blOffset[0];
      var buffOffset = blOffset[1];
      for (blIndex; blIndex < this._bufs.length; blIndex++) {
        var buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          var availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            var nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            var revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (var searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1,
        "readIntBE": null,
        "readIntLE": null,
        "readUIntBE": null,
        "readUIntLE": null
      };
      for (var m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    module2.exports = BufferList;
  }
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS({
  "node_modules/mongodb/lib/cmap/message_stream.js"(exports2, module2) {
    "use strict";
    var Duplex = __require("stream").Duplex;
    var BufferList = require_bl();
    var MongoParseError = require_error().MongoParseError;
    var decompress = require_compression().decompress;
    var Response = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoError = require_error().MongoError;
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var Msg = require_msg().Msg;
    var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
    var kBuffer = Symbol("buffer");
    var MessageStream = class extends Duplex {
      constructor(options) {
        options = options || {};
        super(options);
        this.bson = options.bson;
        this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
        this[kBuffer] = new BufferList();
      }
      _write(chunk, _, callback) {
        const buffer = this[kBuffer];
        buffer.append(chunk);
        processIncomingData(this, callback);
      }
      _read() {
        return;
      }
      writeCommand(command, operationDescription) {
        const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;
        if (!shouldCompress || !canCompress(command)) {
          const data = command.toBin();
          this.push(Array.isArray(data) ? Buffer.concat(data) : data);
          return;
        }
        const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {
          if (err) {
            operationDescription.cb(err, null);
            return;
          }
          const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
          msgHeader.writeInt32LE(
            MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,
            0
          );
          msgHeader.writeInt32LE(command.requestId, 4);
          msgHeader.writeInt32LE(0, 8);
          msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
          const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
          compressionDetails.writeInt32LE(originalCommandOpCode, 0);
          compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
          compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8);
          this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
        });
      }
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function processIncomingData(stream, callback) {
      const buffer = stream[kBuffer];
      if (buffer.length < 4) {
        callback();
        return;
      }
      const sizeOfMessage = buffer.readInt32LE(0);
      if (sizeOfMessage < 0) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));
        return;
      }
      if (sizeOfMessage > stream.maxBsonMessageSize) {
        callback(
          new MongoParseError(
            `Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`
          )
        );
        return;
      }
      if (sizeOfMessage > buffer.length) {
        callback();
        return;
      }
      const message = buffer.slice(0, sizeOfMessage);
      buffer.consume(sizeOfMessage);
      const messageHeader = {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
      let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;
      const responseOptions = stream.responseOptions;
      if (messageHeader.opCode !== OP_COMPRESSED) {
        const messageBody = message.slice(MESSAGE_HEADER_SIZE);
        stream.emit(
          "message",
          new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)
        );
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
        return;
      }
      messageHeader.fromCompressed = true;
      messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
      messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
      const compressorID = message[MESSAGE_HEADER_SIZE + 8];
      const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
      ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;
      decompress(compressorID, compressedBuffer, (err, messageBody) => {
        if (err) {
          callback(err);
          return;
        }
        if (messageBody.length !== messageHeader.length) {
          callback(
            new MongoError(
              "Decompressing a compressed message from the server failed. The message is corrupt."
            )
          );
          return;
        }
        stream.emit(
          "message",
          new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)
        );
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
      });
    }
    module2.exports = MessageStream;
  }
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS({
  "node_modules/mongodb/lib/cmap/stream_description.js"(exports2, module2) {
    "use strict";
    var parseServerType = require_server_description().parseServerType;
    var RESPONSE_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "__nodejs_mock_server__"
    ];
    var StreamDescription = class {
      constructor(address, options) {
        this.address = address;
        this.type = parseServerType(null);
        this.minWireVersion = void 0;
        this.maxWireVersion = void 0;
        this.maxBsonObjectSize = 16777216;
        this.maxMessageSizeBytes = 48e6;
        this.maxWriteBatchSize = 1e5;
        this.compressors = options && options.compression && Array.isArray(options.compression.compressors) ? options.compression.compressors : [];
      }
      receiveResponse(response) {
        this.type = parseServerType(response);
        RESPONSE_FIELDS.forEach((field) => {
          if (typeof response[field] !== "undefined") {
            this[field] = response[field];
          }
        });
        if (response.compression) {
          this.compressor = this.compressors.filter((c) => response.compression.indexOf(c) !== -1)[0];
        }
      }
    };
    module2.exports = {
      StreamDescription
    };
  }
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection2 = __commonJS({
  "node_modules/mongodb/lib/cmap/connection.js"(exports2, module2) {
    "use strict";
    var EventEmitter = __require("events");
    var MessageStream = require_message_stream();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var CommandResult = require_command_result();
    var StreamDescription = require_stream_description().StreamDescription;
    var wp = require_wireprotocol();
    var apm = require_apm();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var uuidV4 = require_utils3().uuidV4;
    var now = require_utils().now;
    var calculateDurationInMs = require_utils().calculateDurationInMs;
    var kStream = Symbol("stream");
    var kQueue = Symbol("queue");
    var kMessageStream = Symbol("messageStream");
    var kGeneration = Symbol("generation");
    var kLastUseTime = Symbol("lastUseTime");
    var kClusterTime = Symbol("clusterTime");
    var kDescription = Symbol("description");
    var kIsMaster = Symbol("ismaster");
    var kAutoEncrypter = Symbol("autoEncrypter");
    var Connection2 = class extends EventEmitter {
      constructor(stream, options) {
        super(options);
        this.id = options.id;
        this.address = streamIdentifier(stream);
        this.bson = options.bson;
        this.socketTimeout = typeof options.socketTimeout === "number" ? options.socketTimeout : 0;
        this.host = options.host || "localhost";
        this.port = options.port || 27017;
        this.monitorCommands = typeof options.monitorCommands === "boolean" ? options.monitorCommands : false;
        this.serverApi = options.serverApi;
        this.closed = false;
        this.destroyed = false;
        this[kDescription] = new StreamDescription(this.address, options);
        this[kGeneration] = options.generation;
        this[kLastUseTime] = now();
        if (options.autoEncrypter) {
          this[kAutoEncrypter] = options.autoEncrypter;
        }
        this[kQueue] = /* @__PURE__ */ new Map();
        this[kMessageStream] = new MessageStream(options);
        this[kMessageStream].on("message", messageHandler(this));
        this[kStream] = stream;
        stream.on("error", () => {
        });
        this[kMessageStream].on("error", (error) => this.handleIssue({ destroy: error }));
        stream.on("close", () => this.handleIssue({ isClose: true }));
        stream.on("timeout", () => this.handleIssue({ isTimeout: true, destroy: true }));
        stream.pipe(this[kMessageStream]);
        this[kMessageStream].pipe(stream);
      }
      get description() {
        return this[kDescription];
      }
      get ismaster() {
        return this[kIsMaster];
      }
      // the `connect` method stores the result of the handshake ismaster on the connection
      set ismaster(response) {
        this[kDescription].receiveResponse(response);
        this[kIsMaster] = response;
      }
      get generation() {
        return this[kGeneration] || 0;
      }
      get idleTime() {
        return calculateDurationInMs(this[kLastUseTime]);
      }
      get clusterTime() {
        return this[kClusterTime];
      }
      get stream() {
        return this[kStream];
      }
      markAvailable() {
        this[kLastUseTime] = now();
      }
      /**
       * @param {{ isTimeout?: boolean; isClose?: boolean; destroy?: boolean | Error }} issue
       */
      handleIssue(issue) {
        if (this.closed) {
          return;
        }
        if (issue.destroy) {
          this[kStream].destroy(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
        }
        this.closed = true;
        for (const idAndOp of this[kQueue]) {
          const op = idAndOp[1];
          if (issue.isTimeout) {
            op.cb(
              new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {
                beforeHandshake: this.ismaster == null
              })
            );
          } else if (issue.isClose) {
            op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));
          } else {
            op.cb(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
          }
        }
        this[kQueue].clear();
        this.emit("close");
      }
      destroy(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = Object.assign({ force: false }, options);
        if (this[kStream] == null || this.destroyed) {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        if (options.force) {
          this[kStream].destroy();
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        this[kStream].end((err) => {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      applyApiVersion(options) {
        if (this.serverApi) {
          options.serverApi = this.serverApi;
        }
        return options;
      }
      // Wire protocol methods
      command(ns, cmd, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        wp.command(makeServerTrampoline(this), ns, cmd, this.applyApiVersion(options), callback);
      }
      query(ns, cmd, cursorState, options, callback) {
        wp.query(
          makeServerTrampoline(this),
          ns,
          cmd,
          cursorState,
          this.applyApiVersion(options),
          callback
        );
      }
      getMore(ns, cursorState, batchSize, options, callback) {
        wp.getMore(
          makeServerTrampoline(this),
          ns,
          cursorState,
          batchSize,
          this.applyApiVersion(options),
          callback
        );
      }
      killCursors(ns, cursorState, callback) {
        wp.killCursors(makeServerTrampoline(this), ns, cursorState, this.applyApiVersion({}), callback);
      }
      insert(ns, ops, options, callback) {
        wp.insert(makeServerTrampoline(this), ns, ops, this.applyApiVersion(options), callback);
      }
      update(ns, ops, options, callback) {
        wp.update(makeServerTrampoline(this), ns, ops, this.applyApiVersion(options), callback);
      }
      remove(ns, ops, options, callback) {
        wp.remove(makeServerTrampoline(this), ns, ops, this.applyApiVersion(options), callback);
      }
    };
    function makeServerTrampoline(connection) {
      const server = {
        description: connection.description,
        clusterTime: connection[kClusterTime],
        s: {
          bson: connection.bson,
          pool: { write: write.bind(connection), isConnected: () => true }
        }
      };
      if (connection[kAutoEncrypter]) {
        server.autoEncrypter = connection[kAutoEncrypter];
      }
      return server;
    }
    function messageHandler(conn) {
      return function messageHandler2(message) {
        conn.emit("message", message);
        if (!conn[kQueue].has(message.responseTo)) {
          return;
        }
        const operationDescription = conn[kQueue].get(message.responseTo);
        const callback = operationDescription.cb;
        conn[kQueue].delete(message.responseTo);
        if (message.moreToCome) {
          conn[kQueue].set(message.requestId, operationDescription);
        } else if (operationDescription.socketTimeoutOverride) {
          conn[kStream].setTimeout(conn.socketTimeout);
        }
        try {
          message.parse(operationDescription);
        } catch (err) {
          callback(new MongoError(err));
          return;
        }
        if (message.documents[0]) {
          const document = message.documents[0];
          const session = operationDescription.session;
          if (session) {
            updateSessionFromResponse(session, document);
          }
          if (document.$clusterTime) {
            conn[kClusterTime] = document.$clusterTime;
            conn.emit("clusterTimeReceived", document.$clusterTime);
          }
          if (operationDescription.command) {
            if (document.writeConcernError) {
              callback(new MongoWriteConcernError(document.writeConcernError, document));
              return;
            }
            if (document.ok === 0 || document.$err || document.errmsg || document.code) {
              callback(new MongoError(document));
              return;
            }
          }
        }
        callback(
          void 0,
          new CommandResult(
            operationDescription.fullResult ? message : message.documents[0],
            conn,
            message
          )
        );
      };
    }
    function streamIdentifier(stream) {
      if (typeof stream.address === "function") {
        return `${stream.remoteAddress}:${stream.remotePort}`;
      }
      return uuidV4().toString("hex");
    }
    function write(command, options, callback) {
      if (typeof options === "function") {
        callback = options;
      }
      options = options || {};
      const operationDescription = {
        requestId: command.requestId,
        cb: callback,
        session: options.session,
        fullResult: typeof options.fullResult === "boolean" ? options.fullResult : false,
        noResponse: typeof options.noResponse === "boolean" ? options.noResponse : false,
        documentsReturnedIn: options.documentsReturnedIn,
        command: !!options.command,
        // for BSON parsing
        promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
        bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false,
        raw: typeof options.raw === "boolean" ? options.raw : false
      };
      if (this[kDescription] && this[kDescription].compressor) {
        operationDescription.agreedCompressor = this[kDescription].compressor;
        if (this[kDescription].zlibCompressionLevel) {
          operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;
        }
      }
      if (typeof options.socketTimeout === "number") {
        operationDescription.socketTimeoutOverride = true;
        this[kStream].setTimeout(options.socketTimeout);
      }
      if (this.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operationDescription.started = now();
        operationDescription.cb = (err, reply) => {
          if (err) {
            this.emit(
              "commandFailed",
              new apm.CommandFailedEvent(this, command, err, operationDescription.started)
            );
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              this.emit(
                "commandFailed",
                new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started)
              );
            } else {
              this.emit(
                "commandSucceeded",
                new apm.CommandSucceededEvent(this, command, reply, operationDescription.started)
              );
            }
          }
          if (typeof callback === "function") {
            callback(err, reply);
          }
        };
      }
      if (!operationDescription.noResponse) {
        this[kQueue].set(operationDescription.requestId, operationDescription);
      }
      try {
        this[kMessageStream].writeCommand(command, operationDescription);
      } catch (e) {
        if (!operationDescription.noResponse) {
          this[kQueue].delete(operationDescription.requestId);
          operationDescription.cb(e);
          return;
        }
      }
      if (operationDescription.noResponse) {
        operationDescription.cb();
      }
    }
    module2.exports = {
      Connection: Connection2
    };
  }
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors = __commonJS({
  "node_modules/mongodb/lib/cmap/errors.js"(exports2, module2) {
    "use strict";
    var MongoError = require_error().MongoError;
    var PoolClosedError = class extends MongoError {
      constructor(pool) {
        super("Attempted to check out a connection from closed connection pool");
        this.name = "MongoPoolClosedError";
        this.address = pool.address;
      }
    };
    var WaitQueueTimeoutError = class extends MongoError {
      constructor(pool) {
        super("Timed out while checking out a connection from connection pool");
        this.name = "MongoWaitQueueTimeoutError";
        this.address = pool.address;
      }
    };
    module2.exports = {
      PoolClosedError,
      WaitQueueTimeoutError
    };
  }
});

// node_modules/mongodb/lib/cmap/events.js
var require_events2 = __commonJS({
  "node_modules/mongodb/lib/cmap/events.js"(exports2, module2) {
    "use strict";
    var ConnectionPoolMonitoringEvent = class {
      constructor(pool) {
        this.time = /* @__PURE__ */ new Date();
        this.address = pool.address;
      }
    };
    var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
        this.options = pool.options;
      }
    };
    var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection, reason) {
        super(pool);
        this.connectionId = connection.id;
        this.reason = reason || "unknown";
      }
    };
    var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, reason) {
        super(pool);
        this.reason = reason;
      }
    };
    var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var CMAP_EVENT_NAMES = [
      "connectionPoolCreated",
      "connectionPoolClosed",
      "connectionCreated",
      "connectionReady",
      "connectionClosed",
      "connectionCheckOutStarted",
      "connectionCheckOutFailed",
      "connectionCheckedOut",
      "connectionCheckedIn",
      "connectionPoolCleared"
    ];
    module2.exports = {
      CMAP_EVENT_NAMES,
      ConnectionPoolCreatedEvent,
      ConnectionPoolClosedEvent,
      ConnectionCreatedEvent,
      ConnectionReadyEvent,
      ConnectionClosedEvent,
      ConnectionCheckOutStartedEvent,
      ConnectionCheckOutFailedEvent,
      ConnectionCheckedOutEvent,
      ConnectionCheckedInEvent,
      ConnectionPoolClearedEvent
    };
  }
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = __require("events").EventEmitter;
    var Logger = require_logger();
    var makeCounter = require_utils().makeCounter;
    var MongoError = require_error().MongoError;
    var Connection2 = require_connection2().Connection;
    var eachAsync = require_utils3().eachAsync;
    var connect = require_connect();
    var relayEvents = require_utils3().relayEvents;
    var errors = require_errors();
    var PoolClosedError = errors.PoolClosedError;
    var WaitQueueTimeoutError = errors.WaitQueueTimeoutError;
    var events = require_events2();
    var ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;
    var ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;
    var ConnectionCreatedEvent = events.ConnectionCreatedEvent;
    var ConnectionReadyEvent = events.ConnectionReadyEvent;
    var ConnectionClosedEvent = events.ConnectionClosedEvent;
    var ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;
    var ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;
    var ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;
    var ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;
    var ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;
    var kLogger = Symbol("logger");
    var kConnections = Symbol("connections");
    var kPermits = Symbol("permits");
    var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
    var kGeneration = Symbol("generation");
    var kConnectionCounter = Symbol("connectionCounter");
    var kCancellationToken = Symbol("cancellationToken");
    var kWaitQueue = Symbol("waitQueue");
    var kCancelled = Symbol("cancelled");
    var VALID_POOL_OPTIONS = /* @__PURE__ */ new Set([
      // `connect` options
      "ssl",
      "bson",
      "connectionType",
      "serverApi",
      "monitorCommands",
      "socketTimeout",
      "credentials",
      "compression",
      // node Net options
      "host",
      "port",
      "localAddress",
      "localPort",
      "family",
      "hints",
      "lookup",
      "path",
      // node TLS options
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "passphrase",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "allowHalfOpen",
      "rejectUnauthorized",
      "pskCallback",
      "ALPNProtocols",
      "servername",
      "checkServerIdentity",
      "session",
      "minDHSize",
      "secureContext",
      // spec options
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ]);
    function resolveOptions(options, defaults) {
      const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {
        if (Object.prototype.hasOwnProperty.call(options, key)) {
          obj[key] = options[key];
        }
        return obj;
      }, {});
      return Object.freeze(Object.assign({}, defaults, newOptions));
    }
    var ConnectionPool = class extends EventEmitter {
      /**
       * Create a new Connection Pool
       *
       * @param {ConnectionPoolOptions} options
       */
      constructor(options) {
        super();
        options = options || {};
        this.closed = false;
        this.options = resolveOptions(options, {
          connectionType: Connection2,
          maxPoolSize: typeof options.maxPoolSize === "number" ? options.maxPoolSize : 100,
          minPoolSize: typeof options.minPoolSize === "number" ? options.minPoolSize : 0,
          maxIdleTimeMS: typeof options.maxIdleTimeMS === "number" ? options.maxIdleTimeMS : 0,
          waitQueueTimeoutMS: typeof options.waitQueueTimeoutMS === "number" ? options.waitQueueTimeoutMS : 0,
          autoEncrypter: options.autoEncrypter,
          metadata: options.metadata,
          useUnifiedTopology: options.useUnifiedTopology
        });
        if (options.minSize > options.maxSize) {
          throw new TypeError(
            "Connection pool minimum size must not be greater than maximum pool size"
          );
        }
        this[kLogger] = Logger("ConnectionPool", options);
        this[kConnections] = new Denque();
        this[kPermits] = this.options.maxPoolSize;
        this[kMinPoolSizeTimer] = void 0;
        this[kGeneration] = 0;
        this[kConnectionCounter] = makeCounter(1);
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kWaitQueue] = new Denque();
        process.nextTick(() => {
          this.emit("connectionPoolCreated", new ConnectionPoolCreatedEvent(this));
          ensureMinPoolSize(this);
        });
      }
      get address() {
        return `${this.options.host}:${this.options.port}`;
      }
      get generation() {
        return this[kGeneration];
      }
      get totalConnectionCount() {
        return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);
      }
      get availableConnectionCount() {
        return this[kConnections].length;
      }
      get waitQueueSize() {
        return this[kWaitQueue].length;
      }
      /**
       * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it
       * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or
       * explicitly destroyed by the new owner.
       *
       * @param {ConnectionPool~checkOutCallback} callback
       */
      checkOut(callback) {
        this.emit("connectionCheckOutStarted", new ConnectionCheckOutStartedEvent(this));
        if (this.closed) {
          this.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(this, "poolClosed"));
          callback(new PoolClosedError(this));
          return;
        }
        const waitQueueMember = { callback };
        const pool = this;
        const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
        if (waitQueueTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, "timeout"));
            waitQueueMember.callback(new WaitQueueTimeoutError(pool));
          }, waitQueueTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        process.nextTick(() => processWaitQueue(this));
      }
      /**
       * Check a connection into the pool.
       *
       * @param {Connection} connection The connection to check in
       */
      checkIn(connection) {
        const poolClosed = this.closed;
        const stale = connectionIsStale(this, connection);
        const willDestroy = !!(poolClosed || stale || connection.closed);
        if (!willDestroy) {
          connection.markAvailable();
          this[kConnections].push(connection);
        }
        this.emit("connectionCheckedIn", new ConnectionCheckedInEvent(this, connection));
        if (willDestroy) {
          const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
          destroyConnection(this, connection, reason);
        }
        process.nextTick(() => processWaitQueue(this));
      }
      /**
       * Clear the pool
       *
       * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a
       * previous generation will eventually be pruned during subsequent checkouts.
       */
      clear() {
        this[kGeneration] += 1;
        this.emit("connectionPoolCleared", new ConnectionPoolClearedEvent(this));
      }
      /**
       * Close the pool
       *
       * @param {object} [options] Optional settings
       * @param {boolean} [options.force] Force close connections
       * @param {Function} callback
       */
      close(options, callback) {
        if (typeof options === "function") {
          callback = options;
        }
        options = Object.assign({ force: false }, options);
        if (this.closed) {
          return callback();
        }
        this[kCancellationToken].emit("cancel");
        while (this.waitQueueSize) {
          const waitQueueMember = this[kWaitQueue].pop();
          clearTimeout(waitQueueMember.timer);
          if (!waitQueueMember[kCancelled]) {
            waitQueueMember.callback(new MongoError("connection pool closed"));
          }
        }
        if (this[kMinPoolSizeTimer]) {
          clearTimeout(this[kMinPoolSizeTimer]);
        }
        if (typeof this[kConnectionCounter].return === "function") {
          this[kConnectionCounter].return();
        }
        this.closed = true;
        eachAsync(
          this[kConnections].toArray(),
          (conn, cb) => {
            this.emit("connectionClosed", new ConnectionClosedEvent(this, conn, "poolClosed"));
            conn.destroy(options, cb);
          },
          (err) => {
            this[kConnections].clear();
            this.emit("connectionPoolClosed", new ConnectionPoolClosedEvent(this));
            callback(err);
          }
        );
      }
      /**
       * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda
       * has completed by calling back.
       *
       * NOTE: please note the required signature of `fn`
       *
       * @param {ConnectionPool~withConnectionCallback} fn A function which operates on a managed connection
       * @param {Function} callback The original callback
       * @return {Promise}
       */
      withConnection(fn, callback) {
        this.checkOut((err, conn) => {
          fn(err, conn, (fnErr, result) => {
            if (typeof callback === "function") {
              if (fnErr) {
                callback(fnErr);
              } else {
                callback(void 0, result);
              }
            }
            if (conn) {
              this.checkIn(conn);
            }
          });
        });
      }
    };
    function ensureMinPoolSize(pool) {
      if (pool.closed || pool.options.minPoolSize === 0) {
        return;
      }
      const minPoolSize = pool.options.minPoolSize;
      for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {
        createConnection(pool);
      }
      pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool[kGeneration];
    }
    function connectionIsIdle(pool, connection) {
      return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);
    }
    function createConnection(pool, callback) {
      const connectOptions = Object.assign(
        {
          id: pool[kConnectionCounter].next().value,
          generation: pool[kGeneration]
        },
        pool.options
      );
      pool[kPermits]--;
      connect(connectOptions, pool[kCancellationToken], (err, connection) => {
        if (err) {
          pool[kPermits]++;
          pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.closed) {
          connection.destroy({ force: true });
          return;
        }
        relayEvents(connection, pool, [
          "commandStarted",
          "commandFailed",
          "commandSucceeded",
          "clusterTimeReceived"
        ]);
        pool.emit("connectionCreated", new ConnectionCreatedEvent(pool, connection));
        connection.markAvailable();
        pool.emit("connectionReady", new ConnectionReadyEvent(pool, connection));
        if (typeof callback === "function") {
          callback(void 0, connection);
          return;
        }
        pool[kConnections].push(connection);
        process.nextTick(() => processWaitQueue(pool));
      });
    }
    function destroyConnection(pool, connection, reason) {
      pool.emit("connectionClosed", new ConnectionClosedEvent(pool, connection, reason));
      pool[kPermits]++;
      process.nextTick(() => connection.destroy());
    }
    function processWaitQueue(pool) {
      if (pool.closed) {
        return;
      }
      while (pool.waitQueueSize) {
        const waitQueueMember = pool[kWaitQueue].peekFront();
        if (waitQueueMember[kCancelled]) {
          pool[kWaitQueue].shift();
          continue;
        }
        if (!pool.availableConnectionCount) {
          break;
        }
        const connection = pool[kConnections].shift();
        const isStale = connectionIsStale(pool, connection);
        const isIdle = connectionIsIdle(pool, connection);
        if (!isStale && !isIdle && !connection.closed) {
          pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          clearTimeout(waitQueueMember.timer);
          pool[kWaitQueue].shift();
          waitQueueMember.callback(void 0, connection);
          return;
        }
        const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
        destroyConnection(pool, connection, reason);
      }
      const maxPoolSize = pool.options.maxPoolSize;
      if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {
        createConnection(pool, (err, connection) => {
          const waitQueueMember = pool[kWaitQueue].shift();
          if (waitQueueMember == null || waitQueueMember[kCancelled]) {
            if (err == null) {
              pool[kConnections].push(connection);
            }
            return;
          }
          if (err) {
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, err));
          } else {
            pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          }
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(err, connection);
        });
        return;
      }
    }
    module2.exports = {
      ConnectionPool
    };
  }
});

// node_modules/mongodb/lib/core/sdam/monitor.js
var require_monitor = __commonJS({
  "node_modules/mongodb/lib/core/sdam/monitor.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var EventEmitter = __require("events");
    var connect = require_connect();
    var Connection2 = require_connection2().Connection;
    var common = require_common();
    var makeStateMachine = require_utils3().makeStateMachine;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = require_utils4().retrieveBSON();
    var makeInterruptableAsyncInterval = require_utils().makeInterruptableAsyncInterval;
    var calculateDurationInMs = require_utils().calculateDurationInMs;
    var now = require_utils().now;
    var sdamEvents = require_events();
    var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
    var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
    var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
    var kServer = Symbol("server");
    var kMonitorId = Symbol("monitorId");
    var kConnection = Symbol("connection");
    var kCancellationToken = Symbol("cancellationToken");
    var kRTTPinger = Symbol("rttPinger");
    var kRoundTripTime = Symbol("roundTripTime");
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_IDLE = "idle";
    var STATE_MONITORING = "monitoring";
    var stateTransition = makeStateMachine({
      [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],
      [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],
      [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],
      [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]
    });
    var INVALID_REQUEST_CHECK_STATES = /* @__PURE__ */ new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);
    function isInCloseState(monitor) {
      return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;
    }
    var Monitor = class extends EventEmitter {
      constructor(server, options) {
        super(options);
        this[kServer] = server;
        this[kConnection] = void 0;
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kMonitorId] = null;
        this.s = {
          state: STATE_CLOSED
        };
        this.address = server.description.address;
        this.options = Object.freeze({
          connectTimeoutMS: typeof options.connectionTimeout === "number" ? options.connectionTimeout : typeof options.connectTimeoutMS === "number" ? options.connectTimeoutMS : 1e4,
          heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === "number" ? options.heartbeatFrequencyMS : 1e4,
          minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === "number" ? options.minHeartbeatFrequencyMS : 500,
          useUnifiedTopology: options.useUnifiedTopology
        });
        const connectOptions = Object.assign(
          {
            id: "<monitor>",
            host: server.description.host,
            port: server.description.port,
            bson: server.s.bson,
            connectionType: Connection2
          },
          server.s.options,
          this.options,
          // force BSON serialization options
          {
            raw: false,
            promoteLongs: true,
            promoteValues: true,
            promoteBuffers: true,
            bsonRegExp: true
          }
        );
        delete connectOptions.credentials;
        delete connectOptions.autoEncrypter;
        this.connectOptions = Object.freeze(connectOptions);
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS,
          immediate: true
        });
      }
      requestCheck() {
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
          return;
        }
        this[kMonitorId].wake();
      }
      reset() {
        const topologyVersion = this[kServer].description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        stateTransition(this, STATE_IDLE);
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS
        });
      }
      close() {
        if (isInCloseState(this)) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        this.emit("close");
        stateTransition(this, STATE_CLOSED);
      }
    };
    function resetMonitorState(monitor) {
      if (monitor[kMonitorId]) {
        monitor[kMonitorId].stop();
        monitor[kMonitorId] = null;
      }
      if (monitor[kRTTPinger]) {
        monitor[kRTTPinger].close();
        monitor[kRTTPinger] = void 0;
      }
      monitor[kCancellationToken].emit("cancel");
      if (monitor[kMonitorId]) {
        clearTimeout(monitor[kMonitorId]);
        monitor[kMonitorId] = void 0;
      }
      if (monitor[kConnection]) {
        monitor[kConnection].destroy({ force: true });
      }
    }
    function checkServer(monitor, callback) {
      let start = now();
      monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
      function failureHandler(err) {
        if (monitor[kConnection]) {
          monitor[kConnection].destroy({ force: true });
          monitor[kConnection] = void 0;
        }
        monitor.emit(
          "serverHeartbeatFailed",
          new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address)
        );
        monitor.emit("resetServer", err);
        monitor.emit("resetConnectionPool");
        callback(err);
      }
      if (monitor[kConnection] != null && !monitor[kConnection].closed) {
        const connectTimeoutMS = monitor.options.connectTimeoutMS;
        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        const topologyVersion = monitor[kServer].description.topologyVersion;
        const isAwaitable = topologyVersion != null;
        const serverApi = monitor[kConnection].serverApi;
        const helloOk = monitor[kConnection].helloOk;
        const cmd = {
          [serverApi || helloOk ? "hello" : "ismaster"]: true
        };
        if (helloOk)
          cmd.helloOk = helloOk;
        const options = { socketTimeout: connectTimeoutMS };
        if (isAwaitable) {
          cmd.maxAwaitTimeMS = maxAwaitTimeMS;
          cmd.topologyVersion = makeTopologyVersion(topologyVersion);
          if (connectTimeoutMS) {
            options.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;
          }
          options.exhaustAllowed = true;
          if (monitor[kRTTPinger] == null) {
            monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);
          }
        }
        monitor[kConnection].command("admin.$cmd", cmd, options, (err, result) => {
          if (err) {
            failureHandler(err);
            return;
          }
          const isMaster = result.result;
          const rttPinger = monitor[kRTTPinger];
          if ("isWritablePrimary" in isMaster) {
            isMaster.ismaster = isMaster.isWritablePrimary;
          }
          const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);
          monitor.emit(
            "serverHeartbeatSucceeded",
            new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)
          );
          if (isAwaitable && isMaster.topologyVersion) {
            monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
            start = now();
          } else {
            if (monitor[kRTTPinger]) {
              monitor[kRTTPinger].close();
              monitor[kRTTPinger] = void 0;
            }
            callback(void 0, isMaster);
          }
        });
        return;
      }
      connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {
        if (conn && isInCloseState(monitor)) {
          conn.destroy({ force: true });
          return;
        }
        if (err) {
          monitor[kConnection] = void 0;
          if (!(err instanceof MongoNetworkError)) {
            monitor.emit("resetConnectionPool");
          }
          failureHandler(err);
          return;
        }
        monitor[kConnection] = conn;
        monitor.emit(
          "serverHeartbeatSucceeded",
          new ServerHeartbeatSucceededEvent(
            calculateDurationInMs(start),
            conn.ismaster,
            monitor.address
          )
        );
        callback(void 0, conn.ismaster);
      });
    }
    function monitorServer(monitor) {
      return (callback) => {
        stateTransition(monitor, STATE_MONITORING);
        function done() {
          if (!isInCloseState(monitor)) {
            stateTransition(monitor, STATE_IDLE);
          }
          callback();
        }
        process.nextTick(() => monitor.emit("monitoring", monitor[kServer]));
        checkServer(monitor, (err, isMaster) => {
          if (err) {
            if (monitor[kServer].description.type === ServerType.Unknown) {
              monitor.emit("resetServer", err);
              return done();
            }
          }
          if (isMaster && isMaster.topologyVersion) {
            setTimeout(() => {
              if (!isInCloseState(monitor)) {
                monitor[kMonitorId].wake();
              }
            });
          }
          done();
        });
      };
    }
    function makeTopologyVersion(tv) {
      return {
        processId: tv.processId,
        counter: BSON2.Long.fromNumber(tv.counter)
      };
    }
    var RTTPinger = class {
      constructor(cancellationToken, options) {
        this[kConnection] = null;
        this[kCancellationToken] = cancellationToken;
        this[kRoundTripTime] = 0;
        this.closed = false;
        const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
        this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);
      }
      get roundTripTime() {
        return this[kRoundTripTime];
      }
      close() {
        this.closed = true;
        clearTimeout(this[kMonitorId]);
        this[kMonitorId] = void 0;
        if (this[kConnection]) {
          this[kConnection].destroy({ force: true });
        }
      }
    };
    function measureRoundTripTime(rttPinger, options) {
      const start = now();
      const cancellationToken = rttPinger[kCancellationToken];
      const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
      if (rttPinger.closed) {
        return;
      }
      function measureAndReschedule(conn) {
        if (rttPinger.closed) {
          conn.destroy({ force: true });
          return;
        }
        if (rttPinger[kConnection] == null) {
          rttPinger[kConnection] = conn;
        }
        rttPinger[kRoundTripTime] = calculateDurationInMs(start);
        rttPinger[kMonitorId] = setTimeout(
          () => measureRoundTripTime(rttPinger, options),
          heartbeatFrequencyMS
        );
      }
      if (rttPinger[kConnection] == null) {
        connect(options, cancellationToken, (err, conn) => {
          if (err) {
            rttPinger[kConnection] = void 0;
            rttPinger[kRoundTripTime] = 0;
            return;
          }
          measureAndReschedule(conn);
        });
        return;
      }
      rttPinger[kConnection].command("admin.$cmd", { ismaster: 1 }, (err) => {
        if (err) {
          rttPinger[kConnection] = void 0;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule();
      });
    }
    module2.exports = {
      Monitor
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server.js
var require_server2 = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = __require("events");
    var ConnectionPool = require_connection_pool().ConnectionPool;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var MongoError = require_error().MongoError;
    var relayEvents = require_utils3().relayEvents;
    var BSON2 = require_utils4().retrieveBSON();
    var Logger = require_logger();
    var ServerDescription = require_server_description().ServerDescription;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var ReadPreference = require_read_preference();
    var Monitor = require_monitor().Monitor;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var collationNotSupported = require_utils3().collationNotSupported;
    var debugOptions = require_utils4().debugOptions;
    var isSDAMUnrecoverableError = require_error().isSDAMUnrecoverableError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var isNodeShuttingDownError = require_error().isNodeShuttingDownError;
    var isNetworkErrorBeforeHandshake = require_error().isNetworkErrorBeforeHandshake;
    var maxWireVersion = require_utils3().maxWireVersion;
    var makeStateMachine = require_utils3().makeStateMachine;
    var extractCommand = require_command_utils().extractCommand;
    var common = require_common();
    var ServerType = common.ServerType;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var DEBUG_FIELDS = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "servername"
    ];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var kMonitor = Symbol("monitor");
    var Server = class extends EventEmitter {
      /**
       * Create a server
       *
       * @param {ServerDescription} description
       * @param {Object} options
       */
      constructor(description, options, topology) {
        super();
        this.s = {
          // the server description
          description,
          // a saved copy of the incoming options
          options,
          // the server logger
          logger: Logger("Server", options),
          // the bson parser
          bson: options.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          // the server state
          state: STATE_CLOSED,
          credentials: options.credentials,
          topology
        };
        this.serverApi = options.serverApi;
        const poolOptions = Object.assign(
          { host: this.description.host, port: this.description.port, bson: this.s.bson },
          options
        );
        this.s.pool = new ConnectionPool(poolOptions);
        relayEvents(
          this.s.pool,
          this,
          ["commandStarted", "commandSucceeded", "commandFailed"].concat(CMAP_EVENT_NAMES)
        );
        this.s.pool.on("clusterTimeReceived", (clusterTime) => {
          this.clusterTime = clusterTime;
        });
        this[kMonitor] = new Monitor(this, this.s.options);
        relayEvents(this[kMonitor], this, [
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          // legacy events
          "monitoring"
        ]);
        this[kMonitor].on("resetConnectionPool", () => {
          this.s.pool.clear();
        });
        this[kMonitor].on("resetServer", (error) => markServerUnknown(this, error));
        this[kMonitor].on("serverHeartbeatSucceeded", (event) => {
          this.emit(
            "descriptionReceived",
            new ServerDescription(this.description.address, event.reply, {
              roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
            })
          );
          if (this.s.state === STATE_CONNECTING) {
            stateTransition(this, STATE_CONNECTED);
            this.emit("connect", this);
          }
        });
      }
      get description() {
        return this.s.description;
      }
      get supportsRetryableWrites() {
        return supportsRetryableWrites(this);
      }
      get name() {
        return this.s.description.address;
      }
      get autoEncrypter() {
        if (this.s.options && this.s.options.autoEncrypter) {
          return this.s.options.autoEncrypter;
        }
        return null;
      }
      /**
       * Initiate server connect
       */
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this[kMonitor].connect();
      }
      /**
       * Destroy the server connection
       *
       * @param {object} [options] Optional settings
       * @param {Boolean} [options.force=false] Force destroy the pool
       */
      destroy(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = Object.assign({}, { force: false }, options);
        if (this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        this[kMonitor].close();
        this.s.pool.close(options, (err) => {
          stateTransition(this, STATE_CLOSED);
          this.emit("closed");
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      /**
       * Immediately schedule monitoring of this server. If there already an attempt being made
       * this will be a no-op.
       */
      requestCheck() {
        this[kMonitor].requestCheck();
      }
      /**
       * Execute a command
       *
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {object} cmd The command hash
       * @param {object} [options] Optional settings
       * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
       * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
       * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.
       * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
       * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.
       * @param {ClientSession} [options.session] Session to use for the operation
       * @param {opResultCallback} callback A callback function
       */
      command(ns, cmd, options, callback) {
        if (typeof options === "function") {
          callback = options, options = {}, options = options || {};
        }
        options.serverApi = this.serverApi;
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        const error = basicReadValidations(this, options);
        if (error) {
          return callback(error);
        }
        options = Object.assign({}, options, { wireProtocolCommand: false });
        if (this.s.logger.isDebug()) {
          const extractedCommand = extractCommand(cmd);
          this.s.logger.debug(
            `executing command [${JSON.stringify({
              ns,
              cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,
              options: debugOptions(DEBUG_FIELDS, options)
            })}] against ${this.name}`
          );
        }
        if (collationNotSupported(this, cmd)) {
          callback(new MongoError(`server ${this.name} does not support collation`));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.command(ns, cmd, options, makeOperationHandler(this, conn, cmd, options, cb));
        }, callback);
      }
      /**
       * Execute a query against the server
       *
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {object} cmd The command document for the query
       * @param {object} options Optional settings
       * @param {function} callback
       */
      query(ns, cmd, cursorState, options, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.query(ns, cmd, cursorState, options, makeOperationHandler(this, conn, cmd, options, cb));
        }, callback);
      }
      /**
       * Execute a `getMore` against the server
       *
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {object} cursorState State data associated with the cursor calling this method
       * @param {object} options Optional settings
       * @param {function} callback
       */
      getMore(ns, cursorState, batchSize, options, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.getMore(
            ns,
            cursorState,
            batchSize,
            options,
            makeOperationHandler(this, conn, null, options, cb)
          );
        }, callback);
      }
      /**
       * Execute a `killCursors` command against the server
       *
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {object} cursorState State data associated with the cursor calling this method
       * @param {function} callback
       */
      killCursors(ns, cursorState, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback(new MongoError("server is closed"));
          }
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, void 0, cb));
        }, callback);
      }
      /**
       * Insert one or more documents
       * @method
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {array} ops An array of documents to insert
       * @param {boolean} [options.ordered=true] Execute in order or out of order
       * @param {object} [options.writeConcern={}] Write concern for the operation
       * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
       * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
       * @param {ClientSession} [options.session] Session to use for the operation
       * @param {opResultCallback} callback A callback function
       */
      insert(ns, ops, options, callback) {
        executeWriteOperation({ server: this, op: "insert", ns, ops }, options, callback);
      }
      /**
       * Perform one or more update operations
       * @method
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {array} ops An array of updates
       * @param {boolean} [options.ordered=true] Execute in order or out of order
       * @param {object} [options.writeConcern={}] Write concern for the operation
       * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
       * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
       * @param {ClientSession} [options.session] Session to use for the operation
       * @param {opResultCallback} callback A callback function
       */
      update(ns, ops, options, callback) {
        executeWriteOperation({ server: this, op: "update", ns, ops }, options, callback);
      }
      /**
       * Perform one or more remove operations
       * @method
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {array} ops An array of removes
       * @param {boolean} [options.ordered=true] Execute in order or out of order
       * @param {object} [options.writeConcern={}] Write concern for the operation
       * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
       * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
       * @param {ClientSession} [options.session] Session to use for the operation
       * @param {opResultCallback} callback A callback function
       */
      remove(ns, ops, options, callback) {
        executeWriteOperation({ server: this, op: "remove", ns, ops }, options, callback);
      }
    };
    Object.defineProperty(Server.prototype, "clusterTime", {
      get: function() {
        return this.s.topology.clusterTime;
      },
      set: function(clusterTime) {
        this.s.topology.clusterTime = clusterTime;
      }
    });
    function supportsRetryableWrites(server) {
      return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;
    }
    function calculateRoundTripTime(oldRtt, duration) {
      if (oldRtt === -1) {
        return duration;
      }
      const alpha = 0.2;
      return alpha * duration + (1 - alpha) * oldRtt;
    }
    function basicReadValidations(server, options) {
      if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
        return new MongoError("readPreference must be an instance of ReadPreference");
      }
    }
    function executeWriteOperation(args, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const server = args.server;
      const op = args.op;
      const ns = args.ns;
      const ops = Array.isArray(args.ops) ? args.ops : [args.ops];
      if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      if (collationNotSupported(server, options)) {
        callback(new MongoError(`server ${server.name} does not support collation`));
        return;
      }
      const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;
      if (unacknowledgedWrite || maxWireVersion(server) < 5) {
        if ((op === "update" || op === "remove") && ops.find((o) => o.hint)) {
          callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));
          return;
        }
      }
      server.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(server, err);
          return cb(err);
        }
        conn[op](ns, ops, options, makeOperationHandler(server, conn, ops, options, cb));
      }, callback);
    }
    function markServerUnknown(server, error) {
      if (error instanceof MongoNetworkError && !(error instanceof MongoNetworkTimeoutError)) {
        server[kMonitor].reset();
      }
      server.emit(
        "descriptionReceived",
        new ServerDescription(server.description.address, null, {
          error,
          topologyVersion: error && error.topologyVersion ? error.topologyVersion : server.description.topologyVersion
        })
      );
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool.generation;
    }
    function shouldHandleStateChangeError(server, err) {
      const etv = err.topologyVersion;
      const stv = server.description.topologyVersion;
      return compareTopologyVersion(stv, etv) < 0;
    }
    function inActiveTransaction(session, cmd) {
      return session && session.inTransaction() && !isTransactionCommand(cmd);
    }
    function makeOperationHandler(server, connection, cmd, options, callback) {
      const session = options && options.session;
      return function handleOperationResult(err, result) {
        if (err && !connectionIsStale(server.s.pool, connection)) {
          if (err instanceof MongoNetworkError) {
            if (session && !session.hasEnded) {
              session.serverSession.isDirty = true;
            }
            if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {
              markServerUnknown(server, err);
              server.s.pool.clear();
            }
          } else {
            if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (isSDAMUnrecoverableError(err)) {
              if (shouldHandleStateChangeError(server, err)) {
                if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {
                  server.s.pool.clear();
                }
                markServerUnknown(server, err);
                process.nextTick(() => server.requestCheck());
              }
            }
          }
        }
        callback(err, result);
      };
    }
    module2.exports = {
      Server
    };
  }
});

// node_modules/mongodb/lib/core/sdam/srv_polling.js
var require_srv_polling = __commonJS({
  "node_modules/mongodb/lib/core/sdam/srv_polling.js"(exports2, module2) {
    "use strict";
    var Logger = require_logger();
    var EventEmitter = __require("events").EventEmitter;
    var dns = __require("dns");
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    var SrvPollingEvent = class {
      constructor(srvRecords) {
        this.srvRecords = srvRecords;
      }
      addresses() {
        return new Set(this.srvRecords.map((record) => `${record.name}:${record.port}`));
      }
    };
    var SrvPoller = class extends EventEmitter {
      /**
       * @param {object} options
       * @param {string} options.srvHost
       * @param {number} [options.heartbeatFrequencyMS]
       * @param {function} [options.logger]
       * @param {string} [options.loggerLevel]
       */
      constructor(options) {
        super();
        if (!options || !options.srvHost) {
          throw new TypeError("options for SrvPoller must exist and include srvHost");
        }
        this.srvHost = options.srvHost;
        this.rescanSrvIntervalMS = 6e4;
        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 1e4;
        this.logger = Logger("srvPoller", options);
        this.haMode = false;
        this.generation = 0;
        this._timeout = null;
      }
      get srvAddress() {
        return `_mongodb._tcp.${this.srvHost}`;
      }
      get intervalMS() {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
      }
      start() {
        if (!this._timeout) {
          this.schedule();
        }
      }
      stop() {
        if (this._timeout) {
          clearTimeout(this._timeout);
          this.generation += 1;
          this._timeout = null;
        }
      }
      schedule() {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => this._poll(), this.intervalMS);
      }
      success(srvRecords) {
        this.haMode = false;
        this.schedule();
        this.emit("srvRecordDiscovery", new SrvPollingEvent(srvRecords));
      }
      failure(message, obj) {
        this.logger.warn(message, obj);
        this.haMode = true;
        this.schedule();
      }
      parentDomainMismatch(srvRecord) {
        this.logger.warn(
          `parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`,
          srvRecord
        );
      }
      _poll() {
        const generation = this.generation;
        dns.resolveSrv(this.srvAddress, (err, srvRecords) => {
          if (generation !== this.generation) {
            return;
          }
          if (err) {
            this.failure("DNS error", err);
            return;
          }
          const finalAddresses = [];
          srvRecords.forEach((record) => {
            if (matchesParentDomain(record.name, this.srvHost)) {
              finalAddresses.push(record);
            } else {
              this.parentDomainMismatch(record);
            }
          });
          if (!finalAddresses.length) {
            this.failure("No valid addresses found at host");
            return;
          }
          this.success(finalAddresses);
        });
      }
    };
    module2.exports.SrvPollingEvent = SrvPollingEvent;
    module2.exports.SrvPoller = SrvPoller;
  }
});

// node_modules/mongodb/lib/core/sdam/server_selection.js
var require_server_selection = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_selection.js"(exports2, module2) {
    "use strict";
    var ServerType = require_common().ServerType;
    var TopologyType = require_common().TopologyType;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var IDLE_WRITE_PERIOD = 1e4;
    var SMALLEST_MAX_STALENESS_SECONDS = 90;
    function writableServerSelector() {
      return function(topologyDescription, servers) {
        return latencyWindowReducer(
          topologyDescription,
          servers.filter((s) => s.isWritable)
        );
      };
    }
    function maxStalenessReducer(readPreference, topologyDescription, servers) {
      if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
        return servers;
      }
      const maxStaleness = readPreference.maxStalenessSeconds;
      const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
      if (maxStaleness < maxStalenessVariance) {
        throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);
      }
      if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
        throw new MongoError(
          `maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`
        );
      }
      if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {
        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
        return servers.reduce((result, server) => {
          const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {
        if (servers.length === 0) {
          return servers;
        }
        const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
        return servers.reduce((result, server) => {
          const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      return servers;
    }
    function tagSetMatch(tagSet, serverTags) {
      const keys = Object.keys(tagSet);
      const serverTagKeys = Object.keys(serverTags);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
          return false;
        }
      }
      return true;
    }
    function tagSetReducer(readPreference, servers) {
      if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
        return servers;
      }
      for (let i = 0; i < readPreference.tags.length; ++i) {
        const tagSet = readPreference.tags[i];
        const serversMatchingTagset = servers.reduce((matched, server) => {
          if (tagSetMatch(tagSet, server.tags))
            matched.push(server);
          return matched;
        }, []);
        if (serversMatchingTagset.length) {
          return serversMatchingTagset;
        }
      }
      return [];
    }
    function latencyWindowReducer(topologyDescription, servers) {
      const low = servers.reduce(
        (min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min),
        -1
      );
      const high = low + topologyDescription.localThresholdMS;
      return servers.reduce((result, server) => {
        if (server.roundTripTime <= high && server.roundTripTime >= low)
          result.push(server);
        return result;
      }, []);
    }
    function primaryFilter(server) {
      return server.type === ServerType.RSPrimary;
    }
    function secondaryFilter(server) {
      return server.type === ServerType.RSSecondary;
    }
    function nearestFilter(server) {
      return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
    }
    function knownFilter(server) {
      return server.type !== ServerType.Unknown;
    }
    function readPreferenceServerSelector(readPreference) {
      if (!readPreference.isValid()) {
        throw new TypeError("Invalid read preference specified");
      }
      return function(topologyDescription, servers) {
        const commonWireVersion = topologyDescription.commonWireVersion;
        if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
          throw new MongoError(
            `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`
          );
        }
        if (topologyDescription.type === TopologyType.Unknown) {
          return [];
        }
        if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {
          return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
        }
        const mode = readPreference.mode;
        if (mode === ReadPreference.PRIMARY) {
          return servers.filter(primaryFilter);
        }
        if (mode === ReadPreference.PRIMARY_PREFERRED) {
          const result = servers.filter(primaryFilter);
          if (result.length) {
            return result;
          }
        }
        const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
        const selectedServers = latencyWindowReducer(
          topologyDescription,
          tagSetReducer(
            readPreference,
            maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))
          )
        );
        if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
          return servers.filter(primaryFilter);
        }
        return selectedServers;
      };
    }
    module2.exports = {
      writableServerSelector,
      readPreferenceServerSelector
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology.js
var require_topology = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = __require("events");
    var ServerDescription = require_server_description().ServerDescription;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var TopologyType = require_common().TopologyType;
    var events = require_events();
    var Server = require_server2().Server;
    var relayEvents = require_utils3().relayEvents;
    var ReadPreference = require_read_preference();
    var CoreCursor = require_cursor().CoreCursor;
    var deprecate = __require("util").deprecate;
    var BSON2 = require_utils4().retrieveBSON();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var ClientSession = require_sessions().ClientSession;
    var MongoError = require_error().MongoError;
    var MongoServerSelectionError = require_error().MongoServerSelectionError;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SrvPoller = require_srv_polling().SrvPoller;
    var getMMAPError = require_shared2().getMMAPError;
    var makeStateMachine = require_utils3().makeStateMachine;
    var eachAsync = require_utils3().eachAsync;
    var emitDeprecationWarning = require_utils().emitDeprecationWarning;
    var ServerSessionPool = require_sessions().ServerSessionPool;
    var makeClientMetadata = require_utils3().makeClientMetadata;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var emitWarning = require_utils().emitWarning;
    var common = require_common();
    var drainTimerQueue = common.drainTimerQueue;
    var clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;
    var serverSelection = require_server_selection();
    var readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;
    var writableServerSelector = serverSelection.writableServerSelector;
    var globalTopologyCounter = 0;
    var SERVER_RELAY_EVENTS = [
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      // NOTE: Legacy events
      "monitoring"
    ].concat(CMAP_EVENT_NAMES);
    var LOCAL_SERVER_EVENTS = ["connect", "descriptionReceived", "close", "ended"];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var DEPRECATED_OPTIONS = /* @__PURE__ */ new Set([
      "autoReconnect",
      "reconnectTries",
      "reconnectInterval",
      "bufferMaxEntries"
    ]);
    var kCancelled = Symbol("cancelled");
    var kWaitQueue = Symbol("waitQueue");
    var Topology = class extends EventEmitter {
      /**
       * Create a topology
       *
       * @param {Array|String} [seedlist] a string list, or array of Server instances to connect to
       * @param {Object} [options] Optional settings
       * @param {Number} [options.localThresholdMS=15] The size of the latency window for selecting among multiple suitable servers
       * @param {Number} [options.serverSelectionTimeoutMS=30000] How long to block for server selection before throwing an error
       * @param {Number} [options.heartbeatFrequencyMS=10000] The frequency with which topology updates are scheduled
       */
      constructor(seedlist, options) {
        super();
        if (typeof options === "undefined" && typeof seedlist !== "string") {
          options = seedlist;
          seedlist = [];
          if (options.host) {
            seedlist.push({ host: options.host, port: options.port });
          }
        }
        seedlist = seedlist || [];
        if (typeof seedlist === "string") {
          seedlist = parseStringSeedlist(seedlist);
        }
        options = Object.assign({}, common.TOPOLOGY_DEFAULTS, options);
        options = Object.freeze(
          Object.assign(options, {
            metadata: makeClientMetadata(options),
            compression: { compressors: createCompressionInfo(options) }
          })
        );
        DEPRECATED_OPTIONS.forEach((optionName) => {
          if (options[optionName]) {
            emitDeprecationWarning(
              `The option \`${optionName}\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`,
              "DeprecationWarning"
            );
          }
        });
        const topologyType = topologyTypeFromSeedlist(seedlist, options);
        const topologyId = globalTopologyCounter++;
        const serverDescriptions = seedlist.reduce((result, seed) => {
          if (seed.domain_socket)
            seed.host = seed.domain_socket;
          const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;
          result.set(address, new ServerDescription(address));
          return result;
        }, /* @__PURE__ */ new Map());
        this[kWaitQueue] = new Denque();
        this.s = {
          // the id of this topology
          id: topologyId,
          // passed in options
          options,
          // initial seedlist of servers to connect to
          seedlist,
          // initial state
          state: STATE_CLOSED,
          // the topology description
          description: new TopologyDescription(
            topologyType,
            serverDescriptions,
            options.replicaSet,
            null,
            null,
            null,
            options
          ),
          serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
          heartbeatFrequencyMS: options.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
          // allow users to override the cursor factory
          Cursor: options.cursorFactory || CoreCursor,
          // the bson parser
          bson: options.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          // a map of server instances to normalized addresses
          servers: /* @__PURE__ */ new Map(),
          // Server Session Pool
          sessionPool: new ServerSessionPool(this),
          // Active client sessions
          sessions: /* @__PURE__ */ new Set(),
          // Promise library
          promiseLibrary: options.promiseLibrary || Promise,
          credentials: options.credentials,
          clusterTime: null,
          // timer management
          connectionTimers: /* @__PURE__ */ new Set()
        };
        this.serverApi = options.serverApi;
        if (options.srvHost) {
          this.s.srvPoller = options.srvPoller || new SrvPoller({
            heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
            srvHost: options.srvHost,
            // TODO: GET THIS
            logger: options.logger,
            loggerLevel: options.loggerLevel
          });
          this.s.detectTopologyDescriptionChange = (ev) => {
            const previousType = ev.previousDescription.type;
            const newType = ev.newDescription.type;
            if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {
              this.s.handleSrvPolling = srvPollingHandler(this);
              this.s.srvPoller.on("srvRecordDiscovery", this.s.handleSrvPolling);
              this.s.srvPoller.start();
            }
          };
          this.on("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
        }
        this.setMaxListeners(Infinity);
      }
      /**
       * @return A `TopologyDescription` for this topology
       */
      get description() {
        return this.s.description;
      }
      get parserType() {
        return BSON2.native ? "c++" : "js";
      }
      /**
       * Initiate server connect
       *
       * @param {Object} [options] Optional settings
       * @param {Array} [options.auth=null] Array of auth options to apply on connect
       * @param {function} [callback] An optional callback called once on the first connected server
       */
      connect(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options || {};
        if (this.s.state === STATE_CONNECTED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this.emit("topologyOpening", new events.TopologyOpeningEvent(this.s.id));
        this.emit(
          "topologyDescriptionChanged",
          new events.TopologyDescriptionChangedEvent(
            this.s.id,
            new TopologyDescription(TopologyType.Unknown),
            // initial is always Unknown
            this.s.description
          )
        );
        connectServers(this, Array.from(this.s.description.servers.values()));
        ReadPreference.translate(options);
        const readPreference = options.readPreference || ReadPreference.primary;
        const connectHandler = (err) => {
          if (err) {
            this.close();
            if (typeof callback === "function") {
              callback(err);
            } else {
              this.emit("error", err);
            }
            return;
          }
          stateTransition(this, STATE_CONNECTED);
          this.emit("open", err, this);
          this.emit("connect", this);
          if (typeof callback === "function")
            callback(err, this);
        };
        if (this.s.credentials) {
          this.command("admin.$cmd", { ping: 1 }, { readPreference }, connectHandler);
          return;
        }
        this.selectServer(readPreferenceServerSelector(readPreference), options, connectHandler);
      }
      /**
       * Close this topology
       */
      close(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (typeof options === "boolean") {
          options = { force: options };
        }
        options = options || {};
        if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        drainWaitQueue(this[kWaitQueue], new MongoError("Topology closed"));
        drainTimerQueue(this.s.connectionTimers);
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          if (this.s.handleSrvPolling) {
            this.s.srvPoller.removeListener("srvRecordDiscovery", this.s.handleSrvPolling);
            delete this.s.handleSrvPolling;
          }
        }
        if (this.s.detectTopologyDescriptionChange) {
          this.removeListener("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
          delete this.s.detectTopologyDescriptionChange;
        }
        this.s.sessions.forEach((session) => session.endSession());
        this.s.sessionPool.endAllPooledSessions(() => {
          eachAsync(
            Array.from(this.s.servers.values()),
            (server, cb) => destroyServer(server, this, options, cb),
            (err) => {
              this.s.servers.clear();
              this.emit("topologyClosed", new events.TopologyClosedEvent(this.s.id));
              stateTransition(this, STATE_CLOSED);
              if (typeof callback === "function") {
                callback(err);
              }
            }
          );
        });
      }
      /**
       * Selects a server according to the selection predicate provided
       *
       * @param {function} [selector] An optional selector to select servers by, defaults to a random selection within a latency window
       * @param {object} [options] Optional settings related to server selection
       * @param {number} [options.serverSelectionTimeoutMS] How long to block for server selection before throwing an error
       * @param {function} callback The callback used to indicate success or failure
       * @return {Server} An instance of a `Server` meeting the criteria of the predicate provided
       */
      selectServer(selector, options, callback) {
        if (typeof options === "function") {
          callback = options;
          if (typeof selector !== "function") {
            options = selector;
            let readPreference;
            if (selector instanceof ReadPreference) {
              readPreference = selector;
            } else if (typeof selector === "string") {
              readPreference = new ReadPreference(selector);
            } else {
              ReadPreference.translate(options);
              readPreference = options.readPreference || ReadPreference.primary;
            }
            selector = readPreferenceServerSelector(readPreference);
          } else {
            options = {};
          }
        }
        options = Object.assign(
          {},
          { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS },
          options
        );
        const isSharded = this.description.type === TopologyType.Sharded;
        const session = options.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
          callback(void 0, transaction.server);
          return;
        }
        let serverSelector = selector;
        if (typeof selector === "object") {
          const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;
          serverSelector = readPreferenceServerSelector(readPreference);
        }
        const waitQueueMember = {
          serverSelector,
          transaction,
          callback
        };
        const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
        if (serverSelectionTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            const timeoutError = new MongoServerSelectionError(
              `Server selection timed out after ${serverSelectionTimeoutMS} ms`,
              this.description
            );
            waitQueueMember.callback(timeoutError);
          }, serverSelectionTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        processWaitQueue(this);
      }
      // Sessions related methods
      /**
       * @return Whether the topology should initiate selection to determine session support
       */
      shouldCheckForSessionSupport() {
        if (this.description.type === TopologyType.Single) {
          return !this.description.hasKnownServers;
        }
        return !this.description.hasDataBearingServers;
      }
      /**
       * @return Whether sessions are supported on the current topology
       */
      hasSessionSupport() {
        return this.description.logicalSessionTimeoutMinutes != null;
      }
      /**
       * Start a logical session
       */
      startSession(options, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      /**
       * Send endSessions command(s) with the given session ids
       *
       * @param {Array} sessions The sessions to end
       * @param {function} [callback]
       */
      endSessions(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command(
          "admin.$cmd",
          { endSessions: sessions },
          {
            readPreference: ReadPreference.primaryPreferred,
            noResponse: true,
            serverApi: this.serverApi
          },
          () => {
            if (typeof callback === "function")
              callback();
          }
        );
      }
      /**
       * Update the internal TopologyDescription with a ServerDescription
       *
       * @param {object} serverDescription The server to update in the internal list of server descriptions
       */
      serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
          return;
        }
        if (isStaleServerDescription(this.s.description, serverDescription)) {
          return;
        }
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
          resolveClusterTime(this, clusterTime);
        }
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
          this.emit("error", new MongoError(this.s.description.compatibilityError));
          return;
        }
        if (!equalDescriptions) {
          this.emit(
            "serverDescriptionChanged",
            new events.ServerDescriptionChangedEvent(
              this.s.id,
              serverDescription.address,
              previousServerDescription,
              this.s.description.servers.get(serverDescription.address)
            )
          );
        }
        updateServers(this, serverDescription);
        if (this[kWaitQueue].length > 0) {
          processWaitQueue(this);
        }
        if (!equalDescriptions) {
          this.emit(
            "topologyDescriptionChanged",
            new events.TopologyDescriptionChangedEvent(
              this.s.id,
              previousTopologyDescription,
              this.s.description
            )
          );
        }
      }
      auth(credentials, callback) {
        if (typeof credentials === "function")
          callback = credentials, credentials = null;
        if (typeof callback === "function")
          callback(null, true);
      }
      logout(callback) {
        if (typeof callback === "function")
          callback(null, true);
      }
      // Basic operation support. Eventually this should be moved into command construction
      // during the command refactor.
      /**
       * Insert one or more documents
       *
       * @param {String} ns The full qualified namespace for this operation
       * @param {Array} ops An array of documents to insert
       * @param {Boolean} [options.ordered=true] Execute in order or out of order
       * @param {Object} [options.writeConcern] Write concern for the operation
       * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized
       * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields
       * @param {ClientSession} [options.session] Session to use for the operation
       * @param {boolean} [options.retryWrites] Enable retryable writes for this operation
       * @param {opResultCallback} callback A callback function
       */
      insert(ns, ops, options, callback) {
        executeWriteOperation({ topology: this, op: "insert", ns, ops }, options, callback);
      }
      /**
       * Perform one or more update operations
       *
       * @param {string} ns The fully qualified namespace for this operation
       * @param {array} ops An array of updates
       * @param {boolean} [options.ordered=true] Execute in order or out of order
       * @param {object} [options.writeConcern] Write concern for the operation
       * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized
       * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields
       * @param {ClientSession} [options.session] Session to use for the operation
       * @param {boolean} [options.retryWrites] Enable retryable writes for this operation
       * @param {opResultCallback} callback A callback function
       */
      update(ns, ops, options, callback) {
        executeWriteOperation({ topology: this, op: "update", ns, ops }, options, callback);
      }
      /**
       * Perform one or more remove operations
       *
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {array} ops An array of removes
       * @param {boolean} [options.ordered=true] Execute in order or out of order
       * @param {object} [options.writeConcern={}] Write concern for the operation
       * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
       * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
       * @param {ClientSession} [options.session=null] Session to use for the operation
       * @param {boolean} [options.retryWrites] Enable retryable writes for this operation
       * @param {opResultCallback} callback A callback function
       */
      remove(ns, ops, options, callback) {
        executeWriteOperation({ topology: this, op: "remove", ns, ops }, options, callback);
      }
      /**
       * Execute a command
       *
       * @method
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {object} cmd The command hash
       * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
       * @param {Connection} [options.connection] Specify connection object to execute command against
       * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
       * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
       * @param {ClientSession} [options.session=null] Session to use for the operation
       * @param {opResultCallback} callback A callback function
       */
      command(ns, cmd, options, callback) {
        if (typeof options === "function") {
          callback = options, options = {}, options = options || {};
        }
        ReadPreference.translate(options);
        const readPreference = options.readPreference || ReadPreference.primary;
        this.selectServer(readPreferenceServerSelector(readPreference), options, (err, server) => {
          if (err) {
            callback(err);
            return;
          }
          const notAlreadyRetrying = !options.retrying;
          const retryWrites = !!options.retryWrites;
          const hasSession = !!options.session;
          const supportsRetryableWrites = server.supportsRetryableWrites;
          const notInTransaction = !hasSession || !options.session.inTransaction();
          const willRetryWrite = notAlreadyRetrying && retryWrites && hasSession && supportsRetryableWrites && notInTransaction && isWriteCommand(cmd);
          const cb = (err2, result) => {
            if (!err2)
              return callback(null, result);
            if (!shouldRetryOperation(err2)) {
              return callback(err2);
            }
            if (willRetryWrite) {
              const newOptions = Object.assign({}, options, { retrying: true });
              return this.command(ns, cmd, newOptions, callback);
            }
            return callback(err2);
          };
          if (willRetryWrite) {
            options.session.incrementTransactionNumber();
            options.willRetryWrite = willRetryWrite;
          }
          server.command(ns, cmd, options, cb);
        });
      }
      /**
       * Create a new cursor
       *
       * @method
       * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
       * @param {object|Long} cmd Can be either a command returning a cursor or a cursorId
       * @param {object} [options] Options for the cursor
       * @param {object} [options.batchSize=0] Batchsize for the operation
       * @param {array} [options.documents=[]] Initial documents list for cursor
       * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
       * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
       * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
       * @param {ClientSession} [options.session=null] Session to use for the operation
       * @param {object} [options.topology] The internal topology of the created cursor
       * @returns {Cursor}
       */
      cursor(ns, cmd, options) {
        options = options || {};
        const topology = options.topology || this;
        const CursorClass = options.cursorFactory || this.s.Cursor;
        ReadPreference.translate(options);
        return new CursorClass(topology, ns, cmd, options);
      }
      get clientMetadata() {
        return this.s.options.metadata;
      }
      isConnected() {
        return this.s.state === STATE_CONNECTED;
      }
      isDestroyed() {
        return this.s.state === STATE_CLOSED;
      }
      /**
       * @deprecated This function is deprecated and will be removed in the next major version.
       */
      unref() {
        emitWarning("`unref` is a noop and will be removed in the next major version");
      }
      // NOTE: There are many places in code where we explicitly check the last isMaster
      //       to do feature support detection. This should be done any other way, but for
      //       now we will just return the first isMaster seen, which should suffice.
      lastIsMaster() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
          return {};
        const sd = serverDescriptions.filter((sd2) => sd2.type !== ServerType.Unknown)[0];
        const result = sd || { maxWireVersion: this.description.commonWireVersion };
        return result;
      }
      get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
      }
      get bson() {
        return this.s.bson;
      }
    };
    Object.defineProperty(Topology.prototype, "clusterTime", {
      enumerable: true,
      get: function() {
        return this.s.clusterTime;
      },
      set: function(clusterTime) {
        this.s.clusterTime = clusterTime;
      }
    });
    Topology.prototype.destroy = deprecate(
      Topology.prototype.close,
      "destroy() is deprecated, please use close() instead"
    );
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    function isStaleServerDescription(topologyDescription, incomingServerDescription) {
      const currentServerDescription = topologyDescription.servers.get(
        incomingServerDescription.address
      );
      const currentTopologyVersion = currentServerDescription.topologyVersion;
      return compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
    }
    function destroyServer(server, topology, options, callback) {
      options = options || {};
      LOCAL_SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options, () => {
        topology.emit(
          "serverClosed",
          new events.ServerClosedEvent(topology.s.id, server.description.address)
        );
        SERVER_RELAY_EVENTS.forEach((event) => server.removeAllListeners(event));
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    function parseStringSeedlist(seedlist) {
      return seedlist.split(",").map((seed) => ({
        host: seed.split(":")[0],
        port: seed.split(":")[1] || 27017
      }));
    }
    function topologyTypeFromSeedlist(seedlist, options) {
      if (options.directConnection) {
        return TopologyType.Single;
      }
      const replicaSet = options.replicaSet || options.setName || options.rs_name;
      if (replicaSet == null) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function randomSelection(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    function createAndConnectServer(topology, serverDescription, connectDelay) {
      topology.emit(
        "serverOpening",
        new events.ServerOpeningEvent(topology.s.id, serverDescription.address)
      );
      const server = new Server(serverDescription, topology.s.options, topology);
      relayEvents(server, topology, SERVER_RELAY_EVENTS);
      server.on("descriptionReceived", topology.serverUpdateHandler.bind(topology));
      if (connectDelay) {
        const connectTimer = setTimeout(() => {
          clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);
          server.connect();
        }, connectDelay);
        topology.s.connectionTimers.add(connectTimer);
        return server;
      }
      server.connect();
      return server;
    }
    function connectServers(topology, serverDescriptions) {
      topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {
        const server = createAndConnectServer(topology, serverDescription);
        servers.set(serverDescription.address, server);
        return servers;
      }, /* @__PURE__ */ new Map());
    }
    function updateServers(topology, incomingServerDescription) {
      if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server = topology.s.servers.get(incomingServerDescription.address);
        server.s.description = incomingServerDescription;
      }
      for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
          const server = createAndConnectServer(topology, serverDescription);
          topology.s.servers.set(serverDescription.address, server);
        }
      }
      for (const entry of topology.s.servers) {
        const serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
          continue;
        }
        const server = topology.s.servers.get(serverAddress);
        topology.s.servers.delete(serverAddress);
        destroyServer(server, topology);
      }
    }
    function executeWriteOperation(args, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const topology = args.topology;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      topology.selectServer(writableServerSelector(), options, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const notAlreadyRetrying = !args.retrying;
        const retryWrites = !!options.retryWrites;
        const hasSession = !!options.session;
        const supportsRetryableWrites = server.supportsRetryableWrites;
        const notInTransaction = !hasSession || !options.session.inTransaction();
        const notExplaining = options.explain === void 0;
        const willRetryWrite = notAlreadyRetrying && retryWrites && hasSession && supportsRetryableWrites && notInTransaction && notExplaining;
        const handler = (err2, result) => {
          if (!err2)
            return callback(null, result);
          if (!shouldRetryOperation(err2)) {
            err2 = getMMAPError(err2);
            return callback(err2);
          }
          if (willRetryWrite) {
            const newArgs = Object.assign({}, args, { retrying: true });
            return executeWriteOperation(newArgs, options, callback);
          }
          return callback(err2);
        };
        if (callback.operationId) {
          handler.operationId = callback.operationId;
        }
        if (willRetryWrite) {
          options.session.incrementTransactionNumber();
          options.willRetryWrite = willRetryWrite;
        }
        server[op](ns, ops, options, handler);
      });
    }
    function shouldRetryOperation(err) {
      return err instanceof MongoError && err.hasErrorLabel("RetryableWriteError");
    }
    function srvPollingHandler(topology) {
      return function handleSrvPolling(ev) {
        const previousTopologyDescription = topology.s.description;
        topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);
        if (topology.s.description === previousTopologyDescription) {
          return;
        }
        updateServers(topology);
        topology.emit(
          "topologyDescriptionChanged",
          new events.TopologyDescriptionChangedEvent(
            topology.s.id,
            previousTopologyDescription,
            topology.s.description
          )
        );
      };
    }
    function drainWaitQueue(queue, err) {
      while (queue.length) {
        const waitQueueMember = queue.shift();
        clearTimeout(waitQueueMember.timer);
        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(err);
        }
      }
    }
    function processWaitQueue(topology) {
      if (topology.s.state === STATE_CLOSED) {
        drainWaitQueue(topology[kWaitQueue], new MongoError("Topology is closed, please connect"));
        return;
      }
      const serverDescriptions = Array.from(topology.description.servers.values());
      const membersToProcess = topology[kWaitQueue].length;
      for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {
        const waitQueueMember = topology[kWaitQueue].shift();
        if (waitQueueMember[kCancelled]) {
          continue;
        }
        let selectedDescriptions;
        try {
          const serverSelector = waitQueueMember.serverSelector;
          selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
        } catch (e) {
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(e);
          continue;
        }
        if (selectedDescriptions.length === 0) {
          topology[kWaitQueue].push(waitQueueMember);
          continue;
        }
        const selectedServerDescription = randomSelection(selectedDescriptions);
        const selectedServer = topology.s.servers.get(selectedServerDescription.address);
        const transaction = waitQueueMember.transaction;
        const isSharded = topology.description.type === TopologyType.Sharded;
        if (isSharded && transaction && transaction.isActive) {
          transaction.pinServer(selectedServer);
        }
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(void 0, selectedServer);
      }
      if (topology[kWaitQueue].length > 0) {
        topology.s.servers.forEach((server) => process.nextTick(() => server.requestCheck()));
      }
    }
    module2.exports = {
      Topology
    };
  }
});

// node_modules/mongodb/lib/core/uri_parser.js
var require_uri_parser = __commonJS({
  "node_modules/mongodb/lib/core/uri_parser.js"(exports2, module2) {
    "use strict";
    var URL = __require("url");
    var qs = __require("querystring");
    var dns = __require("dns");
    var MongoParseError = require_error().MongoParseError;
    var ReadPreference = require_read_preference();
    var emitWarningOnce = require_utils().emitWarningOnce;
    var HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;
    var FILE_PATH_OPTIONS = new Set(
      ["sslCA", "sslCert", "sslKey", "tlsCAFile", "tlsCertificateKeyFile"].map((key) => key.toLowerCase())
    );
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    function parseSrvConnectionString(uri, options, callback) {
      const result = URL.parse(uri, true);
      if (options.directConnection || options.directconnection) {
        return callback(new MongoParseError("directConnection not supported with SRV URI"));
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new MongoParseError("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = uri.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new MongoParseError("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new MongoParseError(`Ports not accepted with '${PROTOCOL_MONGODB_SRV}' URIs`));
      }
      const lookupAddress = result.host;
      dns.resolveSrv(`_mongodb._tcp.${lookupAddress}`, (err, addresses) => {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new MongoParseError("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(
              new MongoParseError("Server record does not share hostname with parent URI")
            );
          }
        }
        result.protocol = "mongodb";
        result.host = addresses.map((address) => `${address.name}:${address.port}`).join(",");
        if (!("ssl" in options) && (!result.search || !("ssl" in result.query) || result.query.ssl === null)) {
          result.query.ssl = true;
        }
        dns.resolveTxt(lookupAddress, (err2, record) => {
          if (err2) {
            if (err2.code !== "ENODATA" && err2.code !== "ENOTFOUND") {
              return callback(err2);
            }
            record = null;
          }
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = qs.parse(record[0].join(""));
            if (Object.keys(record).some((k) => k.toLowerCase() === "loadbalanced")) {
              return callback(new MongoParseError("Load balancer mode requires driver version 4+"));
            }
            if (Object.keys(record).some((key) => key !== "authSource" && key !== "replicaSet")) {
              return callback(
                new MongoParseError("Text record must only set `authSource` or `replicaSet`")
              );
            }
            result.query = Object.assign({}, record, result.query);
          }
          result.search = qs.stringify(result.query);
          const finalString = URL.format(result);
          parseConnectionString(finalString, options, (err3, ret) => {
            if (err3) {
              callback(err3);
              return;
            }
            callback(null, Object.assign({}, ret, { srvHost: lookupAddress }));
          });
        });
      });
    }
    function parseQueryStringItemValue(key, value2) {
      if (Array.isArray(value2)) {
        value2 = value2.filter((v, idx) => value2.indexOf(v) === idx);
        if (value2.length === 1)
          value2 = value2[0];
      } else if (value2.indexOf(":") > 0) {
        value2 = value2.split(",").reduce((result, pair) => {
          const parts = pair.split(":");
          result[parts[0]] = parseQueryStringItemValue(key, parts[1]);
          return result;
        }, {});
      } else if (value2.indexOf(",") > 0) {
        value2 = value2.split(",").map((v) => {
          return parseQueryStringItemValue(key, v);
        });
      } else if (value2.toLowerCase() === "true" || value2.toLowerCase() === "false") {
        value2 = value2.toLowerCase() === "true";
      } else if (!Number.isNaN(value2) && !STRING_OPTIONS.has(key)) {
        const numericValue = parseFloat(value2);
        if (!Number.isNaN(numericValue)) {
          value2 = parseFloat(value2);
        }
      }
      return value2;
    }
    var BOOLEAN_OPTIONS = /* @__PURE__ */ new Set([
      "slaveok",
      "slave_ok",
      "sslvalidate",
      "fsync",
      "safe",
      "retrywrites",
      "j"
    ]);
    var STRING_OPTIONS = /* @__PURE__ */ new Set(["authsource", "replicaset"]);
    var AUTH_MECHANISMS = /* @__PURE__ */ new Set([
      "GSSAPI",
      "MONGODB-AWS",
      "MONGODB-X509",
      "MONGODB-CR",
      "DEFAULT",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256",
      "PLAIN"
    ]);
    var CASE_TRANSLATION = {
      replicaset: "replicaSet",
      connecttimeoutms: "connectTimeoutMS",
      sockettimeoutms: "socketTimeoutMS",
      maxpoolsize: "maxPoolSize",
      minpoolsize: "minPoolSize",
      maxidletimems: "maxIdleTimeMS",
      waitqueuemultiple: "waitQueueMultiple",
      waitqueuetimeoutms: "waitQueueTimeoutMS",
      wtimeoutms: "wtimeoutMS",
      readconcern: "readConcern",
      readconcernlevel: "readConcernLevel",
      readpreference: "readPreference",
      maxstalenessseconds: "maxStalenessSeconds",
      readpreferencetags: "readPreferenceTags",
      authsource: "authSource",
      authmechanism: "authMechanism",
      authmechanismproperties: "authMechanismProperties",
      gssapiservicename: "gssapiServiceName",
      localthresholdms: "localThresholdMS",
      serverselectiontimeoutms: "serverSelectionTimeoutMS",
      serverselectiontryonce: "serverSelectionTryOnce",
      heartbeatfrequencyms: "heartbeatFrequencyMS",
      retrywrites: "retryWrites",
      uuidrepresentation: "uuidRepresentation",
      zlibcompressionlevel: "zlibCompressionLevel",
      tlsallowinvalidcertificates: "tlsAllowInvalidCertificates",
      tlsallowinvalidhostnames: "tlsAllowInvalidHostnames",
      tlsinsecure: "tlsInsecure",
      tlscafile: "tlsCAFile",
      tlscertificatekeyfile: "tlsCertificateKeyFile",
      tlscertificatekeyfilepassword: "tlsCertificateKeyFilePassword",
      wtimeout: "wTimeoutMS",
      j: "journal",
      directconnection: "directConnection"
    };
    function applyConnectionStringOption(obj, key, value2, options) {
      if (key === "journal") {
        key = "j";
      } else if (key === "wtimeoutms") {
        key = "wtimeout";
      }
      if (BOOLEAN_OPTIONS.has(key)) {
        value2 = value2 === "true" || value2 === true;
      } else if (key === "appname") {
        value2 = decodeURIComponent(value2);
      } else if (key === "readconcernlevel") {
        obj["readConcernLevel"] = value2;
        key = "readconcern";
        value2 = { level: value2 };
      }
      if (key === "compressors") {
        value2 = Array.isArray(value2) ? value2 : [value2];
        if (!value2.every((c) => c === "snappy" || c === "zlib")) {
          throw new MongoParseError(
            "Value for `compressors` must be at least one of: `snappy`, `zlib`"
          );
        }
      }
      if (key === "authmechanism" && !AUTH_MECHANISMS.has(value2)) {
        throw new MongoParseError(
          `Value for authMechanism must be one of: ${Array.from(AUTH_MECHANISMS).join(
            ", "
          )}, found: ${value2}`
        );
      }
      if (key === "readpreference" && !ReadPreference.isValid(value2)) {
        throw new MongoParseError(
          "Value for `readPreference` must be one of: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`"
        );
      }
      if (key === "zlibcompressionlevel" && (value2 < -1 || value2 > 9)) {
        throw new MongoParseError("zlibCompressionLevel must be an integer between -1 and 9");
      }
      if (key === "compressors" || key === "zlibcompressionlevel") {
        obj.compression = obj.compression || {};
        obj = obj.compression;
      }
      if (key === "authmechanismproperties") {
        if (typeof value2.SERVICE_NAME === "string")
          obj.gssapiServiceName = value2.SERVICE_NAME;
        if (typeof value2.SERVICE_REALM === "string")
          obj.gssapiServiceRealm = value2.SERVICE_REALM;
        if (typeof value2.CANONICALIZE_HOST_NAME !== "undefined") {
          obj.gssapiCanonicalizeHostName = value2.CANONICALIZE_HOST_NAME;
        }
      }
      if (key === "readpreferencetags") {
        value2 = Array.isArray(value2) ? splitArrayOfMultipleReadPreferenceTags(value2) : [value2];
      }
      if (options.caseTranslate && CASE_TRANSLATION[key]) {
        obj[CASE_TRANSLATION[key]] = value2;
        return;
      }
      obj[key] = value2;
    }
    var USERNAME_REQUIRED_MECHANISMS = /* @__PURE__ */ new Set([
      "GSSAPI",
      "MONGODB-CR",
      "PLAIN",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    function splitArrayOfMultipleReadPreferenceTags(value2) {
      const parsedTags = [];
      for (let i = 0; i < value2.length; i++) {
        parsedTags[i] = {};
        value2[i].split(",").forEach((individualTag) => {
          const splitTag = individualTag.split(":");
          parsedTags[i][splitTag[0]] = splitTag[1];
        });
      }
      return parsedTags;
    }
    function applyAuthExpectations(parsed) {
      if (parsed.options == null) {
        return;
      }
      const options = parsed.options;
      const authSource = options.authsource || options.authSource;
      if (authSource != null) {
        parsed.auth = Object.assign({}, parsed.auth, { db: authSource });
      }
      const authMechanism = options.authmechanism || options.authMechanism;
      if (authMechanism != null) {
        if (USERNAME_REQUIRED_MECHANISMS.has(authMechanism) && (!parsed.auth || parsed.auth.username == null)) {
          throw new MongoParseError(`Username required for mechanism \`${authMechanism}\``);
        }
        if (authMechanism === "GSSAPI") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(
              `Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`
            );
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "MONGODB-AWS") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(
              `Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`
            );
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "MONGODB-X509") {
          if (parsed.auth && parsed.auth.password != null) {
            throw new MongoParseError(`Password not allowed for mechanism \`${authMechanism}\``);
          }
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(
              `Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`
            );
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "PLAIN") {
          if (parsed.auth && parsed.auth.db == null) {
            parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
          }
        }
      }
      if (parsed.auth && parsed.auth.db == null) {
        parsed.auth = Object.assign({}, parsed.auth, { db: "admin" });
      }
      return parsed;
    }
    function parseQueryString(query, options) {
      const result = {};
      let parsedQueryString = qs.parse(query);
      checkTLSOptions(parsedQueryString);
      for (const key in parsedQueryString) {
        const value2 = parsedQueryString[key];
        if (value2 === "" || value2 == null) {
          throw new MongoParseError("Incomplete key value pair for option");
        }
        const normalizedKey = key.toLowerCase();
        if (normalizedKey === "serverapi") {
          throw new MongoParseError(
            "URI cannot contain `serverApi`, it can only be passed to the client"
          );
        }
        const parsedValue = FILE_PATH_OPTIONS.has(normalizedKey) ? value2 : parseQueryStringItemValue(normalizedKey, value2);
        applyConnectionStringOption(result, normalizedKey, parsedValue, options);
      }
      if (result.wtimeout && result.wtimeoutms) {
        delete result.wtimeout;
        emitWarningOnce("Unsupported option `wtimeout` specified");
      }
      return Object.keys(result).length ? result : null;
    }
    function translateTLSOptions(queryString) {
      if (queryString.tls) {
        queryString.ssl = queryString.tls;
      }
      if (queryString.tlsInsecure) {
        queryString.checkServerIdentity = false;
        queryString.sslValidate = false;
      } else {
        Object.assign(queryString, {
          checkServerIdentity: queryString.tlsAllowInvalidHostnames ? false : true,
          sslValidate: queryString.tlsAllowInvalidCertificates ? false : true
        });
      }
      if (queryString.tlsCAFile) {
        queryString.ssl = true;
        queryString.sslCA = queryString.tlsCAFile;
      }
      if (queryString.tlsCertificateKeyFile) {
        queryString.ssl = true;
        if (queryString.tlsCertificateFile) {
          queryString.sslCert = queryString.tlsCertificateFile;
          queryString.sslKey = queryString.tlsCertificateKeyFile;
        } else {
          queryString.sslKey = queryString.tlsCertificateKeyFile;
          queryString.sslCert = queryString.tlsCertificateKeyFile;
        }
      }
      if (queryString.tlsCertificateKeyFilePassword) {
        queryString.ssl = true;
        queryString.sslPass = queryString.tlsCertificateKeyFilePassword;
      }
      return queryString;
    }
    function checkTLSOptions(queryString) {
      const queryStringKeys = Object.keys(queryString);
      if (queryStringKeys.indexOf("tlsInsecure") !== -1 && (queryStringKeys.indexOf("tlsAllowInvalidCertificates") !== -1 || queryStringKeys.indexOf("tlsAllowInvalidHostnames") !== -1)) {
        throw new MongoParseError(
          "The `tlsInsecure` option cannot be used with `tlsAllowInvalidCertificates` or `tlsAllowInvalidHostnames`."
        );
      }
      const tlsValue = assertTlsOptionsAreEqual("tls", queryString, queryStringKeys);
      const sslValue = assertTlsOptionsAreEqual("ssl", queryString, queryStringKeys);
      if (tlsValue != null && sslValue != null) {
        if (tlsValue !== sslValue) {
          throw new MongoParseError("All values of `tls` and `ssl` must be the same.");
        }
      }
    }
    function assertTlsOptionsAreEqual(optionName, queryString, queryStringKeys) {
      const queryStringHasTLSOption = queryStringKeys.indexOf(optionName) !== -1;
      let optionValue;
      if (Array.isArray(queryString[optionName])) {
        optionValue = queryString[optionName][0];
      } else {
        optionValue = queryString[optionName];
      }
      if (queryStringHasTLSOption) {
        if (Array.isArray(queryString[optionName])) {
          const firstValue = queryString[optionName][0];
          queryString[optionName].forEach((tlsValue) => {
            if (tlsValue !== firstValue) {
              throw new MongoParseError(`All values of ${optionName} must be the same.`);
            }
          });
        }
      }
      return optionValue;
    }
    var PROTOCOL_MONGODB = "mongodb";
    var PROTOCOL_MONGODB_SRV = "mongodb+srv";
    var SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];
    function parseConnectionString(uri, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, { caseTranslate: true }, options);
      try {
        URL.parse(uri);
      } catch (e) {
        return callback(new MongoParseError("URI malformed, cannot be parsed"));
      }
      const cap = uri.match(HOSTS_RX);
      if (!cap) {
        return callback(new MongoParseError("Invalid connection string"));
      }
      const protocol = cap[1];
      if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {
        return callback(new MongoParseError("Invalid protocol provided"));
      }
      const dbAndQuery = cap[4].split("?");
      const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
      const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;
      let parsedOptions;
      try {
        parsedOptions = parseQueryString(query, options);
      } catch (parseError) {
        return callback(parseError);
      }
      parsedOptions = Object.assign({}, parsedOptions, options);
      if (Object.keys(parsedOptions).some((k) => k.toLowerCase() === "loadbalanced")) {
        return callback(new MongoParseError("Load balancer mode requires driver version 4+"));
      }
      if (protocol === PROTOCOL_MONGODB_SRV) {
        return parseSrvConnectionString(uri, parsedOptions, callback);
      }
      const auth = { username: null, password: null, db: db && db !== "" ? qs.unescape(db) : null };
      if (parsedOptions.auth) {
        if (parsedOptions.auth.username)
          auth.username = parsedOptions.auth.username;
        if (parsedOptions.auth.user)
          auth.username = parsedOptions.auth.user;
        if (parsedOptions.auth.password)
          auth.password = parsedOptions.auth.password;
      } else {
        if (parsedOptions.username)
          auth.username = parsedOptions.username;
        if (parsedOptions.user)
          auth.username = parsedOptions.user;
        if (parsedOptions.password)
          auth.password = parsedOptions.password;
      }
      if (cap[4].split("?")[0].indexOf("@") !== -1) {
        return callback(new MongoParseError("Unescaped slash in userinfo section"));
      }
      const authorityParts = cap[3].split("@");
      if (authorityParts.length > 2) {
        return callback(new MongoParseError("Unescaped at-sign in authority section"));
      }
      if (authorityParts[0] == null || authorityParts[0] === "") {
        return callback(new MongoParseError("No username provided in authority section"));
      }
      if (authorityParts.length > 1) {
        const authParts = authorityParts.shift().split(":");
        if (authParts.length > 2) {
          return callback(new MongoParseError("Unescaped colon in authority section"));
        }
        if (authParts[0] === "") {
          return callback(new MongoParseError("Invalid empty username provided"));
        }
        if (!auth.username)
          auth.username = qs.unescape(authParts[0]);
        if (!auth.password)
          auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;
      }
      let hostParsingError = null;
      const hosts = authorityParts.shift().split(",").map((host) => {
        let parsedHost = URL.parse(`mongodb://${host}`);
        if (parsedHost.path === "/:") {
          hostParsingError = new MongoParseError("Double colon in host identifier");
          return null;
        }
        if (host.match(/\.sock/)) {
          parsedHost.hostname = qs.unescape(host);
          parsedHost.port = null;
        }
        if (Number.isNaN(parsedHost.port)) {
          hostParsingError = new MongoParseError("Invalid port (non-numeric string)");
          return;
        }
        const result2 = {
          host: parsedHost.hostname,
          port: parsedHost.port ? parseInt(parsedHost.port) : 27017
        };
        if (result2.port === 0) {
          hostParsingError = new MongoParseError("Invalid port (zero) with hostname");
          return;
        }
        if (result2.port > 65535) {
          hostParsingError = new MongoParseError("Invalid port (larger than 65535) with hostname");
          return;
        }
        if (result2.port < 0) {
          hostParsingError = new MongoParseError("Invalid port (negative number)");
          return;
        }
        return result2;
      }).filter((host) => !!host);
      if (hostParsingError) {
        return callback(hostParsingError);
      }
      if (hosts.length === 0 || hosts[0].host === "" || hosts[0].host === null) {
        return callback(new MongoParseError("No hostname or hostnames provided in connection string"));
      }
      const directConnection = !!parsedOptions.directConnection;
      if (directConnection && hosts.length !== 1) {
        return callback(new MongoParseError("directConnection option requires exactly one host"));
      }
      if (parsedOptions.directConnection == null && hosts.length === 1 && parsedOptions.replicaSet == null) {
        parsedOptions.directConnection = true;
      }
      const result = {
        hosts,
        auth: auth.db || auth.username ? auth : null,
        options: Object.keys(parsedOptions).length ? parsedOptions : null
      };
      if (result.auth && result.auth.db) {
        result.defaultDatabase = result.auth.db;
      } else {
        result.defaultDatabase = "test";
      }
      result.options = translateTLSOptions(result.options);
      try {
        applyAuthExpectations(result);
      } catch (authError) {
        return callback(authError);
      }
      callback(null, result);
    }
    module2.exports = parseConnectionString;
  }
});

// node_modules/mongodb/lib/core/index.js
var require_core = __commonJS({
  "node_modules/mongodb/lib/core/index.js"(exports2, module2) {
    "use strict";
    var BSON2 = require_bson2();
    var require_optional = require_optional_require()(__require);
    var EJSON = require_utils3().retrieveEJSON();
    try {
      const BSONNative = require_optional("bson-ext");
      if (BSONNative) {
        BSON2 = BSONNative;
      }
    } catch (err) {
    }
    var ServerApiVersion = Object.freeze({
      v1: "1"
    });
    var ValidServerApiVersions = Object.keys(ServerApiVersion).map((key) => ServerApiVersion[key]);
    module2.exports = {
      // Versioned API
      ServerApiVersion,
      ValidServerApiVersions,
      // Errors
      MongoError: require_error().MongoError,
      MongoNetworkError: require_error().MongoNetworkError,
      MongoParseError: require_error().MongoParseError,
      MongoTimeoutError: require_error().MongoTimeoutError,
      MongoServerSelectionError: require_error().MongoServerSelectionError,
      MongoWriteConcernError: require_error().MongoWriteConcernError,
      // Core
      Connection: require_connection(),
      Server: require_server(),
      ReplSet: require_replset(),
      Mongos: require_mongos(),
      Logger: require_logger(),
      Cursor: require_cursor().CoreCursor,
      ReadPreference: require_read_preference(),
      Sessions: require_sessions(),
      BSON: BSON2,
      EJSON,
      Topology: require_topology().Topology,
      // Raw operations
      Query: require_commands().Query,
      // Auth mechanisms
      MongoCredentials: require_mongo_credentials().MongoCredentials,
      defaultAuthProviders: require_defaultAuthProviders().defaultAuthProviders,
      MongoCR: require_mongocr(),
      X509: require_x509(),
      Plain: require_plain(),
      GSSAPI: require_gssapi(),
      ScramSHA1: require_scram().ScramSHA1,
      ScramSHA256: require_scram().ScramSHA256,
      // Utilities
      parseConnectionString: require_uri_parser()
    };
  }
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS({
  "node_modules/mongodb/lib/bulk/common.js"(exports2, module2) {
    "use strict";
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().BSON.ObjectID;
    var BSON2 = require_core().BSON;
    var MongoWriteConcernError = require_core().MongoWriteConcernError;
    var emitWarningOnce = require_utils().emitWarningOnce;
    var toError = require_utils().toError;
    var handleCallback = require_utils().handleCallback;
    var applyRetryableWrites = require_utils().applyRetryableWrites;
    var applyWriteConcern = require_utils().applyWriteConcern;
    var executeLegacyOperation = require_utils().executeLegacyOperation;
    var isPromiseLike = require_utils().isPromiseLike;
    var hasAtomicOperators = require_utils().hasAtomicOperators;
    var maxWireVersion = require_utils3().maxWireVersion;
    var WRITE_CONCERN_ERROR = 64;
    var INSERT = 1;
    var UPDATE = 2;
    var REMOVE = 3;
    var bson = new BSON2([
      BSON2.Binary,
      BSON2.Code,
      BSON2.DBRef,
      BSON2.Decimal128,
      BSON2.Double,
      BSON2.Int32,
      BSON2.Long,
      BSON2.Map,
      BSON2.MaxKey,
      BSON2.MinKey,
      BSON2.ObjectId,
      BSON2.BSONRegExp,
      BSON2.Symbol,
      BSON2.Timestamp
    ]);
    var Batch = class {
      constructor(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
      }
    };
    var kUpsertedIds = Symbol("upsertedIds");
    var kInsertedIds = Symbol("insertedIds");
    var BulkWriteResult = class {
      /**
       * Create a new BulkWriteResult instance
       *
       * **NOTE:** Internal Type, do not instantiate directly
       */
      constructor(bulkResult) {
        this.result = bulkResult;
        this[kUpsertedIds] = void 0;
        this[kInsertedIds] = void 0;
      }
      /** Number of documents inserted. */
      get insertedCount() {
        return typeof this.result.nInserted !== "number" ? 0 : this.result.nInserted;
      }
      /** Number of documents matched for update. */
      get matchedCount() {
        return typeof this.result.nMatched !== "number" ? 0 : this.result.nMatched;
      }
      /** Number of documents modified. */
      get modifiedCount() {
        return typeof this.result.nModified !== "number" ? 0 : this.result.nModified;
      }
      /** Number of documents deleted. */
      get deletedCount() {
        return typeof this.result.nRemoved !== "number" ? 0 : this.result.nRemoved;
      }
      /** Number of documents upserted. */
      get upsertedCount() {
        return !this.result.upserted ? 0 : this.result.upserted.length;
      }
      /** Upserted document generated Id's, hash key is the index of the originating operation */
      get upsertedIds() {
        if (this[kUpsertedIds]) {
          return this[kUpsertedIds];
        }
        this[kUpsertedIds] = {};
        for (const doc of this.result.upserted || []) {
          this[kUpsertedIds][doc.index] = doc._id;
        }
        return this[kUpsertedIds];
      }
      /** Inserted document generated Id's, hash key is the index of the originating operation */
      get insertedIds() {
        if (this[kInsertedIds]) {
          return this[kInsertedIds];
        }
        this[kInsertedIds] = {};
        for (const doc of this.result.insertedIds || []) {
          this[kInsertedIds][doc.index] = doc._id;
        }
        return this[kInsertedIds];
      }
      /** The number of inserted documents @type {number} */
      get n() {
        return this.result.insertedCount;
      }
      /**
       * Evaluates to true if the bulk operation correctly executes
       * @type {boolean}
       */
      get ok() {
        return this.result.ok;
      }
      /**
       * The number of inserted documents
       * @type {number}
       */
      get nInserted() {
        return this.result.nInserted;
      }
      /**
       * Number of upserted documents
       * @type {number}
       */
      get nUpserted() {
        return this.result.nUpserted;
      }
      /**
       * Number of matched documents
       * @type {number}
       */
      get nMatched() {
        return this.result.nMatched;
      }
      /**
       * Number of documents updated physically on disk
       * @type {number}
       */
      get nModified() {
        return this.result.nModified;
      }
      /**
       * Number of removed documents
       * @type {number}
       */
      get nRemoved() {
        return this.result.nRemoved;
      }
      /**
       * Returns an array of all inserted ids
       *
       * @return {object[]}
       */
      getInsertedIds() {
        return this.result.insertedIds;
      }
      /**
       * Returns an array of all upserted ids
       *
       * @return {object[]}
       */
      getUpsertedIds() {
        return this.result.upserted;
      }
      /**
       * Returns the upserted id at the given index
       *
       * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index
       * @return {object}
       */
      getUpsertedIdAt(index) {
        return this.result.upserted[index];
      }
      /**
       * Returns raw internal result
       *
       * @return {object}
       */
      getRawResponse() {
        return this.result;
      }
      /**
       * Returns true if the bulk operation contains a write error
       *
       * @return {boolean}
       */
      hasWriteErrors() {
        return this.result.writeErrors.length > 0;
      }
      /**
       * Returns the number of write errors off the bulk operation
       *
       * @return {number}
       */
      getWriteErrorCount() {
        return this.result.writeErrors.length;
      }
      /**
       * Returns a specific write error object
       *
       * @param {number} index of the write error to return, returns null if there is no result for passed in index
       * @return {WriteError}
       */
      getWriteErrorAt(index) {
        if (index < this.result.writeErrors.length) {
          return this.result.writeErrors[index];
        }
        return null;
      }
      /**
       * Retrieve all write errors
       *
       * @return {WriteError[]}
       */
      getWriteErrors() {
        return this.result.writeErrors;
      }
      /**
       * Retrieve lastOp if available
       *
       * @return {object}
       */
      getLastOp() {
        return this.result.lastOp;
      }
      /**
       * Retrieve the write concern error if any
       *
       * @return {WriteConcernError}
       */
      getWriteConcernError() {
        if (this.result.writeConcernErrors.length === 0) {
          return null;
        } else if (this.result.writeConcernErrors.length === 1) {
          return this.result.writeConcernErrors[0];
        } else {
          let errmsg = "";
          for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
            const err = this.result.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i === 0)
              errmsg = errmsg + " and ";
          }
          return new WriteConcernError({ errmsg, code: WRITE_CONCERN_ERROR });
        }
      }
      /**
       * @return {object}
       */
      toJSON() {
        return this.result;
      }
      /**
       * @return {string}
       */
      toString() {
        return `BulkWriteResult(${this.toJSON(this.result)})`;
      }
      /**
       * @return {boolean}
       */
      isOk() {
        return this.result.ok === 1;
      }
    };
    var WriteConcernError = class {
      /**
       * Create a new WriteConcernError instance
       *
       * **NOTE:** Internal Type, do not instantiate directly
       */
      constructor(err) {
        this.err = err;
      }
      /**
       * Write concern error code.
       * @type {number}
       */
      get code() {
        return this.err.code;
      }
      /**
       * Write concern error message.
       * @type {string}
       */
      get errmsg() {
        return this.err.errmsg;
      }
      /**
       * @return {object}
       */
      toJSON() {
        return { code: this.err.code, errmsg: this.err.errmsg };
      }
      /**
       * @return {string}
       */
      toString() {
        return `WriteConcernError(${this.err.errmsg})`;
      }
    };
    var WriteError = class {
      /**
       * Create a new WriteError instance
       *
       * **NOTE:** Internal Type, do not instantiate directly
       */
      constructor(err) {
        this.err = err;
      }
      /**
       * WriteError code.
       * @type {number}
       */
      get code() {
        return this.err.code;
      }
      /**
       * WriteError original bulk operation index.
       * @type {number}
       */
      get index() {
        return this.err.index;
      }
      /**
       * WriteError message.
       * @type {string}
       */
      get errmsg() {
        return this.err.errmsg;
      }
      /**
       * Returns the underlying operation that caused the error
       * @return {object}
       */
      getOperation() {
        return this.err.op;
      }
      /**
       * @return {object}
       */
      toJSON() {
        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
      }
      /**
       * @return {string}
       */
      toString() {
        return `WriteError(${JSON.stringify(this.toJSON())})`;
      }
    };
    function longOrConvert(value2) {
      return typeof value2 === "number" ? Long2.fromNumber(value2) : value2;
    }
    function mergeBatchResults(batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      } else if (result == null) {
        return;
      }
      if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        const writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
      }
      if (result.opTime || result.lastOp) {
        let opTime = result.lastOp || result.opTime;
        if (opTime._bsontype === "Timestamp") {
          opTime = { ts: opTime, t: Long2.ZERO };
        }
        if (!bulkResult.lastOp) {
          bulkResult.lastOp = opTime;
        } else {
          const lastOpTS = longOrConvert(bulkResult.lastOp.ts);
          const opTimeTS = longOrConvert(opTime.ts);
          if (opTimeTS.greaterThan(lastOpTS)) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.equals(lastOpTS)) {
            const lastOpT = longOrConvert(bulkResult.lastOp.t);
            const opTimeT = longOrConvert(opTime.t);
            if (opTimeT.greaterThan(lastOpT)) {
              bulkResult.lastOp = opTime;
            }
          }
        }
      }
      if (batch.batchType === INSERT && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (batch.batchType === REMOVE && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      let nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (let i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (batch.batchType === UPDATE && result.n) {
        const nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === "number") {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = null;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (let i = 0; i < result.writeErrors.length; i++) {
          const writeError = {
            index: batch.originalIndexes[result.writeErrors[i].index],
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    }
    function executeCommands(bulkOperation, options, callback) {
      if (bulkOperation.s.batches.length === 0) {
        return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
      }
      const batch = bulkOperation.s.batches.shift();
      function resultHandler(err, result) {
        if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
          return handleCallback(callback, err);
        }
        if (err)
          err.ok = 0;
        if (err instanceof MongoWriteConcernError) {
          return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
        }
        const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
        const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
        if (mergeResult != null) {
          return handleCallback(callback, null, writeResult);
        }
        if (bulkOperation.handleWriteError(callback, writeResult))
          return;
        executeCommands(bulkOperation, options, callback);
      }
      bulkOperation.finalOptionsHandler({ options, batch, resultHandler }, callback);
    }
    function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
      mergeBatchResults(batch, bulkResult, null, err.result);
      const wrappedWriteConcernError = new WriteConcernError({
        errmsg: err.result.writeConcernError.errmsg,
        code: err.result.writeConcernError.result
      });
      return handleCallback(
        callback,
        new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)),
        null
      );
    }
    var BulkWriteError = class extends MongoError {
      /**
       * Creates a new BulkWriteError
       *
       * @param {Error|string|object} message The error message
       * @param {BulkWriteResult} result The result of the bulk write operation
       * @extends {MongoError}
       */
      constructor(error, result) {
        const message = error.err || error.errmsg || error.errMessage || error;
        super(message);
        Object.assign(this, error);
        this.name = "BulkWriteError";
        this.result = result;
      }
      /** Number of documents inserted. */
      get insertedCount() {
        return this.result.insertedCount;
      }
      /** Number of documents matched for update. */
      get matchedCount() {
        return this.result.matchedCount;
      }
      /** Number of documents modified. */
      get modifiedCount() {
        return this.result.modifiedCount;
      }
      /** Number of documents deleted. */
      get deletedCount() {
        return this.result.deletedCount;
      }
      /** Number of documents upserted. */
      get upsertedCount() {
        return this.result.upsertedCount;
      }
      /** Inserted document generated Id's, hash key is the index of the originating operation */
      get insertedIds() {
        return this.result.insertedIds;
      }
      /** Upserted document generated Id's, hash key is the index of the originating operation */
      get upsertedIds() {
        return this.result.upsertedIds;
      }
    };
    var FindOperators = class {
      /**
       * Creates a new FindOperators object.
       *
       * **NOTE:** Internal Type, do not instantiate directly
       * @param {OrderedBulkOperation|UnorderedBulkOperation} bulkOperation
       */
      constructor(bulkOperation) {
        this.s = bulkOperation.s;
      }
      /**
       * Add a multiple update operation to the bulk operation
       *
       * @method
       * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}
       * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.
       * @throws {MongoError} If operation cannot be added to bulk write
       * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation
       */
      update(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: true,
          upsert
        };
        if (updateDocument.hint) {
          document.hint = updateDocument.hint;
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document);
      }
      /**
       * Add a single update operation to the bulk operation
       *
       * @method
       * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}
       * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.
       * @throws {MongoError} If operation cannot be added to bulk write
       * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation
       */
      updateOne(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: false,
          upsert
        };
        if (updateDocument.hint) {
          document.hint = updateDocument.hint;
        }
        if (!hasAtomicOperators(updateDocument)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document);
      }
      /**
       * Add a replace one operation to the bulk operation
       *
       * @method
       * @param {object} replacement the new document to replace the existing one with
       * @throws {MongoError} If operation cannot be added to bulk write
       * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation
       */
      replaceOne(replacement) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document = {
          q: this.s.currentOp.selector,
          u: replacement,
          multi: false,
          upsert
        };
        if (replacement.hint) {
          document.hint = replacement.hint;
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not use atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document);
      }
      /**
       * Upsert modifier for update bulk operation, noting that this operation is an upsert.
       *
       * @method
       * @throws {MongoError} If operation cannot be added to bulk write
       * @return {FindOperators} reference to self
       */
      upsert() {
        this.s.currentOp.upsert = true;
        return this;
      }
      /**
       * Add a delete one operation to the bulk operation
       *
       * @method
       * @throws {MongoError} If operation cannot be added to bulk write
       * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation
       */
      deleteOne() {
        const document = {
          q: this.s.currentOp.selector,
          limit: 1
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document);
      }
      /**
       * Add a delete many operation to the bulk operation
       *
       * @method
       * @throws {MongoError} If operation cannot be added to bulk write
       * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation
       */
      delete() {
        const document = {
          q: this.s.currentOp.selector,
          limit: 0
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document);
      }
      /**
       * backwards compatability for deleteOne
       * @deprecated
       */
      removeOne() {
        emitWarningOnce("bulk operation `removeOne` has been deprecated, please use `deleteOne`");
        return this.deleteOne();
      }
      /**
       * backwards compatability for delete
       * @deprecated
       */
      remove() {
        emitWarningOnce("bulk operation `remove` has been deprecated, please use `delete`");
        return this.delete();
      }
    };
    var BulkOperationBase = class {
      /**
       * Create a new OrderedBulkOperation or UnorderedBulkOperation instance
       * @property {number} length Get the number of operations in the bulk.
       */
      constructor(topology, collection, options, isOrdered) {
        this.isOrdered = isOrdered;
        options = options == null ? {} : options;
        const namespace = collection.s.namespace;
        const executed = false;
        const currentOp = null;
        const bson2 = topology.bson;
        const isMaster = topology.lastIsMaster();
        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;
        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1e3;
        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        let finalOptions = Object.assign({}, options);
        finalOptions = applyRetryableWrites(finalOptions, collection.s.db);
        finalOptions = applyWriteConcern(finalOptions, { collection }, options);
        const writeConcern = finalOptions.writeConcern;
        const promiseLibrary = options.promiseLibrary || Promise;
        const bulkResult = {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        };
        this.s = {
          // Final result
          bulkResult,
          // Current batch state
          currentBatch: null,
          currentIndex: 0,
          // ordered specific
          currentBatchSize: 0,
          currentBatchSizeBytes: 0,
          // unordered specific
          currentInsertBatch: null,
          currentUpdateBatch: null,
          currentRemoveBatch: null,
          batches: [],
          // Write concern
          writeConcern,
          // Max batch size options
          maxBsonObjectSize,
          maxBatchSizeBytes,
          maxWriteBatchSize,
          maxKeySize,
          // Namespace
          namespace,
          // BSON
          bson: bson2,
          // Topology
          topology,
          // Options
          options: finalOptions,
          // Current operation
          currentOp,
          // Executed
          executed,
          // Collection
          collection,
          // Promise Library
          promiseLibrary,
          // Fundamental error
          err: null,
          // check keys
          checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : true
        };
        if (options.bypassDocumentValidation === true) {
          this.s.bypassDocumentValidation = true;
        }
      }
      /**
       * Add a single insert document to the bulk operation
       *
       * @param {object} document the document to insert
       * @throws {MongoError}
       * @return {BulkOperationBase} A reference to self
       *
       * @example
       * const bulkOp = collection.initializeOrderedBulkOp();
       * // Adds three inserts to the bulkOp.
       * bulkOp
       *   .insert({ a: 1 })
       *   .insert({ b: 2 })
       *   .insert({ c: 3 });
       * await bulkOp.execute();
       */
      insert(document) {
        if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null)
          document._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, document);
      }
      /**
       * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.
       * Returns a builder object used to complete the definition of the operation.
       *
       * @method
       * @param {object} selector The selector for the bulk operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-q q documentation}
       * @throws {MongoError} if a selector is not specified
       * @return {FindOperators} A helper object with which the write operation can be defined.
       *
       * @example
       * const bulkOp = collection.initializeOrderedBulkOp();
       *
       * // Add an updateOne to the bulkOp
       * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });
       *
       * // Add an updateMany to the bulkOp
       * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });
       *
       * // Add an upsert
       * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });
       *
       * // Add a deletion
       * bulkOp.find({ g: 7 }).deleteOne();
       *
       * // Add a multi deletion
       * bulkOp.find({ h: 8 }).delete();
       *
       * // Add a replaceOne
       * bulkOp.find({ i: 9 }).replaceOne({ j: 10 });
       *
       * // Update using a pipeline (requires Mongodb 4.2 or higher)
       * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([
       *   { $set: { total: { $sum: [ '$y', '$z' ] } } }
       * ]);
       *
       * // All of the ops will now be executed
       * await bulkOp.execute();
       */
      find(selector) {
        if (!selector) {
          throw toError("Bulk find operation must specify a selector");
        }
        this.s.currentOp = {
          selector
        };
        return new FindOperators(this);
      }
      /**
       * Specifies a raw operation to perform in the bulk write.
       *
       * @method
       * @param {object} op The raw operation to perform.
       * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.
       * @return {BulkOperationBase} A reference to self
       */
      raw(op) {
        const key = Object.keys(op)[0];
        const forceServerObjectId = typeof this.s.options.forceServerObjectId === "boolean" ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
        if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
          op[key].multi = op.updateOne || op.replaceOne ? false : true;
          return this.s.options.addToOperationsList(this, UPDATE, op[key]);
        }
        if (op.updateOne || op.updateMany || op.replaceOne) {
          if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {
            throw new TypeError("Replacement document must not use atomic operators");
          } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {
            throw new TypeError("Update document requires atomic operators");
          }
          const multi = op.updateOne || op.replaceOne ? false : true;
          const operation = {
            q: op[key].filter,
            u: op[key].update || op[key].replacement,
            multi
          };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            operation.upsert = op[key].upsert ? true : false;
            if (op.collation)
              operation.collation = op.collation;
          } else {
            if (op[key].upsert)
              operation.upsert = true;
          }
          if (op[key].arrayFilters) {
            if (maxWireVersion(this.s.topology) < 6) {
              throw new TypeError("arrayFilters are only supported on MongoDB 3.6+");
            }
            operation.arrayFilters = op[key].arrayFilters;
          }
          return this.s.options.addToOperationsList(this, UPDATE, operation);
        }
        if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
          op[key].limit = op.removeOne ? 1 : 0;
          return this.s.options.addToOperationsList(this, REMOVE, op[key]);
        }
        if (op.deleteOne || op.deleteMany) {
          const limit = op.deleteOne ? 1 : 0;
          const operation = { q: op[key].filter, limit };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            if (op.collation)
              operation.collation = op.collation;
          }
          return this.s.options.addToOperationsList(this, REMOVE, operation);
        }
        if (op.insertOne && op.insertOne.document == null) {
          if (forceServerObjectId !== true && op.insertOne._id == null)
            op.insertOne._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne);
        } else if (op.insertOne && op.insertOne.document) {
          if (forceServerObjectId !== true && op.insertOne.document._id == null)
            op.insertOne.document._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);
        }
        if (op.insertMany) {
          emitWarningOnce(
            "bulk operation `insertMany` has been deprecated; use multiple `insertOne` ops instead"
          );
          for (let i = 0; i < op.insertMany.length; i++) {
            if (forceServerObjectId !== true && op.insertMany[i]._id == null)
              op.insertMany[i]._id = new ObjectID2();
            this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);
          }
          return;
        }
        throw toError(
          "bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany"
        );
      }
      /**
       * helper function to assist with promiseOrCallback behavior
       * @ignore
       * @param {*} err
       * @param {*} callback
       */
      _handleEarlyError(err, callback) {
        if (typeof callback === "function") {
          callback(err, null);
          return;
        }
        return this.s.promiseLibrary.reject(err);
      }
      /**
       * An internal helper method. Do not invoke directly. Will be going away in the future
       *
       * @ignore
       * @method
       * @param {class} bulk either OrderedBulkOperation or UnorderdBulkOperation
       * @param {object} writeConcern
       * @param {object} options
       * @param {function} callback
       */
      bulkExecute(_writeConcern, options, callback) {
        if (typeof options === "function") {
          callback = options;
        }
        const finalOptions = Object.assign({}, this.s.options, options);
        if (typeof _writeConcern === "function") {
          callback = _writeConcern;
        } else if (_writeConcern && typeof _writeConcern === "object") {
          this.s.writeConcern = _writeConcern;
        }
        if (this.s.executed) {
          const executedError = toError("batch cannot be re-executed");
          return this._handleEarlyError(executedError, callback);
        }
        if (this.isOrdered) {
          if (this.s.currentBatch)
            this.s.batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            this.s.batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            this.s.batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            this.s.batches.push(this.s.currentRemoveBatch);
        }
        if (this.s.batches.length === 0) {
          const emptyBatchError = toError("Invalid Operation, no operations specified");
          return this._handleEarlyError(emptyBatchError, callback);
        }
        return { options: finalOptions, callback };
      }
      /**
       * The callback format for results
       * @callback BulkOperationBase~resultCallback
       * @param {MongoError} error An error instance representing the error during the execution.
       * @param {BulkWriteResult} result The bulk write result.
       */
      /**
       * Execute the bulk operation
       *
       * @method
       * @param {WriteConcern} [_writeConcern] Optional write concern. Can also be specified through options.
       * @param {object} [options] Optional settings.
       * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.
       * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.
       * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.
       * @param {boolean} [options.fsync=false] **Deprecated** Specify a file sync write concern. Use writeConcern instead.
       * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.
       * @param {BulkOperationBase~resultCallback} [callback] A callback that will be invoked when bulkWrite finishes/errors
       * @throws {MongoError} Throws error if the bulk object has already been executed
       * @throws {MongoError} Throws error if the bulk object does not have any operations
       * @return {Promise|void} returns Promise if no callback passed
       */
      execute(_writeConcern, options, callback) {
        const ret = this.bulkExecute(_writeConcern, options, callback);
        if (!ret || isPromiseLike(ret)) {
          return ret;
        }
        options = ret.options;
        callback = ret.callback;
        return executeLegacyOperation(this.s.topology, executeCommands, [this, options, callback]);
      }
      /**
       * Handles final options before executing command
       *
       * An internal method. Do not invoke. Will not be accessible in the future
       *
       * @ignore
       * @param {object} config
       * @param {object} config.options
       * @param {number} config.batch
       * @param {function} config.resultHandler
       * @param {function} callback
       */
      finalOptionsHandler(config, callback) {
        const finalOptions = Object.assign({ ordered: this.isOrdered }, config.options);
        if (this.s.writeConcern != null) {
          finalOptions.writeConcern = this.s.writeConcern;
        }
        if (finalOptions.bypassDocumentValidation !== true) {
          delete finalOptions.bypassDocumentValidation;
        }
        if (this.operationId) {
          config.resultHandler.operationId = this.operationId;
        }
        if (this.s.options.serializeFunctions) {
          finalOptions.serializeFunctions = true;
        }
        if (this.s.options.ignoreUndefined) {
          finalOptions.ignoreUndefined = true;
        }
        if (this.s.bypassDocumentValidation === true) {
          finalOptions.bypassDocumentValidation = true;
        }
        if (this.s.checkKeys === false) {
          finalOptions.checkKeys = false;
        }
        if (finalOptions.retryWrites) {
          if (config.batch.batchType === UPDATE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.multi);
          }
          if (config.batch.batchType === REMOVE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.limit === 0);
          }
        }
        try {
          if (config.batch.batchType === INSERT) {
            this.s.topology.insert(
              this.s.namespace,
              config.batch.operations,
              finalOptions,
              config.resultHandler
            );
          } else if (config.batch.batchType === UPDATE) {
            this.s.topology.update(
              this.s.namespace,
              config.batch.operations,
              finalOptions,
              config.resultHandler
            );
          } else if (config.batch.batchType === REMOVE) {
            this.s.topology.remove(
              this.s.namespace,
              config.batch.operations,
              finalOptions,
              config.resultHandler
            );
          }
        } catch (err) {
          err.ok = 0;
          handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));
        }
      }
      /**
       * Handles the write error before executing commands
       *
       * An internal helper method. Do not invoke directly. Will be going away in the future
       *
       * @ignore
       * @param {function} callback
       * @param {BulkWriteResult} writeResult
       * @param {class} self either OrderedBulkOperation or UnorderedBulkOperation
       */
      handleWriteError(callback, writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
          const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
          handleCallback(
            callback,
            new BulkWriteError(
              toError({
                message: msg,
                code: this.s.bulkResult.writeErrors[0].code,
                writeErrors: this.s.bulkResult.writeErrors
              }),
              writeResult
            ),
            null
          );
          return true;
        }
        if (writeResult.getWriteConcernError()) {
          handleCallback(
            callback,
            new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult),
            null
          );
          return true;
        }
      }
    };
    Object.defineProperty(BulkOperationBase.prototype, "length", {
      enumerable: true,
      get: function() {
        return this.s.currentIndex;
      }
    });
    module2.exports = {
      Batch,
      BulkOperationBase,
      mergeBatchResults,
      bson,
      INSERT,
      UPDATE,
      REMOVE,
      BulkWriteError,
      BulkWriteResult
    };
  }
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS({
  "node_modules/mongodb/lib/bulk/unordered.js"(exports2, module2) {
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document) {
      const bsonSize = bson.calculateObjectSize(document, {
        checkKeys: false,
        // Since we don't know what the user selected for BSON options here,
        // err on the safe side, and check the size with ignoreUndefined: false.
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      bulkOperation.s.currentBatch = null;
      if (docType === common.INSERT) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;
      }
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      if (
        // New batch if we exceed the max batch op size
        bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
        // since we can't sent an empty batch
        bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
        bulkOperation.s.currentBatch.batchType !== docType
      ) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      }
      if (Array.isArray(document)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.operations.push(document);
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
      if (docType === common.INSERT) {
        bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.bulkResult.insertedIds.length,
          _id: document._id
        });
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;
      }
      bulkOperation.s.currentBatch.size += 1;
      bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return bulkOperation;
    }
    var UnorderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options) {
        options = options || {};
        options = Object.assign(options, { addToOperationsList });
        super(topology, collection, options, false);
      }
      handleWriteError(callback, writeResult) {
        if (this.s.batches.length) {
          return false;
        }
        return super.handleWriteError(callback, writeResult);
      }
    };
    function initializeUnorderedBulkOp(topology, collection, options) {
      return new UnorderedBulkOperation(topology, collection, options);
    }
    initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
    module2.exports = initializeUnorderedBulkOp;
    module2.exports.Bulk = UnorderedBulkOperation;
  }
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS({
  "node_modules/mongodb/lib/bulk/ordered.js"(exports2, module2) {
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document) {
      const bsonSize = bson.calculateObjectSize(document, {
        checkKeys: false,
        // Since we don't know what the user selected for BSON options here,
        // err on the safe side, and check the size with ignoreUndefined: false.
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (
        // New batch if we exceed the max batch op size
        bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
        // since we can't sent an empty batch
        bulkOperation.s.currentBatchSize > 0 && bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
        bulkOperation.s.currentBatch.batchType !== docType
      ) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
        bulkOperation.s.currentBatchSize = 0;
        bulkOperation.s.currentBatchSizeBytes = 0;
      }
      if (docType === common.INSERT) {
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.currentIndex,
          _id: document._id
        });
      }
      if (Array.isArray(document)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentBatch.operations.push(document);
      bulkOperation.s.currentBatchSize += 1;
      bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      bulkOperation.s.currentIndex += 1;
      return bulkOperation;
    }
    var OrderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options) {
        options = options || {};
        options = Object.assign(options, { addToOperationsList });
        super(topology, collection, options, true);
      }
    };
    function initializeOrderedBulkOp(topology, collection, options) {
      return new OrderedBulkOperation(topology, collection, options);
    }
    initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
    module2.exports = initializeOrderedBulkOp;
    module2.exports.Bulk = OrderedBulkOperation;
  }
});

// node_modules/mongodb/lib/error.js
var require_error2 = __commonJS({
  "node_modules/mongodb/lib/error.js"(exports2, module2) {
    "use strict";
    var MongoNetworkError = require_core().MongoNetworkError;
    var MONGODB_ERROR_CODES = require_error_codes().MONGODB_ERROR_CODES;
    var GET_MORE_RESUMABLE_CODES = /* @__PURE__ */ new Set([
      MONGODB_ERROR_CODES.HostUnreachable,
      MONGODB_ERROR_CODES.HostNotFound,
      MONGODB_ERROR_CODES.NetworkTimeout,
      MONGODB_ERROR_CODES.ShutdownInProgress,
      MONGODB_ERROR_CODES.PrimarySteppedDown,
      MONGODB_ERROR_CODES.ExceededTimeLimit,
      MONGODB_ERROR_CODES.SocketException,
      MONGODB_ERROR_CODES.NotMaster,
      MONGODB_ERROR_CODES.InterruptedAtShutdown,
      MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      MONGODB_ERROR_CODES.NotMasterNoSlaveOk,
      MONGODB_ERROR_CODES.NotMasterOrSecondary,
      MONGODB_ERROR_CODES.StaleShardVersion,
      MONGODB_ERROR_CODES.StaleEpoch,
      MONGODB_ERROR_CODES.StaleConfig,
      MONGODB_ERROR_CODES.RetryChangeStream,
      MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
      MONGODB_ERROR_CODES.CursorNotFound
    ]);
    function isResumableError(error, wireVersion) {
      if (error instanceof MongoNetworkError) {
        return true;
      }
      if (wireVersion >= 9) {
        if (error.code === MONGODB_ERROR_CODES.CursorNotFound) {
          return true;
        }
        return error.hasErrorLabel("ResumableChangeStreamError");
      }
      return GET_MORE_RESUMABLE_CODES.has(error.code);
    }
    module2.exports = { GET_MORE_RESUMABLE_CODES, isResumableError, MONGODB_ERROR_CODES };
  }
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/mongodb/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SYSTEM_NAMESPACE_COLLECTION: "system.namespaces",
      SYSTEM_INDEX_COLLECTION: "system.indexes",
      SYSTEM_PROFILE_COLLECTION: "system.profile",
      SYSTEM_USER_COLLECTION: "system.users",
      SYSTEM_COMMAND_COLLECTION: "$cmd",
      SYSTEM_JS_COLLECTION: "system.js"
    };
  }
});

// node_modules/mongodb/lib/operations/db_ops.js
var require_db_ops = __commonJS({
  "node_modules/mongodb/lib/operations/db_ops.js"(exports2, module2) {
    "use strict";
    var MONGODB_ERROR_CODES = require_error_codes().MONGODB_ERROR_CODES;
    var applyWriteConcern = require_utils().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var debugOptions = require_utils().debugOptions;
    var handleCallback = require_utils().handleCallback;
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils().parseIndexOptions;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils().toError;
    var extractCommand = require_command_utils().extractCommand;
    var CONSTANTS = require_constants2();
    var MongoDBNamespace = require_utils().MongoDBNamespace;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    function createIndex(db, name, fieldOrSpec, options, callback) {
      let finalOptions = Object.assign({}, { readPreference: ReadPreference.PRIMARY }, options);
      finalOptions = applyWriteConcern(finalOptions, { db }, options);
      if (finalOptions.writeConcern && typeof callback !== "function") {
        throw MongoError.create({
          message: "Cannot use a writeConcern without a provided callback",
          driver: true
        });
      }
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {
        if (err == null)
          return handleCallback(callback, err, result);
        if (err.code === MONGODB_ERROR_CODES.CannotCreateIndex || err.code === MONGODB_ERROR_CODES.DuplicateKey || err.code === MONGODB_ERROR_CODES.IndexOptionsConflict || err.code === MONGODB_ERROR_CODES.IndexKeySpecsConflict || err.code === MONGODB_ERROR_CODES.InterruptedAtShutdown || err.code === MONGODB_ERROR_CODES.InvalidIndexSpecificationOption) {
          return handleCallback(callback, err, result);
        }
        const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);
        finalOptions.checkKeys = false;
        db.s.topology.insert(
          db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION),
          doc,
          finalOptions,
          (err2, result2) => {
            if (callback == null)
              return;
            if (err2)
              return handleCallback(callback, err2);
            if (result2 == null)
              return handleCallback(callback, null, null);
            if (result2.result.writeErrors)
              return handleCallback(callback, MongoError.create(result2.result.writeErrors[0]), null);
            handleCallback(callback, null, doc.name);
          }
        );
      });
    }
    function createListener(db, e, object2) {
      function listener(err) {
        if (object2.listeners(e).length > 0) {
          object2.emit(e, err, db);
          for (let i = 0; i < db.s.children.length; i++) {
            db.s.children[i].emit(e, err, db.s.children[i]);
          }
        }
      }
      return listener;
    }
    function ensureIndex(db, name, fieldOrSpec, options, callback) {
      const finalOptions = applyWriteConcern({}, { db }, options);
      const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);
      const index_name = selector.name;
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      finalOptions.readPreference = ReadPreference.PRIMARY;
      indexInformation(db, name, finalOptions, (err, indexInformation2) => {
        if (err != null && err.code !== MONGODB_ERROR_CODES.NamespaceNotFound) {
          return handleCallback(callback, err, null);
        }
        if (indexInformation2 == null || !indexInformation2[index_name]) {
          createIndex(db, name, fieldOrSpec, options, callback);
        } else {
          if (typeof callback === "function")
            return handleCallback(callback, null, index_name);
        }
      });
    }
    function evaluate(db, code, parameters, options, callback) {
      let finalCode = code;
      let finalParameters = [];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      if (!(finalCode && finalCode._bsontype === "Code"))
        finalCode = new Code2(finalCode);
      if (parameters != null && !Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = [parameters];
      } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = parameters;
      }
      let cmd = { $eval: finalCode, args: finalParameters };
      if (options["nolock"]) {
        cmd["nolock"] = options["nolock"];
      }
      options.readPreference = new ReadPreference(ReadPreference.PRIMARY);
      executeCommand(db, cmd, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result && result.ok === 1)
          return handleCallback(callback, null, result.retval);
        if (result)
          return handleCallback(
            callback,
            MongoError.create({ message: `eval failed: ${result.errmsg}`, driver: true }),
            null
          );
        handleCallback(callback, err, result);
      });
    }
    function executeCommand(db, command, options, callback) {
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      const dbName = options.dbName || options.authdb || db.databaseName;
      options.readPreference = ReadPreference.resolve(db, options);
      if (db.s.logger.isDebug()) {
        const extractedCommand = extractCommand(command);
        db.s.logger.debug(
          `executing command ${JSON.stringify(
            extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : command
          )} against ${dbName}.$cmd with options [${JSON.stringify(
            debugOptions(debugFields, options)
          )}]`
        );
      }
      db.s.topology.command(db.s.namespace.withCollection("$cmd"), command, options, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (options.full)
          return handleCallback(callback, null, result);
        handleCallback(callback, null, result.result);
      });
    }
    function executeDbAdminCommand(db, command, options, callback) {
      const namespace = new MongoDBNamespace("admin", "$cmd");
      db.s.topology.command(namespace, command, options, (err, result) => {
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, result.result);
      });
    }
    function indexInformation(db, name, options, callback) {
      const full = options["full"] == null ? false : options["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index = indexes[i];
          info[index.name] = [];
          for (let name2 in index.key) {
            info[index.name].push([name2, index.key[name2]]);
          }
        }
        return info;
      }
      db.collection(name).listIndexes(options).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function profilingInfo(db, options, callback) {
      try {
        db.collection("system.profile").find({}, options).toArray(callback);
      } catch (err) {
        return callback(err, null);
      }
    }
    function validateDatabaseName(databaseName) {
      if (typeof databaseName !== "string")
        throw MongoError.create({ message: "database name must be a string", driver: true });
      if (databaseName.length === 0)
        throw MongoError.create({ message: "database name cannot be the empty string", driver: true });
      if (databaseName === "$external")
        return;
      const invalidChars = [" ", ".", "$", "/", "\\"];
      for (let i = 0; i < invalidChars.length; i++) {
        if (databaseName.indexOf(invalidChars[i]) !== -1)
          throw MongoError.create({
            message: "database names cannot contain the character '" + invalidChars[i] + "'",
            driver: true
          });
      }
    }
    function createCreateIndexCommand(db, name, fieldOrSpec, options) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const fieldHash = indexParameters.fieldHash;
      const indexName = typeof options.name === "string" ? options.name : indexParameters.name;
      const selector = {
        ns: db.s.namespace.withCollection(name).toString(),
        key: fieldHash,
        name: indexName
      };
      const finalUnique = options == null || "object" === typeof options ? false : options;
      options = options == null || typeof options === "boolean" ? {} : options;
      const keysToOmit = Object.keys(selector);
      for (let optionName in options) {
        if (keysToOmit.indexOf(optionName) === -1) {
          selector[optionName] = options[optionName];
        }
      }
      if (selector["unique"] == null)
        selector["unique"] = finalUnique;
      const removeKeys = ["w", "wtimeout", "j", "fsync", "readPreference", "session"];
      for (let i = 0; i < removeKeys.length; i++) {
        delete selector[removeKeys[i]];
      }
      return selector;
    }
    function createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const indexName = typeof options.name === "string" ? options.name : indexParameters.name;
      const indexes = [{ name: indexName, key: indexParameters.fieldHash }];
      const keysToOmit = Object.keys(indexes[0]).concat([
        "writeConcern",
        "w",
        "wtimeout",
        "j",
        "fsync",
        "readPreference",
        "session"
      ]);
      for (let optionName in options) {
        if (keysToOmit.indexOf(optionName) === -1) {
          indexes[0][optionName] = options[optionName];
        }
      }
      const capabilities = db.s.topology.capabilities();
      if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
        const error = new MongoError("server/primary/mongos does not support collation");
        error.code = 67;
        return callback(error);
      }
      const cmd = applyWriteConcern({ createIndexes: name, indexes }, { db }, options);
      options.readPreference = ReadPreference.PRIMARY;
      executeCommand(db, cmd, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result.ok === 0)
          return handleCallback(callback, toError(result), null);
        handleCallback(callback, null, indexName);
      });
    }
    module2.exports = {
      createListener,
      createIndex,
      ensureIndex,
      evaluate,
      executeCommand,
      executeDbAdminCommand,
      indexInformation,
      profilingInfo,
      validateDatabaseName
    };
  }
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS({
  "node_modules/mongodb/lib/operations/common_functions.js"(exports2, module2) {
    "use strict";
    var applyRetryableWrites = require_utils().applyRetryableWrites;
    var applyWriteConcern = require_utils().applyWriteConcern;
    var decorateWithCollation = require_utils().decorateWithCollation;
    var decorateWithReadConcern = require_utils().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils().formattedOrderClause;
    var handleCallback = require_utils().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils().toError;
    var CursorState = require_cursor().CursorState;
    var maxWireVersion = require_utils3().maxWireVersion;
    function buildCountCommand(collectionOrCursor, query, options) {
      const skip = options.skip;
      const limit = options.limit;
      let hint = options.hint;
      const maxTimeMS = options.maxTimeMS;
      query = query || {};
      const cmd = {
        count: options.collectionName,
        query
      };
      if (collectionOrCursor.s.numberOfRetries) {
        if (collectionOrCursor.options.hint) {
          hint = collectionOrCursor.options.hint;
        } else if (collectionOrCursor.cmd.hint) {
          hint = collectionOrCursor.cmd.hint;
        }
        decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);
      } else {
        decorateWithCollation(cmd, collectionOrCursor, options);
      }
      if (typeof skip === "number")
        cmd.skip = skip;
      if (typeof limit === "number")
        cmd.limit = limit;
      if (typeof maxTimeMS === "number")
        cmd.maxTimeMS = maxTimeMS;
      if (hint)
        cmd.hint = hint;
      decorateWithReadConcern(cmd, collectionOrCursor);
      return cmd;
    }
    function findAndModify(coll, query, sort, doc, options, callback) {
      const queryObject = {
        findAndModify: coll.collectionName,
        query
      };
      sort = formattedOrderClause(sort);
      if (sort) {
        queryObject.sort = sort;
      }
      queryObject.new = options.new ? true : false;
      queryObject.remove = options.remove ? true : false;
      queryObject.upsert = options.upsert ? true : false;
      const projection = options.projection || options.fields;
      if (projection) {
        queryObject.fields = projection;
      }
      if (options.arrayFilters) {
        queryObject.arrayFilters = options.arrayFilters;
        delete options.arrayFilters;
      }
      if (doc && !options.remove) {
        queryObject.update = doc;
      }
      if (options.maxTimeMS)
        queryObject.maxTimeMS = options.maxTimeMS;
      options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
      options.checkKeys = false;
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
      if (finalOptions.writeConcern) {
        queryObject.writeConcern = finalOptions.writeConcern;
      }
      if (finalOptions.bypassDocumentValidation === true) {
        queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
      }
      finalOptions.readPreference = ReadPreference.primary;
      try {
        decorateWithCollation(queryObject, coll, finalOptions);
      } catch (err) {
        return callback(err, null);
      }
      executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        return handleCallback(callback, null, result);
      });
    }
    function indexInformation(db, name, options, callback) {
      const full = options["full"] == null ? false : options["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index = indexes[i];
          info[index.name] = [];
          for (let name2 in index.key) {
            info[index.name].push([name2, index.key[name2]]);
          }
        }
        return info;
      }
      db.collection(name).listIndexes(options).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function prepareDocs(coll, docs, options) {
      const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : coll.s.db.options.forceServerObjectId;
      if (forceServerObjectId === true) {
        return docs;
      }
      return docs.map((doc) => {
        if (forceServerObjectId !== true && doc._id == null) {
          doc._id = coll.s.pkFactory.createPk();
        }
        return doc;
      });
    }
    function nextObject(cursor, callback) {
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
        return handleCallback(
          callback,
          MongoError.create({ message: "Cursor is closed", driver: true })
        );
      }
      if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {
        try {
          cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
        } catch (err) {
          return handleCallback(callback, err);
        }
      }
      cursor._next((err, doc) => {
        cursor.s.state = CursorState.OPEN;
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, doc);
      });
    }
    function insertDocuments(coll, docs, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      docs = Array.isArray(docs) ? docs : [docs];
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
      if (finalOptions.keepGoing === true)
        finalOptions.ordered = false;
      finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
      docs = prepareDocs(coll, docs, options);
      coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        result.ops = docs;
        handleCallback(callback, null, result);
      });
    }
    function removeDocuments(coll, selector, options, callback) {
      if (typeof options === "function") {
        callback = options, options = {};
      } else if (typeof selector === "function") {
        callback = selector;
        options = {};
        selector = {};
      }
      options = options || {};
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
      if (selector == null)
        selector = {};
      const op = { q: selector, limit: 0 };
      if (options.single) {
        op.limit = 1;
      } else if (finalOptions.retryWrites) {
        finalOptions.retryWrites = false;
      }
      if (options.hint) {
        op.hint = options.hint;
      }
      try {
        decorateWithCollation(finalOptions, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      if (options.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on remove`)) : void 0;
      }
      coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors) {
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        }
        handleCallback(callback, null, result);
      });
    }
    function updateDocuments(coll, selector, document, options, callback) {
      if ("function" === typeof options)
        callback = options, options = null;
      if (options == null)
        options = {};
      if (!("function" === typeof callback))
        callback = null;
      if (selector == null || typeof selector !== "object")
        return callback(toError("selector must be a valid JavaScript object"));
      if (document == null || typeof document !== "object")
        return callback(toError("document must be a valid JavaScript object"));
      let finalOptions = Object.assign({}, options);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
      finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
      const op = { q: selector, u: document };
      op.upsert = options.upsert !== void 0 ? !!options.upsert : false;
      op.multi = options.multi !== void 0 ? !!options.multi : false;
      if (options.hint) {
        op.hint = options.hint;
      }
      if (finalOptions.arrayFilters) {
        op.arrayFilters = finalOptions.arrayFilters;
        delete finalOptions.arrayFilters;
      }
      if (finalOptions.retryWrites && op.multi) {
        finalOptions.retryWrites = false;
      }
      try {
        decorateWithCollation(finalOptions, coll, options);
      } catch (err) {
        return callback(err, null);
      }
      if (options.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on update`)) : void 0;
      }
      coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      buildCountCommand,
      findAndModify,
      indexInformation,
      nextObject,
      prepareDocs,
      insertDocuments,
      removeDocuments,
      updateDocuments
    };
  }
});

// node_modules/mongodb/lib/operations/collection_ops.js
var require_collection_ops = __commonJS({
  "node_modules/mongodb/lib/operations/collection_ops.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var createIndexDb = require_db_ops().createIndex;
    var decorateWithCollation = require_utils().decorateWithCollation;
    var decorateWithReadConcern = require_utils().decorateWithReadConcern;
    var ensureIndexDb = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var insertDocuments = require_common_functions().insertDocuments;
    var updateDocuments = require_common_functions().updateDocuments;
    var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
    function createIndex(coll, fieldOrSpec, options, callback) {
      createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);
    }
    function createIndexes(coll, indexSpecs, options, callback) {
      const capabilities = coll.s.topology.capabilities();
      for (let i = 0; i < indexSpecs.length; i++) {
        if (indexSpecs[i].name == null) {
          const keys = [];
          if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
            return callback(new MongoError("server/primary/mongos does not support collation"));
          }
          for (let name in indexSpecs[i].key) {
            keys.push(`${name}_${indexSpecs[i].key[name]}`);
          }
          indexSpecs[i].name = keys.join("_");
        }
      }
      options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });
      executeCommand(
        coll.s.db,
        {
          createIndexes: coll.collectionName,
          indexes: indexSpecs
        },
        options,
        callback
      );
    }
    function ensureIndex(coll, fieldOrSpec, options, callback) {
      ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options, callback);
    }
    function group(coll, keys, condition, initial, reduce, finalize, command, options, callback) {
      if (command) {
        const reduceFunction = reduce && reduce._bsontype === "Code" ? reduce : new Code2(reduce);
        const selector = {
          group: {
            ns: coll.collectionName,
            $reduce: reduceFunction,
            cond: condition,
            initial,
            out: "inline"
          }
        };
        if (finalize != null)
          selector.group["finalize"] = finalize;
        if ("function" === typeof keys || keys && keys._bsontype === "Code") {
          selector.group.$keyf = keys && keys._bsontype === "Code" ? keys : new Code2(keys);
        } else {
          const hash2 = {};
          keys.forEach((key) => {
            hash2[key] = 1;
          });
          selector.group.key = hash2;
        }
        options = Object.assign({}, options);
        options.readPreference = ReadPreference.resolve(coll, options);
        decorateWithReadConcern(selector, coll, options);
        try {
          decorateWithCollation(selector, coll, options);
        } catch (err) {
          return callback(err, null);
        }
        executeCommand(coll.s.db, selector, options, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result.retval);
        });
      } else {
        const scope = reduce != null && reduce._bsontype === "Code" ? reduce.scope : {};
        scope.ns = coll.collectionName;
        scope.keys = keys;
        scope.condition = condition;
        scope.initial = initial;
        const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ";");
        evaluate(coll.s.db, new Code2(groupfn, scope), null, options, (err, results) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, results.result || results);
        });
      }
    }
    function indexes(coll, options, callback) {
      options = Object.assign({}, { full: true }, options);
      indexInformationDb(coll.s.db, coll.collectionName, options, callback);
    }
    function indexExists(coll, indexes2, options, callback) {
      indexInformation(coll, options, (err, indexInformation2) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (!Array.isArray(indexes2))
          return handleCallback(callback, null, indexInformation2[indexes2] != null);
        for (let i = 0; i < indexes2.length; i++) {
          if (indexInformation2[indexes2[i]] == null) {
            return handleCallback(callback, null, false);
          }
        }
        return handleCallback(callback, null, true);
      });
    }
    function indexInformation(coll, options, callback) {
      indexInformationDb(coll.s.db, coll.collectionName, options, callback);
    }
    function parallelCollectionScan(coll, options, callback) {
      const commandObject = {
        parallelCollectionScan: coll.collectionName,
        numCursors: options.numCursors
      };
      decorateWithReadConcern(commandObject, coll, options);
      const raw = options.raw;
      delete options["raw"];
      executeCommand(coll.s.db, commandObject, options, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(
            callback,
            new Error("no result returned for parallelCollectionScan"),
            null
          );
        options = Object.assign({ explicitlyIgnoreSession: true }, options);
        const cursors = [];
        if (raw)
          options.raw = raw;
        for (let i = 0; i < result.cursors.length; i++) {
          const rawId = result.cursors[i].cursor.id;
          const cursorId = typeof rawId === "number" ? Long2.fromNumber(rawId) : rawId;
          cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options));
        }
        handleCallback(callback, null, cursors);
      });
    }
    function save(coll, doc, options, callback) {
      const finalOptions = applyWriteConcern(
        Object.assign({}, options),
        { db: coll.s.db, collection: coll },
        options
      );
      if (doc._id != null) {
        finalOptions.upsert = true;
        return updateDocuments(coll, { _id: doc._id }, doc, finalOptions, callback);
      }
      insertDocuments(coll, [doc], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (doc == null)
          return handleCallback(callback, null, null);
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      createIndex,
      createIndexes,
      ensureIndex,
      group,
      indexes,
      indexExists,
      indexInformation,
      parallelCollectionScan,
      save
    };
  }
});

// node_modules/mongodb/lib/operations/cursor_ops.js
var require_cursor_ops = __commonJS({
  "node_modules/mongodb/lib/operations/cursor_ops.js"(exports2, module2) {
    "use strict";
    var buildCountCommand = require_collection_ops().buildCountCommand;
    var handleCallback = require_utils().handleCallback;
    var MongoError = require_core().MongoError;
    var push = Array.prototype.push;
    var CursorState = require_cursor().CursorState;
    function count(cursor, applySkipLimit, opts, callback) {
      if (applySkipLimit) {
        if (typeof cursor.cursorSkip() === "number")
          opts.skip = cursor.cursorSkip();
        if (typeof cursor.cursorLimit() === "number")
          opts.limit = cursor.cursorLimit();
      }
      if (opts.readPreference) {
        cursor.setReadPreference(opts.readPreference);
      }
      if (typeof opts.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
        opts.maxTimeMS = cursor.cmd.maxTimeMS;
      }
      let options = {};
      options.skip = opts.skip;
      options.limit = opts.limit;
      options.hint = opts.hint;
      options.maxTimeMS = opts.maxTimeMS;
      options.collectionName = cursor.namespace.collection;
      let command;
      try {
        command = buildCountCommand(cursor, cursor.cmd.query, options);
      } catch (err) {
        return callback(err);
      }
      cursor.server = cursor.topology.s.coreTopology;
      cursor.topology.command(
        cursor.namespace.withCollection("$cmd"),
        command,
        cursor.options,
        (err, result) => {
          callback(err, result ? result.result.n : null);
        }
      );
    }
    function each(cursor, callback) {
      if (!callback)
        throw MongoError.create({ message: "callback is mandatory", driver: true });
      if (cursor.isNotified())
        return;
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {
        return handleCallback(
          callback,
          MongoError.create({ message: "Cursor is closed", driver: true })
        );
      }
      if (cursor.s.state === CursorState.INIT) {
        cursor.s.state = CursorState.OPEN;
      }
      let fn = null;
      if (cursor.bufferedCount() > 0) {
        while (fn = loop(cursor, callback))
          fn(cursor, callback);
        each(cursor, callback);
      } else {
        cursor.next((err, item) => {
          if (err)
            return handleCallback(callback, err);
          if (item == null) {
            return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, null));
          }
          if (handleCallback(callback, null, item) === false)
            return;
          each(cursor, callback);
        });
      }
    }
    function loop(cursor, callback) {
      if (cursor.bufferedCount() === 0)
        return;
      cursor._next(callback);
      return loop;
    }
    function toArray(cursor, callback) {
      const items = [];
      cursor.rewind();
      cursor.s.state = CursorState.INIT;
      const fetchDocs = () => {
        cursor._next((err, doc) => {
          if (err) {
            return handleCallback(callback, err);
          }
          if (doc == null) {
            return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));
          }
          items.push(doc);
          if (cursor.bufferedCount() > 0) {
            let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
            if (cursor.s.transforms && typeof cursor.s.transforms.doc === "function") {
              docs = docs.map(cursor.s.transforms.doc);
            }
            push.apply(items, docs);
          }
          fetchDocs();
        });
      };
      fetchDocs();
    }
    module2.exports = { count, each, toArray };
  }
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS({
  "node_modules/mongodb/lib/operations/count.js"(exports2, module2) {
    "use strict";
    var buildCountCommand = require_common_functions().buildCountCommand;
    var OperationBase = require_operation().OperationBase;
    var CountOperation = class extends OperationBase {
      constructor(cursor, applySkipLimit, options) {
        super(options);
        this.cursor = cursor;
        this.applySkipLimit = applySkipLimit;
      }
      execute(callback) {
        const cursor = this.cursor;
        const applySkipLimit = this.applySkipLimit;
        const options = this.options;
        if (applySkipLimit) {
          if (typeof cursor.cursorSkip() === "number")
            options.skip = cursor.cursorSkip();
          if (typeof cursor.cursorLimit() === "number")
            options.limit = cursor.cursorLimit();
        }
        if (options.readPreference) {
          cursor.setReadPreference(options.readPreference);
        }
        if (typeof options.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
          options.maxTimeMS = cursor.cmd.maxTimeMS;
        }
        let finalOptions = {};
        finalOptions.skip = options.skip;
        finalOptions.limit = options.limit;
        finalOptions.hint = options.hint;
        finalOptions.maxTimeMS = options.maxTimeMS;
        finalOptions.collectionName = cursor.namespace.collection;
        let command;
        try {
          command = buildCountCommand(cursor, cursor.cmd.query, finalOptions);
        } catch (err) {
          return callback(err);
        }
        cursor.server = cursor.topology.s.coreTopology;
        cursor.topology.command(
          cursor.namespace.withCollection("$cmd"),
          command,
          cursor.options,
          (err, result) => {
            callback(err, result ? result.result.n : null);
          }
        );
      }
    };
    module2.exports = CountOperation;
  }
});

// node_modules/mongodb/lib/cursor.js
var require_cursor2 = __commonJS({
  "node_modules/mongodb/lib/cursor.js"(exports2, module2) {
    "use strict";
    var Transform = __require("stream").Transform;
    var PassThrough = __require("stream").PassThrough;
    var deprecate = __require("util").deprecate;
    var handleCallback = require_utils().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var CoreCursor = require_cursor().CoreCursor;
    var CursorState = require_cursor().CursorState;
    var Map2 = require_core().BSON.Map;
    var maybePromise = require_utils().maybePromise;
    var executeOperation = require_execute_operation();
    var formattedOrderClause = require_utils().formattedOrderClause;
    var Explain = require_explain().Explain;
    var Aspect = require_operation().Aspect;
    var each = require_cursor_ops().each;
    var CountOperation = require_count();
    var flags = ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];
    var fields = ["numberOfRetries", "tailableRetryInterval"];
    var Cursor = class _Cursor extends CoreCursor {
      constructor(topology, ns, cmd, options) {
        super(topology, ns, cmd, options);
        if (this.operation) {
          options = this.operation.options;
        }
        const numberOfRetries = options.numberOfRetries || 5;
        const tailableRetryInterval = options.tailableRetryInterval || 500;
        const currentNumberOfRetries = numberOfRetries;
        const promiseLibrary = options.promiseLibrary || Promise;
        this.s = {
          // Tailable cursor options
          numberOfRetries,
          tailableRetryInterval,
          currentNumberOfRetries,
          // State
          state: CursorState.INIT,
          // Promise library
          promiseLibrary,
          // explicitlyIgnoreSession
          explicitlyIgnoreSession: !!options.explicitlyIgnoreSession
        };
        if (!options.explicitlyIgnoreSession && options.session) {
          this.cursorState.session = options.session;
        }
        if (this.options.noCursorTimeout === true) {
          this.addCursorFlag("noCursorTimeout", true);
        }
        let batchSize = 1e3;
        if (this.cmd.cursor && this.cmd.cursor.batchSize) {
          batchSize = this.cmd.cursor.batchSize;
        } else if (options.cursor && options.cursor.batchSize) {
          batchSize = options.cursor.batchSize;
        } else if (typeof options.batchSize === "number") {
          batchSize = options.batchSize;
        }
        this.setCursorBatchSize(batchSize);
      }
      get readPreference() {
        if (this.operation) {
          return this.operation.readPreference;
        }
        return this.options.readPreference;
      }
      get sortValue() {
        return this.cmd.sort;
      }
      set session(clientSession) {
        this.cursorState.session = clientSession;
      }
      _initializeCursor(callback) {
        if (this.operation && this.operation.session != null) {
          this.cursorState.session = this.operation.session;
        } else {
          if (!this.s.explicitlyIgnoreSession && !this.cursorState.session && this.topology.hasSessionSupport()) {
            this.cursorState.session = this.topology.startSession({ owner: this });
            if (this.operation) {
              this.operation.session = this.cursorState.session;
            }
          }
        }
        super._initializeCursor(callback);
      }
      /**
       * Check if there is any document still available in the cursor
       * @method
       * @param {Cursor~resultCallback} [callback] The result callback.
       * @throws {MongoError}
       * @return {Promise} returns Promise if no callback passed
       */
      hasNext(callback) {
        if (this.s.state === CursorState.CLOSED || this.isDead && this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.isNotified()) {
            return cb(null, false);
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            if (doc == null || cursor.s.state === _Cursor.CLOSED || cursor.isDead()) {
              return cb(null, false);
            }
            cursor.s.state = CursorState.OPEN;
            cursor.cursorState.cursorIndex--;
            if (cursor.cursorState.limit > 0) {
              cursor.cursorState.currentLimit--;
            }
            cb(null, true);
          });
        });
      }
      /**
       * Get the next available document from the cursor, returns null if no more documents are available.
       * @method
       * @param {Cursor~resultCallback} [callback] The result callback.
       * @throws {MongoError}
       * @return {Promise} returns Promise if no callback passed
       */
      next(callback) {
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
            cb(MongoError.create({ message: "Cursor is closed", driver: true }));
            return;
          }
          if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {
            try {
              cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
            } catch (err) {
              return cb(err);
            }
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            cursor.s.state = CursorState.OPEN;
            cb(null, doc);
          });
        });
      }
      /**
       * Set the cursor query
       * @method
       * @param {object} filter The filter object used for the cursor.
       * @return {Cursor}
       */
      filter(filter) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.query = filter;
        return this;
      }
      /**
       * Set the cursor maxScan
       * @method
       * @param {object} maxScan Constrains the query to only scan the specified number of documents when fulfilling the query
       * @deprecated as of MongoDB 4.0
       * @return {Cursor}
       */
      maxScan(maxScan) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxScan = maxScan;
        return this;
      }
      /**
       * Set the cursor hint
       * @method
       * @param {object} hint If specified, then the query system will only consider plans using the hinted index.
       * @return {Cursor}
       */
      hint(hint) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.hint = hint;
        return this;
      }
      /**
       * Set the cursor min
       * @method
       * @param {object} min Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.
       * @return {Cursor}
       */
      min(min) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.min = min;
        return this;
      }
      /**
       * Set the cursor max
       * @method
       * @param {object} max Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.
       * @return {Cursor}
       */
      max(max) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.max = max;
        return this;
      }
      /**
       * Set the cursor returnKey. If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents. If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.
       * @method
       * @param {bool} returnKey the returnKey value.
       * @return {Cursor}
       */
      returnKey(value2) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.returnKey = value2;
        return this;
      }
      /**
       * Set the cursor showRecordId
       * @method
       * @param {object} showRecordId The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.
       * @return {Cursor}
       */
      showRecordId(value2) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.showDiskLoc = value2;
        return this;
      }
      /**
       * Set the cursor snapshot
       * @method
       * @param {object} snapshot The $snapshot operator prevents the cursor from returning a document more than once because an intervening write operation results in a move of the document.
       * @deprecated as of MongoDB 4.0
       * @return {Cursor}
       */
      snapshot(value2) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.snapshot = value2;
        return this;
      }
      /**
       * Set a node.js specific cursor option
       * @method
       * @param {string} field The cursor option to set ['numberOfRetries', 'tailableRetryInterval'].
       * @param {object} value The field value.
       * @throws {MongoError}
       * @return {Cursor}
       */
      setCursorOption(field, value2) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (fields.indexOf(field) === -1) {
          throw MongoError.create({
            message: `option ${field} is not a supported option ${fields}`,
            driver: true
          });
        }
        this.s[field] = value2;
        if (field === "numberOfRetries")
          this.s.currentNumberOfRetries = value2;
        return this;
      }
      /**
       * Add a cursor flag to the cursor
       * @method
       * @param {string} flag The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial'].
       * @param {boolean} value The flag boolean value.
       * @throws {MongoError}
       * @return {Cursor}
       */
      addCursorFlag(flag, value2) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (flags.indexOf(flag) === -1) {
          throw MongoError.create({
            message: `flag ${flag} is not a supported flag ${flags}`,
            driver: true
          });
        }
        if (typeof value2 !== "boolean") {
          throw MongoError.create({ message: `flag ${flag} must be a boolean value`, driver: true });
        }
        this.cmd[flag] = value2;
        return this;
      }
      /**
       * Add a query modifier to the cursor query
       * @method
       * @param {string} name The query modifier (must start with $, such as $orderby etc)
       * @param {string|boolean|number} value The modifier value.
       * @throws {MongoError}
       * @return {Cursor}
       */
      addQueryModifier(name, value2) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (name[0] !== "$") {
          throw MongoError.create({ message: `${name} is not a valid query modifier`, driver: true });
        }
        const field = name.substr(1);
        this.cmd[field] = value2;
        if (field === "orderby")
          this.cmd.sort = this.cmd[field];
        return this;
      }
      /**
       * Add a comment to the cursor query allowing for tracking the comment in the log.
       * @method
       * @param {string} value The comment attached to this query.
       * @throws {MongoError}
       * @return {Cursor}
       */
      comment(value2) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.comment = value2;
        return this;
      }
      /**
       * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)
       * @method
       * @param {number} value Number of milliseconds to wait before aborting the tailed query.
       * @throws {MongoError}
       * @return {Cursor}
       */
      maxAwaitTimeMS(value2) {
        if (typeof value2 !== "number") {
          throw MongoError.create({ message: "maxAwaitTimeMS must be a number", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxAwaitTimeMS = value2;
        return this;
      }
      /**
       * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
       * @method
       * @param {number} value Number of milliseconds to wait before aborting the query.
       * @throws {MongoError}
       * @return {Cursor}
       */
      maxTimeMS(value2) {
        if (typeof value2 !== "number") {
          throw MongoError.create({ message: "maxTimeMS must be a number", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxTimeMS = value2;
        return this;
      }
      /**
       * Sets a field projection for the query.
       * @method
       * @param {object} value The field projection object.
       * @throws {MongoError}
       * @return {Cursor}
       */
      project(value2) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.fields = value2;
        return this;
      }
      /**
       * Sets the sort order of the cursor query.
       * @method
       * @param {(string|array|object)} keyOrList The key or keys set for the sort.
       * @param {number} [direction] The direction of the sorting (1 or -1).
       * @throws {MongoError}
       * @return {Cursor}
       */
      sort(keyOrList, direction) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support sorting", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        let order = keyOrList;
        if (Array.isArray(order) && Array.isArray(order[0])) {
          order = new Map2(
            order.map((x) => {
              const value2 = [x[0], null];
              if (x[1] === "asc") {
                value2[1] = 1;
              } else if (x[1] === "desc") {
                value2[1] = -1;
              } else if (x[1] === 1 || x[1] === -1 || x[1].$meta) {
                value2[1] = x[1];
              } else {
                throw new MongoError(
                  "Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]"
                );
              }
              return value2;
            })
          );
        }
        if (direction != null) {
          order = [[keyOrList, direction]];
        }
        this.cmd.sort = order;
        return this;
      }
      /**
       * Set the batch size for the cursor.
       * @method
       * @param {number} value The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.
       * @throws {MongoError}
       * @return {Cursor}
       */
      batchSize(value2) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor doesn't support batchSize",
            driver: true
          });
        }
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value2 !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        this.cmd.batchSize = value2;
        this.setCursorBatchSize(value2);
        return this;
      }
      /**
       * Set the collation options for the cursor.
       * @method
       * @param {object} value The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
       * @throws {MongoError}
       * @return {Cursor}
       */
      collation(value2) {
        this.cmd.collation = value2;
        return this;
      }
      /**
       * Set the limit for the cursor.
       * @method
       * @param {number} value The limit for the cursor query.
       * @throws {MongoError}
       * @return {Cursor}
       */
      limit(value2) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support limit", driver: true });
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value2 !== "number") {
          throw MongoError.create({ message: "limit requires an integer", driver: true });
        }
        this.cmd.limit = value2;
        this.setCursorLimit(value2);
        return this;
      }
      /**
       * Set the skip for the cursor.
       * @method
       * @param {number} value The skip for the cursor query.
       * @throws {MongoError}
       * @return {Cursor}
       */
      skip(value2) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support skip", driver: true });
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value2 !== "number") {
          throw MongoError.create({ message: "skip requires an integer", driver: true });
        }
        this.cmd.skip = value2;
        this.setCursorSkip(value2);
        return this;
      }
      /**
       * The callback format for results
       * @callback Cursor~resultCallback
       * @param {MongoError} error An error instance representing the error during the execution.
       * @param {(object|null|boolean)} result The result object if the command was executed successfully.
       */
      /**
       * Clone the cursor
       * @function external:CoreCursor#clone
       * @return {Cursor}
       */
      /**
       * Resets the cursor
       * @function external:CoreCursor#rewind
       * @return {null}
       */
      /**
       * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
       * not all of the elements will be iterated if this cursor had been previously accessed.
       * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
       * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
       * at any given time if batch size is specified. Otherwise, the caller is responsible
       * for making sure that the entire result can fit the memory.
       * @method
       * @deprecated
       * @param {Cursor~resultCallback} callback The result callback.
       * @throws {MongoError}
       * @return {null}
       */
      each(callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        each(this, callback);
      }
      /**
       * The callback format for the forEach iterator method
       * @callback Cursor~iteratorCallback
       * @param {Object} doc An emitted document for the iterator
       */
      /**
       * The callback error format for the forEach iterator method
       * @callback Cursor~endCallback
       * @param {MongoError} error An error instance representing the error during the execution.
       */
      /**
       * Iterates over all the documents for this cursor using the iterator, callback pattern.
       * @method
       * @param {Cursor~iteratorCallback} iterator The iteration callback.
       * @param {Cursor~endCallback} callback The end callback.
       * @throws {MongoError}
       * @return {Promise} if no callback supplied
       */
      forEach(iterator, callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        if (typeof callback === "function") {
          each(this, (err, doc) => {
            if (err) {
              callback(err);
              return false;
            }
            if (doc != null) {
              try {
                iterator(doc);
              } catch (error) {
                callback(error);
                return false;
              }
              return true;
            }
            if (doc == null && callback) {
              const internalCallback = callback;
              callback = null;
              internalCallback(null);
              return false;
            }
          });
        } else {
          return new this.s.promiseLibrary((fulfill, reject) => {
            each(this, (err, doc) => {
              if (err) {
                reject(err);
                return false;
              } else if (doc == null) {
                fulfill(null);
                return false;
              } else {
                try {
                  iterator(doc);
                } catch (error) {
                  reject(error);
                  return false;
                }
                return true;
              }
            });
          });
        }
      }
      /**
       * Set the ReadPreference for the cursor.
       * @method
       * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.
       * @throws {MongoError}
       * @return {Cursor}
       */
      setReadPreference(readPreference) {
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      /**
       * The callback format for results
       * @callback Cursor~toArrayResultCallback
       * @param {MongoError} error An error instance representing the error during the execution.
       * @param {object[]} documents All the documents the satisfy the cursor.
       */
      /**
       * Returns an array of documents. The caller is responsible for making sure that there
       * is enough memory to store the results. Note that the array only contains partial
       * results when this cursor had been previously accessed. In that case,
       * cursor.rewind() can be used to reset the cursor.
       * @method
       * @param {Cursor~toArrayResultCallback} [callback] The result callback.
       * @throws {MongoError}
       * @return {Promise} returns Promise if no callback passed
       */
      toArray(callback) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor cannot be converted to array",
            driver: true
          });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          const items = [];
          cursor.rewind();
          cursor.s.state = CursorState.INIT;
          const fetchDocs = () => {
            cursor._next((err, doc) => {
              if (err) {
                return handleCallback(cb, err);
              }
              if (doc == null) {
                return cursor.close({ skipKillCursors: true }, () => handleCallback(cb, null, items));
              }
              items.push(doc);
              if (cursor.bufferedCount() > 0) {
                let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
                Array.prototype.push.apply(items, docs);
              }
              fetchDocs();
            });
          };
          fetchDocs();
        });
      }
      /**
       * The callback format for results
       * @callback Cursor~countResultCallback
       * @param {MongoError} error An error instance representing the error during the execution.
       * @param {number} count The count of documents.
       */
      /**
       * Get the count of documents for this cursor
       * @method
       * @param {boolean} [applySkipLimit=true] Should the count command apply limit and skip settings on the cursor or in the passed in options.
       * @param {object} [options] Optional settings.
       * @param {number} [options.skip] The number of documents to skip.
       * @param {number} [options.limit] The maximum amounts to count before aborting.
       * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.
       * @param {string} [options.hint] An index name hint for the query.
       * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
       * @param {Cursor~countResultCallback} [callback] The result callback.
       * @return {Promise} returns Promise if no callback passed
       */
      count(applySkipLimit, opts, callback) {
        if (this.cmd.query == null)
          throw MongoError.create({
            message: "count can only be used with find command",
            driver: true
          });
        if (typeof opts === "function")
          callback = opts, opts = {};
        opts = opts || {};
        if (typeof applySkipLimit === "function") {
          callback = applySkipLimit;
          applySkipLimit = true;
        }
        if (this.cursorState.session) {
          opts = Object.assign({}, opts, { session: this.cursorState.session });
        }
        const countOperation = new CountOperation(this, applySkipLimit, opts);
        return executeOperation(this.topology, countOperation, callback);
      }
      /**
       * Close the cursor, sending a KillCursor command and emitting close.
       * @method
       * @param {object} [options] Optional settings.
       * @param {boolean} [options.skipKillCursors] Bypass calling killCursors when closing the cursor.
       * @param {Cursor~resultCallback} [callback] The result callback.
       * @return {Promise} returns Promise if no callback passed
       */
      close(options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = Object.assign({}, { skipKillCursors: false }, options);
        return maybePromise(this, callback, (cb) => {
          this.s.state = CursorState.CLOSED;
          if (!options.skipKillCursors) {
            this.kill();
          }
          this._endSession(() => {
            this.emit("close");
            cb(null, this);
          });
        });
      }
      /**
       * Map all documents using the provided function
       * @method
       * @param {function} [transform] The mapping transformation method.
       * @return {Cursor}
       */
      map(transform) {
        if (this.cursorState.transforms && this.cursorState.transforms.doc) {
          const oldTransform = this.cursorState.transforms.doc;
          this.cursorState.transforms.doc = (doc) => {
            return transform(oldTransform(doc));
          };
        } else {
          this.cursorState.transforms = { doc: transform };
        }
        return this;
      }
      /**
       * Is the cursor closed
       * @method
       * @return {boolean}
       */
      isClosed() {
        return this.isDead();
      }
      destroy(err) {
        if (err)
          this.emit("error", err);
        this.pause();
        this.close();
      }
      /**
       * Return a modified Readable stream including a possible transform method.
       * @method
       * @param {object} [options] Optional settings.
       * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.
       * @return {Cursor}
       * TODO: replace this method with transformStream in next major release
       */
      stream(options) {
        this.cursorState.streamOptions = options || {};
        return this;
      }
      /**
       * Return a modified Readable stream that applies a given transform function, if supplied. If none supplied,
       * returns a stream of unmodified docs.
       * @method
       * @param {object} [options] Optional settings.
       * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.
       * @return {stream}
       */
      transformStream(options) {
        const streamOptions = options || {};
        if (typeof streamOptions.transform === "function") {
          const stream = new Transform({
            objectMode: true,
            transform: function(chunk, encoding, callback) {
              this.push(streamOptions.transform(chunk));
              callback();
            }
          });
          return this.pipe(stream);
        }
        return this.pipe(new PassThrough({ objectMode: true }));
      }
      /**
       * Execute the explain for the cursor
       *
       * For backwards compatibility, a verbosity of true is interpreted as "allPlansExecution"
       * and false as "queryPlanner". Prior to server version 3.6, aggregate()
       * ignores the verbosity parameter and executes in "queryPlanner".
       *
       * @method
       * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [verbosity=true] - An optional mode in which to run the explain.
       * @param {Cursor~resultCallback} [callback] The result callback.
       * @return {Promise} returns Promise if no callback passed
       */
      explain(verbosity, callback) {
        if (typeof verbosity === "function")
          callback = verbosity, verbosity = true;
        if (verbosity === void 0)
          verbosity = true;
        if (!this.operation || !this.operation.hasAspect(Aspect.EXPLAINABLE)) {
          throw new MongoError("This command cannot be explained");
        }
        this.operation.explain = new Explain(verbosity);
        return maybePromise(this, callback, (cb) => {
          CoreCursor.prototype._next.apply(this, [cb]);
        });
      }
      /**
       * Return the cursor logger
       * @method
       * @return {Logger} return the cursor logger
       * @ignore
       */
      getLogger() {
        return this.logger;
      }
    };
    Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
    deprecate(Cursor.prototype.each, "Cursor.each is deprecated. Use Cursor.forEach instead.");
    deprecate(
      Cursor.prototype.maxScan,
      "Cursor.maxScan is deprecated, and will be removed in a later version"
    );
    deprecate(
      Cursor.prototype.snapshot,
      "Cursor Snapshot is deprecated, and will be removed in a later version"
    );
    module2.exports = Cursor;
  }
});

// node_modules/mongodb/lib/operations/command_v2.js
var require_command_v2 = __commonJS({
  "node_modules/mongodb/lib/operations/command_v2.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var maxWireVersion = require_utils3().maxWireVersion;
    var decorateWithExplain = require_utils().decorateWithExplain;
    var commandSupportsReadConcern = require_sessions().commandSupportsReadConcern;
    var MongoError = require_error().MongoError;
    var extractCommand = require_command_utils().extractCommand;
    var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
    var CommandOperationV2 = class extends OperationBase {
      constructor(parent, options, operationOptions) {
        super(options);
        this.ns = parent.s.namespace.withCollection("$cmd");
        const propertyProvider = this.hasAspect(Aspect.NO_INHERIT_OPTIONS) ? void 0 : parent;
        this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION) ? ReadPreference.primary : ReadPreference.resolve(propertyProvider, this.options);
        this.readConcern = resolveReadConcern(propertyProvider, this.options);
        this.writeConcern = resolveWriteConcern(propertyProvider, this.options);
        if (operationOptions && typeof operationOptions.fullResponse === "boolean") {
          this.fullResponse = true;
        }
        this.options.readPreference = this.readPreference;
        if (parent.s.logger) {
          this.logger = parent.s.logger;
        } else if (parent.s.db && parent.s.db.logger) {
          this.logger = parent.s.db.logger;
        }
      }
      executeCommand(server, cmd, callback) {
        this.server = server;
        const options = this.options;
        const serverWireVersion = maxWireVersion(server);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && commandSupportsReadConcern(cmd) && !inTransaction) {
          Object.assign(cmd, { readConcern: this.readConcern });
        }
        if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          callback(
            new MongoError(
              `Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`
            )
          );
          return;
        }
        if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION)) {
            Object.assign(cmd, { writeConcern: this.writeConcern });
          }
          if (options.collation && typeof options.collation === "object") {
            Object.assign(cmd, { collation: options.collation });
          }
        }
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        if (typeof options.comment === "string") {
          cmd.comment = options.comment;
        }
        if (this.hasAspect(Aspect.EXPLAINABLE) && this.explain) {
          if (serverWireVersion < 6 && cmd.aggregate) {
            cmd.explain = true;
          } else {
            cmd = decorateWithExplain(cmd, this.explain);
          }
        }
        if (this.logger && this.logger.isDebug()) {
          const extractedCommand = extractCommand(cmd);
          this.logger.debug(
            `executing command ${JSON.stringify(
              extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd
            )} against ${this.ns}`
          );
        }
        server.command(this.ns.toString(), cmd, this.options, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          if (this.fullResponse) {
            callback(null, result);
            return;
          }
          callback(null, result.result);
        });
      }
    };
    function resolveWriteConcern(parent, options) {
      return WriteConcern.fromOptions(options) || parent && parent.writeConcern;
    }
    function resolveReadConcern(parent, options) {
      return ReadConcern.fromOptions(options) || parent && parent.readConcern;
    }
    module2.exports = CommandOperationV2;
  }
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/mongodb/lib/operations/aggregate.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var maxWireVersion = require_utils3().maxWireVersion;
    var ReadPreference = require_core().ReadPreference;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DB_AGGREGATE_COLLECTION = 1;
    var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
    var AggregateOperation = class extends CommandOperationV2 {
      constructor(parent, pipeline, options) {
        super(parent, options, { fullResponse: true });
        this.target = parent.s.namespace && parent.s.namespace.collection ? parent.s.namespace.collection : DB_AGGREGATE_COLLECTION;
        this.pipeline = pipeline;
        this.hasWriteStage = false;
        if (typeof options.out === "string") {
          this.pipeline = this.pipeline.concat({ $out: options.out });
          this.hasWriteStage = true;
        } else if (pipeline.length > 0) {
          const finalStage = pipeline[pipeline.length - 1];
          if (finalStage.$out || finalStage.$merge) {
            this.hasWriteStage = true;
          }
        }
        if (this.hasWriteStage) {
          this.readPreference = ReadPreference.primary;
        }
        if (this.explain && this.writeConcern) {
          throw new MongoError('"explain" cannot be used on an aggregate call with writeConcern');
        }
        if (options.cursor != null && typeof options.cursor !== "object") {
          throw new MongoError("cursor options must be an object");
        }
      }
      get canRetryRead() {
        return !this.hasWriteStage;
      }
      addToPipeline(stage) {
        this.pipeline.push(stage);
      }
      execute(server, callback) {
        const options = this.options;
        const serverWireVersion = maxWireVersion(server);
        const command = { aggregate: this.target, pipeline: this.pipeline };
        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
          this.readConcern = null;
        }
        if (serverWireVersion >= 5) {
          if (this.hasWriteStage && this.writeConcern) {
            Object.assign(command, { writeConcern: this.writeConcern });
          }
        }
        if (options.bypassDocumentValidation === true) {
          command.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        if (typeof options.allowDiskUse === "boolean") {
          command.allowDiskUse = options.allowDiskUse;
        }
        if (options.hint) {
          command.hint = options.hint;
        }
        if (this.explain) {
          options.full = false;
        }
        command.cursor = options.cursor || {};
        if (options.batchSize && !this.hasWriteStage) {
          command.cursor.batchSize = options.batchSize;
        }
        super.executeCommand(server, command, callback);
      }
    };
    defineAspects(AggregateOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = AggregateOperation;
  }
});

// node_modules/mongodb/lib/command_cursor.js
var require_command_cursor = __commonJS({
  "node_modules/mongodb/lib/command_cursor.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var CommandCursor = class extends Cursor {
      constructor(topology, ns, cmd, options) {
        super(topology, ns, cmd, options);
      }
      /**
       * Set the ReadPreference for the cursor.
       * @method
       * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.
       * @throws {MongoError}
       * @return {Cursor}
       */
      setReadPreference(readPreference) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      /**
       * Set the batch size for the cursor.
       * @method
       * @param {number} value The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.
       * @throws {MongoError}
       * @return {CommandCursor}
       */
      batchSize(value2) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value2 !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        if (this.cmd.cursor) {
          this.cmd.cursor.batchSize = value2;
        }
        this.setCursorBatchSize(value2);
        return this;
      }
      /**
       * Add a maxTimeMS stage to the aggregation pipeline
       * @method
       * @param {number} value The state maxTimeMS value.
       * @return {CommandCursor}
       */
      maxTimeMS(value2) {
        if (this.topology.lastIsMaster().minWireVersion > 2) {
          this.cmd.maxTimeMS = value2;
        }
        return this;
      }
      /**
       * Return the cursor logger
       * @method
       * @return {Logger} return the cursor logger
       * @ignore
       */
      getLogger() {
        return this.logger;
      }
    };
    CommandCursor.prototype.get = CommandCursor.prototype.toArray;
    module2.exports = CommandCursor;
  }
});

// node_modules/mongodb/lib/aggregation_cursor.js
var require_aggregation_cursor = __commonJS({
  "node_modules/mongodb/lib/aggregation_cursor.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var AggregationCursor = class extends Cursor {
      constructor(topology, operation, options) {
        super(topology, operation, options);
      }
      /**
       * Set the batch size for the cursor.
       * @method
       * @param {number} value The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.
       * @throws {MongoError}
       * @return {AggregationCursor}
       */
      batchSize(value2) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value2 !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        this.operation.options.batchSize = value2;
        this.setCursorBatchSize(value2);
        return this;
      }
      /**
       * Add a geoNear stage to the aggregation pipeline
       * @method
       * @param {object} document The geoNear stage document.
       * @return {AggregationCursor}
       */
      geoNear(document) {
        this.operation.addToPipeline({ $geoNear: document });
        return this;
      }
      /**
       * Add a group stage to the aggregation pipeline
       * @method
       * @param {object} document The group stage document.
       * @return {AggregationCursor}
       */
      group(document) {
        this.operation.addToPipeline({ $group: document });
        return this;
      }
      /**
       * Add a limit stage to the aggregation pipeline
       * @method
       * @param {number} value The state limit value.
       * @return {AggregationCursor}
       */
      limit(value2) {
        this.operation.addToPipeline({ $limit: value2 });
        return this;
      }
      /**
       * Add a match stage to the aggregation pipeline
       * @method
       * @param {object} document The match stage document.
       * @return {AggregationCursor}
       */
      match(document) {
        this.operation.addToPipeline({ $match: document });
        return this;
      }
      /**
       * Add a maxTimeMS stage to the aggregation pipeline
       * @method
       * @param {number} value The state maxTimeMS value.
       * @return {AggregationCursor}
       */
      maxTimeMS(value2) {
        this.operation.options.maxTimeMS = value2;
        return this;
      }
      /**
       * Add a out stage to the aggregation pipeline
       * @method
       * @param {number} destination The destination name.
       * @return {AggregationCursor}
       */
      out(destination) {
        this.operation.addToPipeline({ $out: destination });
        return this;
      }
      /**
       * Add a project stage to the aggregation pipeline
       * @method
       * @param {object} document The project stage document.
       * @return {AggregationCursor}
       */
      project(document) {
        this.operation.addToPipeline({ $project: document });
        return this;
      }
      /**
       * Add a lookup stage to the aggregation pipeline
       * @method
       * @param {object} document The lookup stage document.
       * @return {AggregationCursor}
       */
      lookup(document) {
        this.operation.addToPipeline({ $lookup: document });
        return this;
      }
      /**
       * Add a redact stage to the aggregation pipeline
       * @method
       * @param {object} document The redact stage document.
       * @return {AggregationCursor}
       */
      redact(document) {
        this.operation.addToPipeline({ $redact: document });
        return this;
      }
      /**
       * Add a skip stage to the aggregation pipeline
       * @method
       * @param {number} value The state skip value.
       * @return {AggregationCursor}
       */
      skip(value2) {
        this.operation.addToPipeline({ $skip: value2 });
        return this;
      }
      /**
       * Add a sort stage to the aggregation pipeline
       * @method
       * @param {object} document The sort stage document.
       * @return {AggregationCursor}
       */
      sort(document) {
        this.operation.addToPipeline({ $sort: document });
        return this;
      }
      /**
       * Add a unwind stage to the aggregation pipeline
       * @method
       * @param {(string|object)} field The unwind field name or stage document.
       * @return {AggregationCursor}
       */
      unwind(field) {
        this.operation.addToPipeline({ $unwind: field });
        return this;
      }
      /**
       * Return the cursor logger
       * @method
       * @return {Logger} return the cursor logger
       * @ignore
       */
      getLogger() {
        return this.logger;
      }
    };
    AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
    module2.exports = AggregationCursor;
  }
});

// node_modules/mongodb/lib/operations/command.js
var require_command2 = __commonJS({
  "node_modules/mongodb/lib/operations/command.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils().applyWriteConcern;
    var debugOptions = require_utils().debugOptions;
    var handleCallback = require_utils().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var MongoDBNamespace = require_utils().MongoDBNamespace;
    var extractCommand = require_command_utils().extractCommand;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    var CommandOperation = class extends OperationBase {
      constructor(db, options, collection, command) {
        super(options);
        if (!this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (collection != null) {
            this.options.readPreference = ReadPreference.resolve(collection, options);
          } else {
            this.options.readPreference = ReadPreference.resolve(db, options);
          }
        } else {
          if (collection != null) {
            applyWriteConcern(this.options, { db, coll: collection }, this.options);
          } else {
            applyWriteConcern(this.options, { db }, this.options);
          }
          this.options.readPreference = ReadPreference.primary;
        }
        this.db = db;
        if (command != null) {
          this.command = command;
        }
        if (collection != null) {
          this.collection = collection;
        }
      }
      _buildCommand() {
        if (this.command != null) {
          return this.command;
        }
      }
      execute(callback) {
        const db = this.db;
        const options = Object.assign({}, this.options);
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        let command;
        try {
          command = this._buildCommand();
        } catch (e) {
          return callback(e);
        }
        const dbName = options.dbName || options.authdb || db.databaseName;
        if (this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (options.writeConcern && (!options.session || !options.session.inTransaction())) {
            command.writeConcern = options.writeConcern;
          }
        }
        if (db.s.logger.isDebug()) {
          const extractedCommand = extractCommand(command);
          db.s.logger.debug(
            `executing command ${JSON.stringify(
              extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : command
            )} against ${dbName}.$cmd with options [${JSON.stringify(
              debugOptions(debugFields, options)
            )}]`
          );
        }
        const namespace = this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, "$cmd");
        db.s.topology.command(namespace, command, options, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (options.full)
            return handleCallback(callback, null, result);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = CommandOperation;
  }
});

// node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS({
  "node_modules/mongodb/lib/operations/add_user.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var crypto = __require("crypto");
    var handleCallback = require_utils().handleCallback;
    var toError = require_utils().toError;
    var emitWarning = require_utils().emitWarning;
    var AddUserOperation = class extends CommandOperation {
      constructor(db, username, password, options) {
        super(db, options);
        this.username = username;
        this.password = password;
      }
      _buildCommand() {
        const db = this.db;
        const username = this.username;
        const password = this.password;
        const options = this.options;
        let roles = [];
        if (Array.isArray(options.roles))
          roles = options.roles;
        if (typeof options.roles === "string")
          roles = [options.roles];
        if (roles.length === 0) {
          emitWarning("Creating a user without roles is deprecated in MongoDB >= 2.6");
        }
        if ((db.databaseName.toLowerCase() === "admin" || options.dbName === "admin") && !Array.isArray(options.roles)) {
          roles = ["root"];
        } else if (!Array.isArray(options.roles)) {
          roles = ["dbOwner"];
        }
        const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;
        let userPassword = password;
        if (!digestPassword) {
          const md5 = crypto.createHash("md5");
          md5.update(username + ":mongo:" + password);
          userPassword = md5.digest("hex");
        }
        const command = {
          createUser: username,
          customData: options.customData || {},
          roles,
          digestPassword
        };
        if (typeof password === "string") {
          command.pwd = userPassword;
        }
        return command;
      }
      execute(callback) {
        const options = this.options;
        if (options.digestPassword != null) {
          return callback(
            toError(
              "The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."
            )
          );
        }
        super.execute((err, r) => {
          if (!err) {
            return handleCallback(callback, err, r);
          }
          return handleCallback(callback, err, null);
        });
      }
    };
    defineAspects(AddUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = AddUserOperation;
  }
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS({
  "node_modules/mongodb/lib/operations/collections.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils().handleCallback;
    var collection;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    var CollectionsOperation = class extends OperationBase {
      constructor(db, options) {
        super(options);
        this.db = db;
      }
      execute(callback) {
        const db = this.db;
        let options = this.options;
        let Collection = loadCollection();
        options = Object.assign({}, options, { nameOnly: true });
        db.listCollections({}, options).toArray((err, documents) => {
          if (err != null)
            return handleCallback(callback, err, null);
          documents = documents.filter((doc) => {
            return doc.name.indexOf("$") === -1;
          });
          handleCallback(
            callback,
            null,
            documents.map((d) => {
              return new Collection(
                db,
                db.s.topology,
                db.databaseName,
                d.name,
                db.s.pkFactory,
                db.s.options
              );
            })
          );
        });
      }
    };
    module2.exports = CollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS({
  "node_modules/mongodb/lib/operations/run_command.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var defineAspects = require_operation().defineAspects;
    var Aspect = require_operation().Aspect;
    var RunCommandOperation = class extends CommandOperationV2 {
      constructor(parent, command, options) {
        super(parent, options);
        this.command = command;
      }
      execute(server, callback) {
        const command = this.command;
        this.executeCommand(server, command, callback);
      }
    };
    defineAspects(RunCommandOperation, [Aspect.EXECUTE_WITH_SELECTION, Aspect.NO_INHERIT_OPTIONS]);
    module2.exports = RunCommandOperation;
  }
});

// node_modules/mongodb/lib/dynamic_loaders.js
var require_dynamic_loaders = __commonJS({
  "node_modules/mongodb/lib/dynamic_loaders.js"(exports2, module2) {
    "use strict";
    var collection;
    var cursor;
    var db;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    function loadCursor() {
      if (!cursor) {
        cursor = require_cursor2();
      }
      return cursor;
    }
    function loadDb() {
      if (!db) {
        db = require_db();
      }
      return db;
    }
    module2.exports = {
      loadCollection,
      loadCursor,
      loadDb
    };
  }
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS({
  "node_modules/mongodb/lib/operations/create_collection.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils().applyWriteConcern;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var ILLEGAL_COMMAND_FIELDS = /* @__PURE__ */ new Set([
      "w",
      "wtimeout",
      "j",
      "fsync",
      "autoIndexId",
      "strict",
      "serializeFunctions",
      "pkFactory",
      "raw",
      "readPreference",
      "session",
      "readConcern",
      "writeConcern"
    ]);
    var CreateCollectionOperation = class extends CommandOperation {
      constructor(db, name, options) {
        super(db, options);
        this.name = name;
      }
      _buildCommand() {
        const name = this.name;
        const options = this.options;
        const cmd = { create: name };
        for (let n in options) {
          if (options[n] != null && typeof options[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options[n];
          }
        }
        return cmd;
      }
      execute(callback) {
        const db = this.db;
        const name = this.name;
        const options = this.options;
        const Collection = loadCollection();
        let listCollectionOptions = Object.assign({ nameOnly: true, strict: false }, options);
        listCollectionOptions = applyWriteConcern(listCollectionOptions, { db }, listCollectionOptions);
        function done(err) {
          if (err) {
            return callback(err);
          }
          try {
            callback(
              null,
              new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options)
            );
          } catch (err2) {
            callback(err2);
          }
        }
        const strictMode = listCollectionOptions.strict;
        if (strictMode) {
          db.listCollections({ name }, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {
            if (err) {
              return callback(err);
            }
            if (collections.length > 0) {
              return callback(
                new MongoError(`Collection ${name} already exists. Currently in strict mode.`)
              );
            }
            super.execute(done);
          });
          return;
        }
        super.execute(done);
      }
    };
    defineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);
    module2.exports = CreateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/create_indexes.js
var require_create_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/create_indexes.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils().parseIndexOptions;
    var maxWireVersion = require_utils3().maxWireVersion;
    var VALID_INDEX_OPTIONS = /* @__PURE__ */ new Set([
      "background",
      "unique",
      "name",
      "partialFilterExpression",
      "sparse",
      "expireAfterSeconds",
      "storageEngine",
      "collation",
      // text indexes
      "weights",
      "default_language",
      "language_override",
      "textIndexVersion",
      // 2d-sphere indexes
      "2dsphereIndexVersion",
      // 2d indexes
      "bits",
      "min",
      "max",
      // geoHaystack Indexes
      "bucketSize",
      // wildcard indexes
      "wildcardProjection"
    ]);
    var CreateIndexesOperation = class extends CommandOperationV2 {
      /**
       * @ignore
       */
      constructor(parent, collection, indexes, options) {
        super(parent, options);
        this.collection = collection;
        if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {
          this.onlyReturnNameOfCreatedIndex = true;
          const indexParameters = parseIndexOptions(indexes);
          const name = typeof options.name === "string" ? options.name : indexParameters.name;
          const indexSpec = { name, key: indexParameters.fieldHash };
          for (let optionName in options) {
            if (VALID_INDEX_OPTIONS.has(optionName)) {
              indexSpec[optionName] = options[optionName];
            }
          }
          this.indexes = [indexSpec];
          return;
        }
        this.indexes = indexes;
      }
      /**
       * @ignore
       */
      execute(server, callback) {
        const options = this.options;
        const indexes = this.indexes;
        const serverWireVersion = maxWireVersion(server);
        for (let i = 0; i < indexes.length; i++) {
          if (indexes[i].collation && serverWireVersion < 5) {
            callback(
              new MongoError(
                `Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`
              )
            );
            return;
          }
          if (indexes[i].name == null) {
            const keys = [];
            for (let name in indexes[i].key) {
              keys.push(`${name}_${indexes[i].key[name]}`);
            }
            indexes[i].name = keys.join("_");
          }
        }
        const cmd = { createIndexes: this.collection, indexes };
        if (options.commitQuorum != null) {
          if (serverWireVersion < 9) {
            callback(
              new MongoError("`commitQuorum` option for `createIndexes` not supported on servers < 4.4")
            );
            return;
          }
          cmd.commitQuorum = options.commitQuorum;
        }
        this.options.collation = void 0;
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);
        });
      }
    };
    defineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = CreateIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS({
  "node_modules/mongodb/lib/operations/drop.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils().handleCallback;
    var DropOperation = class extends CommandOperation {
      constructor(db, options) {
        const finalOptions = Object.assign({}, options, db.s.options);
        if (options.session) {
          finalOptions.session = options.session;
        }
        super(db, finalOptions);
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok)
            return handleCallback(callback, null, true);
          handleCallback(callback, null, false);
        });
      }
    };
    defineAspects(DropOperation, Aspect.WRITE_OPERATION);
    var DropCollectionOperation = class extends DropOperation {
      constructor(db, name, options) {
        super(db, options);
        this.name = name;
        this.namespace = `${db.namespace}.${name}`;
      }
      _buildCommand() {
        return { drop: this.name };
      }
    };
    var DropDatabaseOperation = class extends DropOperation {
      _buildCommand() {
        return { dropDatabase: 1 };
      }
    };
    module2.exports = {
      DropOperation,
      DropCollectionOperation,
      DropDatabaseOperation
    };
  }
});

// node_modules/mongodb/lib/operations/execute_db_admin_command.js
var require_execute_db_admin_command = __commonJS({
  "node_modules/mongodb/lib/operations/execute_db_admin_command.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils().handleCallback;
    var MongoError = require_core().MongoError;
    var MongoDBNamespace = require_utils().MongoDBNamespace;
    var ExecuteDbAdminCommandOperation = class extends OperationBase {
      constructor(db, selector, options) {
        super(options);
        this.db = db;
        this.selector = selector;
      }
      execute(callback) {
        const db = this.db;
        const selector = this.selector;
        const options = this.options;
        const namespace = new MongoDBNamespace("admin", "$cmd");
        db.s.topology.command(namespace, selector, options, (err, result) => {
          if (db.serverConfig && db.serverConfig.isDestroyed()) {
            return callback(new MongoError("topology was destroyed"));
          }
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = ExecuteDbAdminCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/index_information.js
var require_index_information = __commonJS({
  "node_modules/mongodb/lib/operations/index_information.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexInformationOperation = class extends OperationBase {
      constructor(db, name, options) {
        super(options);
        this.db = db;
        this.name = name;
      }
      execute(callback) {
        const db = this.db;
        const name = this.name;
        const options = this.options;
        indexInformation(db, name, options, callback);
      }
    };
    module2.exports = IndexInformationOperation;
  }
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS({
  "node_modules/mongodb/lib/operations/list_collections.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils3().maxWireVersion;
    var CONSTANTS = require_constants2();
    var LIST_COLLECTIONS_WIRE_VERSION = 3;
    function listCollectionsTransforms(databaseName) {
      const matching = `${databaseName}.`;
      return {
        doc: (doc) => {
          const index = doc.name.indexOf(matching);
          if (doc.name && index === 0) {
            doc.name = doc.name.substr(index + matching.length);
          }
          return doc;
        }
      };
    }
    var ListCollectionsOperation = class extends CommandOperationV2 {
      constructor(db, filter, options) {
        super(db, options, { fullResponse: true });
        this.db = db;
        this.filter = filter;
        this.nameOnly = !!this.options.nameOnly;
        if (typeof this.options.batchSize === "number") {
          this.batchSize = this.options.batchSize;
        }
      }
      execute(server, callback) {
        if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {
          let filter = this.filter;
          const databaseName = this.db.s.namespace.db;
          if (typeof filter.name === "string" && !new RegExp("^" + databaseName + "\\.").test(filter.name)) {
            filter = Object.assign({}, filter);
            filter.name = this.db.s.namespace.withCollection(filter.name).toString();
          }
          if (filter == null) {
            filter.name = `/${databaseName}/`;
          }
          if (filter.name) {
            filter = { $and: [{ name: filter.name }, { name: /^((?!\$).)*$/ }] };
          } else {
            filter = { name: /^((?!\$).)*$/ };
          }
          const transforms = listCollectionsTransforms(databaseName);
          server.query(
            `${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`,
            { query: filter },
            { batchSize: this.batchSize || 1e3 },
            {},
            (err, result) => {
              if (result && result.message && result.message.documents && Array.isArray(result.message.documents)) {
                result.message.documents = result.message.documents.map(transforms.doc);
              }
              callback(err, result);
            }
          );
          return;
        }
        const command = {
          listCollections: 1,
          filter: this.filter,
          cursor: this.batchSize ? { batchSize: this.batchSize } : {},
          nameOnly: this.nameOnly
        };
        return super.executeCommand(server, command, callback);
      }
    };
    defineAspects(ListCollectionsOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListCollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/profiling_level.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var ProfilingLevelOperation = class extends CommandOperation {
      constructor(db, command, options) {
        super(db, options);
      }
      _buildCommand() {
        const command = { profile: -1 };
        return command;
      }
      execute(callback) {
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1) {
            const was = doc.was;
            if (was === 0)
              return callback(null, "off");
            if (was === 1)
              return callback(null, "slow_only");
            if (was === 2)
              return callback(null, "all");
            return callback(new Error("Error: illegal profiling level value " + was), null);
          } else {
            err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
          }
        });
      }
    };
    module2.exports = ProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS({
  "node_modules/mongodb/lib/operations/remove_user.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils().handleCallback;
    var WriteConcern = require_write_concern();
    var RemoveUserOperation = class extends CommandOperation {
      constructor(db, username, options) {
        const commandOptions = {};
        const writeConcern = WriteConcern.fromOptions(options);
        if (writeConcern != null) {
          commandOptions.writeConcern = writeConcern;
        }
        if (options.dbName) {
          commandOptions.dbName = options.dbName;
        }
        if (typeof options.maxTimeMS === "number") {
          commandOptions.maxTimeMS = options.maxTimeMS;
        }
        super(db, commandOptions);
        this.username = username;
      }
      _buildCommand() {
        const username = this.username;
        const command = { dropUser: username };
        return command;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, err, result.ok ? true : false);
        });
      }
    };
    defineAspects(RemoveUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = RemoveUserOperation;
  }
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS({
  "node_modules/mongodb/lib/operations/rename.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils().applyWriteConcern;
    var checkCollectionName = require_utils().checkCollectionName;
    var executeDbAdminCommand = require_db_ops().executeDbAdminCommand;
    var handleCallback = require_utils().handleCallback;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var toError = require_utils().toError;
    var RenameOperation = class extends OperationBase {
      constructor(collection, newName, options) {
        super(options);
        this.collection = collection;
        this.newName = newName;
      }
      execute(callback) {
        const coll = this.collection;
        const newName = this.newName;
        const options = this.options;
        let Collection = loadCollection();
        checkCollectionName(newName);
        const renameCollection = coll.namespace;
        const toCollection = coll.s.namespace.withCollection(newName).toString();
        const dropTarget = typeof options.dropTarget === "boolean" ? options.dropTarget : false;
        const cmd = { renameCollection, to: toCollection, dropTarget };
        applyWriteConcern(cmd, { db: coll.s.db, collection: coll }, options);
        executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options, (err, doc) => {
          if (err)
            return handleCallback(callback, err, null);
          if (doc.errmsg)
            return handleCallback(callback, toError(doc), null);
          try {
            return handleCallback(
              callback,
              null,
              new Collection(
                coll.s.db,
                coll.s.topology,
                coll.s.namespace.db,
                newName,
                coll.s.pkFactory,
                coll.s.options
              )
            );
          } catch (err2) {
            return handleCallback(callback, toError(err2), null);
          }
        });
      }
    };
    module2.exports = RenameOperation;
  }
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/set_profiling_level.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var levelValues = /* @__PURE__ */ new Set(["off", "slow_only", "all"]);
    var SetProfilingLevelOperation = class extends CommandOperation {
      constructor(db, level, options) {
        let profile = 0;
        if (level === "off") {
          profile = 0;
        } else if (level === "slow_only") {
          profile = 1;
        } else if (level === "all") {
          profile = 2;
        }
        super(db, options);
        this.level = level;
        this.profile = profile;
      }
      _buildCommand() {
        const profile = this.profile;
        const command = { profile };
        return command;
      }
      execute(callback) {
        const level = this.level;
        if (!levelValues.has(level)) {
          return callback(new Error("Error: illegal profiling level value " + level));
        }
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1)
            return callback(null, level);
          return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
        });
      }
    };
    module2.exports = SetProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS({
  "node_modules/mongodb/lib/operations/validate_collection.js"(exports2, module2) {
    "use strict";
    var CommandOperation = require_command2();
    var ValidateCollectionOperation = class extends CommandOperation {
      constructor(admin, collectionName, options) {
        let command = { validate: collectionName };
        const keys = Object.keys(options);
        for (let i = 0; i < keys.length; i++) {
          if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== "session") {
            command[keys[i]] = options[keys[i]];
          }
        }
        super(admin.s.db, options, null, command);
        this.collectionName = collectionName;
      }
      execute(callback) {
        const collectionName = this.collectionName;
        super.execute((err, doc) => {
          if (err != null)
            return callback(err, null);
          if (doc.ok === 0)
            return callback(new Error("Error with validate command"), null);
          if (doc.result != null && doc.result.constructor !== String)
            return callback(new Error("Error with validation data"), null);
          if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          if (doc.valid != null && !doc.valid)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          return callback(null, doc);
        });
      }
    };
    module2.exports = ValidateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS({
  "node_modules/mongodb/lib/operations/list_databases.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var MongoDBNamespace = require_utils().MongoDBNamespace;
    var ListDatabasesOperation = class extends CommandOperationV2 {
      constructor(db, options) {
        super(db, options);
        this.ns = new MongoDBNamespace("admin", "$cmd");
      }
      execute(server, callback) {
        const cmd = { listDatabases: 1 };
        if (this.options.nameOnly) {
          cmd.nameOnly = Number(cmd.nameOnly);
        }
        if (this.options.filter) {
          cmd.filter = this.options.filter;
        }
        if (typeof this.options.authorizedDatabases === "boolean") {
          cmd.authorizedDatabases = this.options.authorizedDatabases;
        }
        super.executeCommand(server, cmd, callback);
      }
    };
    defineAspects(ListDatabasesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListDatabasesOperation;
  }
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS({
  "node_modules/mongodb/lib/admin.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils().applyWriteConcern;
    var AddUserOperation = require_add_user();
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var RemoveUserOperation = require_remove_user();
    var ValidateCollectionOperation = require_validate_collection();
    var ListDatabasesOperation = require_list_databases();
    var executeOperation = require_execute_operation();
    function Admin(db, topology, promiseLibrary) {
      if (!(this instanceof Admin))
        return new Admin(db, topology);
      this.s = {
        db,
        topology,
        promiseLibrary
      };
    }
    Admin.prototype.command = function(command, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() : {};
      const commandOperation = new ExecuteDbAdminCommandOperation(this.s.db, command, options);
      return executeOperation(this.s.db.s.topology, commandOperation, callback);
    };
    Admin.prototype.buildInfo = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const cmd = { buildinfo: 1 };
      const buildInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
      return executeOperation(this.s.db.s.topology, buildInfoOperation, callback);
    };
    Admin.prototype.serverInfo = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const cmd = { buildinfo: 1 };
      const serverInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
      return executeOperation(this.s.db.s.topology, serverInfoOperation, callback);
    };
    Admin.prototype.serverStatus = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const serverStatusOperation = new ExecuteDbAdminCommandOperation(
        this.s.db,
        { serverStatus: 1 },
        options
      );
      return executeOperation(this.s.db.s.topology, serverStatusOperation, callback);
    };
    Admin.prototype.ping = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const cmd = { ping: 1 };
      const pingOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options);
      return executeOperation(this.s.db.s.topology, pingOperation, callback);
    };
    Admin.prototype.addUser = function(username, password, options, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      if (typeof username === "string" && password != null && typeof password === "object") {
        options = password;
        password = null;
      }
      options = args.length ? args.shift() : {};
      options = Object.assign({}, options);
      options = applyWriteConcern(options, { db: this.s.db });
      options.dbName = "admin";
      const addUserOperation = new AddUserOperation(this.s.db, username, password, options);
      return executeOperation(this.s.db.s.topology, addUserOperation, callback);
    };
    Admin.prototype.removeUser = function(username, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() : {};
      options = Object.assign({}, options);
      options = applyWriteConcern(options, { db: this.s.db });
      options.dbName = "admin";
      const removeUserOperation = new RemoveUserOperation(this.s.db, username, options);
      return executeOperation(this.s.db.s.topology, removeUserOperation, callback);
    };
    Admin.prototype.validateCollection = function(collectionName, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const validateCollectionOperation = new ValidateCollectionOperation(
        this,
        collectionName,
        options
      );
      return executeOperation(this.s.db.s.topology, validateCollectionOperation, callback);
    };
    Admin.prototype.listDatabases = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeOperation(
        this.s.db.s.topology,
        new ListDatabasesOperation(this.s.db, options),
        callback
      );
    };
    Admin.prototype.replSetGetStatus = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const replSetGetStatusOperation = new ExecuteDbAdminCommandOperation(
        this.s.db,
        { replSetGetStatus: 1 },
        options
      );
      return executeOperation(this.s.db.s.topology, replSetGetStatusOperation, callback);
    };
    module2.exports = Admin;
  }
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS({
  "node_modules/mongodb/lib/db.js"(exports2, module2) {
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    var getSingleProperty = require_utils().getSingleProperty;
    var CommandCursor = require_command_cursor();
    var handleCallback = require_utils().handleCallback;
    var filterOptions = require_utils().filterOptions;
    var toError = require_utils().toError;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().ObjectID;
    var Logger = require_core().Logger;
    var Collection = require_collection();
    var conditionallyMergeWriteConcern = require_utils().conditionallyMergeWriteConcern;
    var executeLegacyOperation = require_utils().executeLegacyOperation;
    var ChangeStream = require_change_stream();
    var deprecate = __require("util").deprecate;
    var deprecateOptions = require_utils().deprecateOptions;
    var MongoDBNamespace = require_utils().MongoDBNamespace;
    var CONSTANTS = require_constants2();
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var AggregationCursor = require_aggregation_cursor();
    var createListener = require_db_ops().createListener;
    var ensureIndex = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var profilingInfo = require_db_ops().profilingInfo;
    var validateDatabaseName = require_db_ops().validateDatabaseName;
    var AggregateOperation = require_aggregate();
    var AddUserOperation = require_add_user();
    var CollectionsOperation = require_collections();
    var CommandOperation = require_command2();
    var RunCommandOperation = require_run_command();
    var CreateCollectionOperation = require_create_collection();
    var CreateIndexesOperation = require_create_indexes();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropDatabaseOperation = require_drop().DropDatabaseOperation;
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var IndexInformationOperation = require_index_information();
    var ListCollectionsOperation = require_list_collections();
    var ProfilingLevelOperation = require_profiling_level();
    var RemoveUserOperation = require_remove_user();
    var RenameOperation = require_rename();
    var SetProfilingLevelOperation = require_set_profiling_level();
    var executeOperation = require_execute_operation();
    var legalOptionNames = [
      "w",
      "wtimeout",
      "fsync",
      "j",
      "writeConcern",
      "readPreference",
      "readPreferenceTags",
      "native_parser",
      "forceServerObjectId",
      "pkFactory",
      "serializeFunctions",
      "raw",
      "bufferMaxEntries",
      "authSource",
      "ignoreUndefined",
      "promiseLibrary",
      "readConcern",
      "retryMiliSeconds",
      "numberOfRetries",
      "parentDb",
      "noListener",
      "loggerLevel",
      "logger",
      "promoteBuffers",
      "promoteLongs",
      "promoteValues",
      "bsonRegExp",
      "compression",
      "retryWrites"
    ];
    function Db2(databaseName, topology, options) {
      options = options || {};
      if (!(this instanceof Db2))
        return new Db2(databaseName, topology, options);
      EventEmitter.call(this);
      const promiseLibrary = options.promiseLibrary || Promise;
      options = filterOptions(options, legalOptionNames);
      options.promiseLibrary = promiseLibrary;
      this.s = {
        // DbCache
        dbCache: {},
        // Children db's
        children: [],
        // Topology
        topology,
        // Options
        options,
        // Logger instance
        logger: Logger("Db", options),
        // Get the bson parser
        bson: topology ? topology.bson : null,
        // Unpack read preference
        readPreference: ReadPreference.fromOptions(options),
        // Set buffermaxEntries
        bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : -1,
        // Parent db (if chained)
        parentDb: options.parentDb || null,
        // Set up the primary key factory or fallback to ObjectID
        pkFactory: options.pkFactory || ObjectID2,
        // Get native parser
        nativeParser: options.nativeParser || options.native_parser,
        // Promise library
        promiseLibrary,
        // No listener
        noListener: typeof options.noListener === "boolean" ? options.noListener : false,
        // ReadConcern
        readConcern: ReadConcern.fromOptions(options),
        writeConcern: WriteConcern.fromOptions(options),
        // Namespace
        namespace: new MongoDBNamespace(databaseName)
      };
      validateDatabaseName(databaseName);
      getSingleProperty(this, "serverConfig", this.s.topology);
      getSingleProperty(this, "bufferMaxEntries", this.s.bufferMaxEntries);
      getSingleProperty(this, "databaseName", this.s.namespace.db);
      if (options.parentDb)
        return;
      if (this.s.noListener)
        return;
      topology.on("error", createListener(this, "error", this));
      topology.on("timeout", createListener(this, "timeout", this));
      topology.on("close", createListener(this, "close", this));
      topology.on("parseError", createListener(this, "parseError", this));
      topology.once("open", createListener(this, "open", this));
      topology.once("fullsetup", createListener(this, "fullsetup", this));
      topology.once("all", createListener(this, "all", this));
      topology.on("reconnect", createListener(this, "reconnect", this));
    }
    inherits(Db2, EventEmitter);
    Db2.prototype.on = deprecate(function() {
      return Db2.super_.prototype.on.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Db2.prototype.once = deprecate(function() {
      return Db2.super_.prototype.once.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Object.defineProperty(Db2.prototype, "topology", {
      enumerable: true,
      get: function() {
        return this.s.topology;
      }
    });
    Object.defineProperty(Db2.prototype, "options", {
      enumerable: true,
      get: function() {
        return this.s.options;
      }
    });
    Object.defineProperty(Db2.prototype, "slaveOk", {
      enumerable: true,
      get: function() {
        if (this.s.options.readPreference != null && (this.s.options.readPreference !== "primary" || this.s.options.readPreference.mode !== "primary")) {
          return true;
        }
        return false;
      }
    });
    Object.defineProperty(Db2.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Db2.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return ReadPreference.primary;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Db2.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Db2.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Db2.prototype.command = function(command, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      const commandOperation = new RunCommandOperation(this, command, options);
      return executeOperation(this.s.topology, commandOperation, callback);
    };
    Db2.prototype.aggregate = function(pipeline, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (options == null && callback == null) {
        options = {};
      }
      const cursor = new AggregationCursor(
        this.s.topology,
        new AggregateOperation(this, pipeline, options),
        options
      );
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Db2.prototype.admin = function() {
      const Admin = require_admin();
      return new Admin(this, this.s.topology, this.s.promiseLibrary);
    };
    var COLLECTION_OPTION_KEYS = [
      "pkFactory",
      "readPreference",
      "serializeFunctions",
      "strict",
      "readConcern",
      "ignoreUndefined",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs",
      "bsonRegExp"
    ];
    Db2.prototype.collection = deprecateOptions(
      {
        name: "Db.collection",
        deprecatedOptions: ["strict"],
        optionsIndex: 1
      },
      function(name, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options || {};
        options = Object.assign({}, options);
        options.promiseLibrary = this.s.promiseLibrary;
        options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern;
        if (this.s.options.ignoreUndefined) {
          options.ignoreUndefined = this.s.options.ignoreUndefined;
        }
        for (const collectionOptionKey of COLLECTION_OPTION_KEYS) {
          if (!(collectionOptionKey in options) && this.s.options[collectionOptionKey] !== void 0) {
            options[collectionOptionKey] = this.s.options[collectionOptionKey];
          }
        }
        options = conditionallyMergeWriteConcern(options, this.s.options);
        if (options == null || !options.strict) {
          try {
            const collection = new Collection(
              this,
              this.s.topology,
              this.databaseName,
              name,
              this.s.pkFactory,
              options
            );
            if (callback)
              callback(null, collection);
            return collection;
          } catch (err) {
            if (err instanceof MongoError && callback)
              return callback(err);
            throw err;
          }
        }
        if (typeof callback !== "function") {
          throw toError(`A callback is required in strict mode. While getting collection ${name}`);
        }
        if (this.serverConfig && this.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        const listCollectionOptions = Object.assign({}, options, { nameOnly: true });
        this.listCollections({ name }, listCollectionOptions).toArray((err, collections) => {
          if (err != null)
            return handleCallback(callback, err, null);
          if (collections.length === 0)
            return handleCallback(
              callback,
              toError(`Collection ${name} does not exist. Currently in strict mode.`),
              null
            );
          try {
            return handleCallback(
              callback,
              null,
              new Collection(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options)
            );
          } catch (err2) {
            return handleCallback(callback, err2, null);
          }
        });
      }
    );
    Db2.prototype.createCollection = deprecateOptions(
      {
        name: "Db.createCollection",
        deprecatedOptions: ["autoIndexId", "strict", "w", "wtimeout", "j"],
        optionsIndex: 1
      },
      function(name, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options || {};
        options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;
        options.readConcern = options.readConcern ? new ReadConcern(options.readConcern.level) : this.readConcern;
        const createCollectionOperation = new CreateCollectionOperation(this, name, options);
        return executeOperation(this.s.topology, createCollectionOperation, callback);
      }
    );
    Db2.prototype.stats = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const commandObject = { dbStats: true };
      if (options["scale"] != null)
        commandObject["scale"] = options["scale"];
      if (options.readPreference == null && this.s.readPreference) {
        options.readPreference = this.s.readPreference;
      }
      const statsOperation = new CommandOperation(this, options, null, commandObject);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Db2.prototype.listCollections = function(filter, options) {
      filter = filter || {};
      options = options || {};
      return new CommandCursor(
        this.s.topology,
        new ListCollectionsOperation(this, filter, options),
        options
      );
    };
    Db2.prototype.eval = deprecate(function(code, parameters, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      parameters = args.length ? args.shift() : parameters;
      options = args.length ? args.shift() || {} : {};
      return executeLegacyOperation(this.s.topology, evaluate, [
        this,
        code,
        parameters,
        options,
        callback
      ]);
    }, "Db.eval is deprecated as of MongoDB version 3.2");
    Db2.prototype.renameCollection = function(fromCollection, toCollection, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });
      options.new_collection = true;
      const renameOperation = new RenameOperation(
        this.collection(fromCollection),
        toCollection,
        options
      );
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Db2.prototype.dropCollection = function(name, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const dropCollectionOperation = new DropCollectionOperation(this, name, options);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Db2.prototype.dropDatabase = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const dropDatabaseOperation = new DropDatabaseOperation(this, options);
      return executeOperation(this.s.topology, dropDatabaseOperation, callback);
    };
    Db2.prototype.collections = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const collectionsOperation = new CollectionsOperation(this, options);
      return executeOperation(this.s.topology, collectionsOperation, callback);
    };
    Db2.prototype.executeDbAdminCommand = function(selector, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      options.readPreference = ReadPreference.resolve(this, options);
      const executeDbAdminCommandOperation = new ExecuteDbAdminCommandOperation(
        this,
        selector,
        options
      );
      return executeOperation(this.s.topology, executeDbAdminCommandOperation, callback);
    };
    Db2.prototype.createIndex = function(name, fieldOrSpec, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options ? Object.assign({}, options) : {};
      const createIndexesOperation = new CreateIndexesOperation(this, name, fieldOrSpec, options);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Db2.prototype.ensureIndex = deprecate(function(name, fieldOrSpec, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        name,
        fieldOrSpec,
        options,
        callback
      ]);
    }, "Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0");
    Db2.prototype.addChild = function(db) {
      if (this.s.parentDb)
        return this.s.parentDb.addChild(db);
      this.s.children.push(db);
    };
    Db2.prototype.addUser = function(username, password, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (typeof username === "string" && password != null && typeof password === "object") {
        options = password;
        password = null;
      }
      const addUserOperation = new AddUserOperation(this, username, password, options);
      return executeOperation(this.s.topology, addUserOperation, callback);
    };
    Db2.prototype.removeUser = function(username, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const removeUserOperation = new RemoveUserOperation(this, username, options);
      return executeOperation(this.s.topology, removeUserOperation, callback);
    };
    Db2.prototype.setProfilingLevel = function(level, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const setProfilingLevelOperation = new SetProfilingLevelOperation(this, level, options);
      return executeOperation(this.s.topology, setProfilingLevelOperation, callback);
    };
    Db2.prototype.profilingInfo = deprecate(function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.s.topology, profilingInfo, [this, options, callback]);
    }, "Db.profilingInfo is deprecated. Query the system.profile collection directly.");
    Db2.prototype.profilingLevel = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const profilingLevelOperation = new ProfilingLevelOperation(this, options);
      return executeOperation(this.s.topology, profilingLevelOperation, callback);
    };
    Db2.prototype.indexInformation = function(name, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const indexInformationOperation = new IndexInformationOperation(this, name, options);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Db2.prototype.unref = function() {
      this.s.topology.unref();
    };
    Db2.prototype.watch = function(pipeline, options) {
      pipeline = pipeline || [];
      options = options || {};
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new ChangeStream(this, pipeline, options);
    };
    Db2.prototype.getLogger = function() {
      return this.s.logger;
    };
    Db2.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db2.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db2.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db2.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db2.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db2.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
    module2.exports = Db2;
  }
});

// node_modules/mongodb/lib/topologies/topology_base.js
var require_topology_base = __commonJS({
  "node_modules/mongodb/lib/topologies/topology_base.js"(exports2) {
    "use strict";
    var EventEmitter = __require("events");
    var MongoError = require_core().MongoError;
    var f = __require("util").format;
    var ReadPreference = require_core().ReadPreference;
    var ClientSession = require_core().Sessions.ClientSession;
    var Store = function(topology, storeOptions) {
      var self2 = this;
      var storedOps = [];
      storeOptions = storeOptions || { force: false, bufferMaxEntries: -1 };
      this.s = {
        storedOps,
        storeOptions,
        topology
      };
      Object.defineProperty(this, "length", {
        enumerable: true,
        get: function() {
          return self2.s.storedOps.length;
        }
      });
    };
    Store.prototype.add = function(opType, ns, ops, options, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({ message: "db closed by application", driver: true }));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(
          MongoError.create({
            message: f(
              "no connection available for operation and number of stored operation > %s",
              this.s.storeOptions.bufferMaxEntries
            ),
            driver: true
          })
        );
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(
            MongoError.create({
              message: f(
                "no connection available for operation and number of stored operation > %s",
                this.s.storeOptions.bufferMaxEntries
              ),
              driver: true
            })
          );
        }
        return;
      }
      this.s.storedOps.push({ t: opType, n: ns, o: ops, op: options, c: callback });
    };
    Store.prototype.addObjectAndMethod = function(opType, object2, method, params, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({ message: "db closed by application", driver: true }));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(
          MongoError.create({
            message: f(
              "no connection available for operation and number of stored operation > %s",
              this.s.storeOptions.bufferMaxEntries
            ),
            driver: true
          })
        );
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(
            MongoError.create({
              message: f(
                "no connection available for operation and number of stored operation > %s",
                this.s.storeOptions.bufferMaxEntries
              ),
              driver: true
            })
          );
        }
        return;
      }
      this.s.storedOps.push({ t: opType, m: method, o: object2, p: params, c: callback });
    };
    Store.prototype.flush = function(err) {
      while (this.s.storedOps.length > 0) {
        this.s.storedOps.shift().c(
          err || MongoError.create({ message: f("no connection available for operation"), driver: true })
        );
      }
    };
    var primaryOptions = ["primary", "primaryPreferred", "nearest", "secondaryPreferred"];
    var secondaryOptions = ["secondary", "secondaryPreferred"];
    Store.prototype.execute = function(options) {
      options = options || {};
      var ops = this.s.storedOps;
      this.s.storedOps = [];
      var executePrimary = typeof options.executePrimary === "boolean" ? options.executePrimary : true;
      var executeSecondary = typeof options.executeSecondary === "boolean" ? options.executeSecondary : true;
      while (ops.length > 0) {
        var op = ops.shift();
        if (op.t === "cursor") {
          if (executePrimary && executeSecondary) {
            op.o[op.m].apply(op.o, op.p);
          } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          }
        } else if (op.t === "auth") {
          this.s.topology[op.t].apply(this.s.topology, op.o);
        } else {
          if (executePrimary && executeSecondary) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          }
        }
      }
    };
    Store.prototype.all = function() {
      return this.s.storedOps;
    };
    var ServerCapabilities = function(ismaster) {
      var setup_get_property = function(object2, name, value2) {
        Object.defineProperty(object2, name, {
          enumerable: true,
          get: function() {
            return value2;
          }
        });
      };
      var aggregationCursor = false;
      var writeCommands = false;
      var textSearch = false;
      var authCommands = false;
      var listCollections = false;
      var listIndexes = false;
      var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1e3;
      var commandsTakeWriteConcern = false;
      var commandsTakeCollation = false;
      if (ismaster.minWireVersion >= 0) {
        textSearch = true;
      }
      if (ismaster.maxWireVersion >= 1) {
        aggregationCursor = true;
        authCommands = true;
      }
      if (ismaster.maxWireVersion >= 2) {
        writeCommands = true;
      }
      if (ismaster.maxWireVersion >= 3) {
        listCollections = true;
        listIndexes = true;
      }
      if (ismaster.maxWireVersion >= 5) {
        commandsTakeWriteConcern = true;
        commandsTakeCollation = true;
      }
      if (ismaster.minWireVersion == null) {
        ismaster.minWireVersion = 0;
      }
      if (ismaster.maxWireVersion == null) {
        ismaster.maxWireVersion = 0;
      }
      setup_get_property(this, "hasAggregationCursor", aggregationCursor);
      setup_get_property(this, "hasWriteCommands", writeCommands);
      setup_get_property(this, "hasTextSearch", textSearch);
      setup_get_property(this, "hasAuthCommands", authCommands);
      setup_get_property(this, "hasListCollectionsCommand", listCollections);
      setup_get_property(this, "hasListIndexesCommand", listIndexes);
      setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
      setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
      setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
      setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
      setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
    };
    var TopologyBase = class extends EventEmitter {
      constructor() {
        super();
        this.setMaxListeners(Infinity);
      }
      // Sessions related methods
      hasSessionSupport() {
        return this.logicalSessionTimeoutMinutes != null;
      }
      startSession(options, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        return this.s.coreTopology.endSessions(sessions, callback);
      }
      get clientMetadata() {
        return this.s.coreTopology.s.options.metadata;
      }
      // Server capabilities
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.s.coreTopology.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());
        return this.s.sCapabilities;
      }
      // Command
      command(ns, cmd, options, callback) {
        this.s.coreTopology.command(ns.toString(), cmd, ReadPreference.translate(options), callback);
      }
      // Insert
      insert(ns, ops, options, callback) {
        this.s.coreTopology.insert(ns.toString(), ops, options, callback);
      }
      // Update
      update(ns, ops, options, callback) {
        this.s.coreTopology.update(ns.toString(), ops, options, callback);
      }
      // Remove
      remove(ns, ops, options, callback) {
        this.s.coreTopology.remove(ns.toString(), ops, options, callback);
      }
      // IsConnected
      isConnected(options) {
        options = options || {};
        options = ReadPreference.translate(options);
        return this.s.coreTopology.isConnected(options);
      }
      // IsDestroyed
      isDestroyed() {
        return this.s.coreTopology.isDestroyed();
      }
      // Cursor
      cursor(ns, cmd, options) {
        options = options || {};
        options = ReadPreference.translate(options);
        options.disconnectHandler = this.s.store;
        options.topology = this;
        return this.s.coreTopology.cursor(ns, cmd, options);
      }
      lastIsMaster() {
        return this.s.coreTopology.lastIsMaster();
      }
      selectServer(selector, options, callback) {
        return this.s.coreTopology.selectServer(selector, options, callback);
      }
      /**
       * Unref all sockets
       * @method
       */
      unref() {
        return this.s.coreTopology.unref();
      }
      /**
       * All raw connections
       * @method
       * @return {array}
       */
      connections() {
        return this.s.coreTopology.connections();
      }
      close(forceClosed, callback) {
        this.s.sessions.forEach((session) => session.endSession());
        if (this.s.sessionPool) {
          this.s.sessionPool.endAllPooledSessions();
        }
        if (forceClosed === true) {
          this.s.storeOptions.force = forceClosed;
          this.s.store.flush();
        }
        this.s.coreTopology.destroy(
          {
            force: typeof forceClosed === "boolean" ? forceClosed : false
          },
          callback
        );
      }
    };
    Object.defineProperty(TopologyBase.prototype, "bson", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.bson;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.parserType;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.logicalSessionTimeoutMinutes;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "type", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.type;
      }
    });
    exports2.Store = Store;
    exports2.ServerCapabilities = ServerCapabilities;
    exports2.TopologyBase = TopologyBase;
  }
});

// node_modules/mongodb/lib/topologies/native_topology.js
var require_native_topology = __commonJS({
  "node_modules/mongodb/lib/topologies/native_topology.js"(exports2, module2) {
    "use strict";
    var Topology = require_core().Topology;
    var ServerCapabilities = require_topology_base().ServerCapabilities;
    var Cursor = require_cursor2();
    var translateOptions = require_utils().translateOptions;
    var NativeTopology = class extends Topology {
      constructor(servers, options) {
        options = options || {};
        let clonedOptions = Object.assign(
          {},
          {
            cursorFactory: Cursor,
            reconnect: false,
            emitError: typeof options.emitError === "boolean" ? options.emitError : true,
            maxPoolSize: typeof options.maxPoolSize === "number" ? options.maxPoolSize : typeof options.poolSize === "number" ? options.poolSize : 10,
            minPoolSize: typeof options.minPoolSize === "number" ? options.minPoolSize : typeof options.minSize === "number" ? options.minSize : 0,
            monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
          }
        );
        clonedOptions = translateOptions(clonedOptions, options);
        var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        clonedOptions.serverApi = options.serverApi;
        clonedOptions.useUnifiedTopology = options.useUnifiedTopology;
        super(servers, clonedOptions);
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.lastIsMaster());
        return this.s.sCapabilities;
      }
      // Command
      command(ns, cmd, options, callback) {
        super.command(ns.toString(), cmd, options, callback);
      }
      // Insert
      insert(ns, ops, options, callback) {
        super.insert(ns.toString(), ops, options, callback);
      }
      // Update
      update(ns, ops, options, callback) {
        super.update(ns.toString(), ops, options, callback);
      }
      // Remove
      remove(ns, ops, options, callback) {
        super.remove(ns.toString(), ops, options, callback);
      }
    };
    module2.exports = NativeTopology;
  }
});

// node_modules/mongodb/lib/topologies/server.js
var require_server3 = __commonJS({
  "node_modules/mongodb/lib/topologies/server.js"(exports2, module2) {
    "use strict";
    var CServer = require_core().Server;
    var Cursor = require_cursor2();
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var MongoError = require_core().MongoError;
    var MAX_JS_INT = require_utils().MAX_JS_INT;
    var translateOptions = require_utils().translateOptions;
    var filterOptions = require_utils().filterOptions;
    var mergeOptions = require_utils().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "reconnectInterval",
      "monitoring",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "compression",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Server = class extends TopologyBase {
      constructor(host, port, options) {
        super();
        var self2 = this;
        options = filterOptions(options, legalOptionNames);
        const promiseLibrary = options.promiseLibrary;
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
        };
        var store = options.store || new Store(self2, storeOptions);
        if (host.indexOf("/") !== -1) {
          if (port != null && typeof port === "object") {
            options = port;
            port = null;
          }
        } else if (port == null) {
          throw MongoError.create({ message: "port must be specified", driver: true });
        }
        var reconnect = typeof options.auto_reconnect === "boolean" ? options.auto_reconnect : true;
        reconnect = typeof options.autoReconnect === "boolean" ? options.autoReconnect : reconnect;
        var clonedOptions = mergeOptions(
          {},
          {
            host,
            port,
            disconnectHandler: store,
            cursorFactory: Cursor,
            reconnect,
            emitError: typeof options.emitError === "boolean" ? options.emitError : true,
            size: typeof options.poolSize === "number" ? options.poolSize : 5,
            monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
          }
        );
        clonedOptions = translateOptions(clonedOptions, options);
        var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          // Create an instance of a server instance from core module
          coreTopology: new CServer(clonedOptions),
          // Server capabilities
          sCapabilities: null,
          // Cloned options
          clonedOptions,
          // Reconnect
          reconnect: clonedOptions.reconnect,
          // Emit error
          emitError: clonedOptions.emitError,
          // Pool size
          poolSize: clonedOptions.size,
          // Store Options
          storeOptions,
          // Store
          store,
          // Host
          host,
          // Port
          port,
          // Options
          options,
          // Server Session Pool
          sessionPool: null,
          // Active client sessions
          sessions: /* @__PURE__ */ new Set(),
          // Promise library
          promiseLibrary: promiseLibrary || Promise
        };
      }
      // Connect
      connect(_options, callback) {
        var self2 = this;
        if ("function" === typeof _options)
          callback = _options, _options = {};
        if (_options == null)
          _options = this.s.clonedOptions;
        if (!("function" === typeof callback))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events = ["timeout", "error", "close"];
            events.forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectHandlers[e]);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect", self2);
          self2.s.store.execute();
        };
        var reconnectFailedHandler = function(err) {
          self2.emit("reconnectFailed", err);
          self2.s.store.flush(err);
        };
        var destroyHandler = function() {
          self2.s.store.flush();
        };
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          ["timeout", "error", "close", "destroy"].forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("destroy", destroyHandler);
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectHandlers = {
          timeout: connectErrorHandler("timeout"),
          error: connectErrorHandler("error"),
          close: connectErrorHandler("close")
        };
        [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ].forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.once("timeout", connectHandlers.timeout);
        self2.s.coreTopology.once("error", connectHandlers.error);
        self2.s.coreTopology.once("close", connectHandlers.close);
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.on("reconnectFailed", reconnectFailedHandler);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("attemptReconnect", relay("attemptReconnect"));
        self2.s.coreTopology.on("monitoring", relay("monitoring"));
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Server.prototype, "poolSize", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.connections().length;
      }
    });
    Object.defineProperty(Server.prototype, "autoReconnect", {
      enumerable: true,
      get: function() {
        return this.s.reconnect;
      }
    });
    Object.defineProperty(Server.prototype, "host", {
      enumerable: true,
      get: function() {
        return this.s.host;
      }
    });
    Object.defineProperty(Server.prototype, "port", {
      enumerable: true,
      get: function() {
        return this.s.port;
      }
    });
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/topologies/mongos.js
var require_mongos2 = __commonJS({
  "node_modules/mongodb/lib/topologies/mongos.js"(exports2, module2) {
    "use strict";
    var TopologyBase = require_topology_base().TopologyBase;
    var MongoError = require_core().MongoError;
    var CMongos = require_core().Mongos;
    var Cursor = require_cursor2();
    var Server = require_server3();
    var Store = require_topology_base().Store;
    var MAX_JS_INT = require_utils().MAX_JS_INT;
    var translateOptions = require_utils().translateOptions;
    var filterOptions = require_utils().filterOptions;
    var mergeOptions = require_utils().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Mongos = class extends TopologyBase {
      constructor(servers, options) {
        super();
        options = options || {};
        var self2 = this;
        options = filterOptions(options, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
        };
        var store = options.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return { host: x.host, port: x.port };
        });
        var reconnect = typeof options.auto_reconnect === "boolean" ? options.auto_reconnect : true;
        reconnect = typeof options.autoReconnect === "boolean" ? options.autoReconnect : reconnect;
        var clonedOptions = mergeOptions(
          {},
          {
            disconnectHandler: store,
            cursorFactory: Cursor,
            reconnect,
            emitError: typeof options.emitError === "boolean" ? options.emitError : true,
            size: typeof options.poolSize === "number" ? options.poolSize : 5,
            monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
          }
        );
        clonedOptions = translateOptions(clonedOptions, options);
        var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          // Create the Mongos
          coreTopology: new CMongos(seedlist, clonedOptions),
          // Server capabilities
          sCapabilities: null,
          // Debug turned on
          debug: clonedOptions.debug,
          // Store option defaults
          storeOptions,
          // Cloned options
          clonedOptions,
          // Actual store of callbacks
          store,
          // Options
          options,
          // Server Session Pool
          sessionPool: null,
          // Active client sessions
          sessions: /* @__PURE__ */ new Set(),
          // Promise library
          promiseLibrary: options.promiseLibrary || Promise
        };
      }
      // Connect
      connect(_options, callback) {
        var self2 = this;
        if ("function" === typeof _options)
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!("function" === typeof callback))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events2 = ["timeout", "error", "close"];
            events2.forEach(function(e) {
              self2.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.close(true);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect");
          self2.s.store.execute();
        };
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          var events2 = ["timeout", "error", "close", "fullsetup"];
          events2.forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.on("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("fullsetup", function() {
            self2.emit("fullsetup", self2);
          });
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("joined", relay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Mongos.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = Mongos;
  }
});

// node_modules/mongodb/lib/topologies/replset.js
var require_replset2 = __commonJS({
  "node_modules/mongodb/lib/topologies/replset.js"(exports2, module2) {
    "use strict";
    var Server = require_server3();
    var Cursor = require_cursor2();
    var MongoError = require_core().MongoError;
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var CReplSet = require_core().ReplSet;
    var MAX_JS_INT = require_utils().MAX_JS_INT;
    var translateOptions = require_utils().translateOptions;
    var filterOptions = require_utils().filterOptions;
    var mergeOptions = require_utils().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "replicaSet",
      "rs_name",
      "secondaryAcceptableLatencyMS",
      "connectWithNoPrimary",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslCRL",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "strategy",
      "debug",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "maxStalenessSeconds",
      "promiseLibrary",
      "minSize",
      "monitorCommands"
    ];
    var ReplSet = class extends TopologyBase {
      constructor(servers, options) {
        super();
        options = options || {};
        var self2 = this;
        options = filterOptions(options, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options.bufferMaxEntries === "number" ? options.bufferMaxEntries : MAX_JS_INT
        };
        var store = options.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return { host: x.host, port: x.port };
        });
        var clonedOptions = mergeOptions(
          {},
          {
            disconnectHandler: store,
            cursorFactory: Cursor,
            reconnect: false,
            emitError: typeof options.emitError === "boolean" ? options.emitError : true,
            size: typeof options.poolSize === "number" ? options.poolSize : 5,
            monitorCommands: typeof options.monitorCommands === "boolean" ? options.monitorCommands : false
          }
        );
        clonedOptions = translateOptions(clonedOptions, options);
        var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        var coreTopology = new CReplSet(seedlist, clonedOptions);
        coreTopology.on("reconnect", function() {
          self2.emit("reconnect");
          store.execute();
        });
        this.s = {
          // Replicaset
          coreTopology,
          // Server capabilities
          sCapabilities: null,
          // Debug tag
          tag: options.tag,
          // Store options
          storeOptions,
          // Cloned options
          clonedOptions,
          // Store
          store,
          // Options
          options,
          // Server Session Pool
          sessionPool: null,
          // Active client sessions
          sessions: /* @__PURE__ */ new Set(),
          // Promise library
          promiseLibrary: options.promiseLibrary || Promise
        };
        if (clonedOptions.debug) {
          Object.defineProperty(this, "replset", {
            enumerable: true,
            get: function() {
              return coreTopology;
            }
          });
        }
      }
      // Connect method
      connect(_options, callback) {
        var self2 = this;
        if ("function" === typeof _options)
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!("function" === typeof callback))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed",
          "joined",
          "left",
          "ping",
          "ha"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var replsetRelay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server.lastIsMaster(), server);
          };
        };
        var relayHa = function(t, state) {
          self2.emit("ha", t, state);
          if (t === "start") {
            self2.emit("ha_connect", t, state);
          } else if (t === "end") {
            self2.emit("ha_ismaster", t, state);
          }
        };
        self2.s.coreTopology.on("joined", replsetRelay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("ping", relay("ping"));
        self2.s.coreTopology.on("ha", relayHa);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("fullsetup", function() {
          self2.emit("fullsetup", self2, self2);
        });
        self2.s.coreTopology.on("all", function() {
          self2.emit("all", null, self2);
        });
        var connectHandler = function() {
          self2.s.coreTopology.once("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.once("close", errorHandler("close"));
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectErrorHandler = function() {
          return function(err) {
            ["timeout", "error", "close"].forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.s.coreTopology.destroy();
            try {
              callback(err);
            } catch (err2) {
              if (!self2.s.coreTopology.isConnected())
                process.nextTick(function() {
                  throw err2;
                });
            }
          };
        };
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.connect(_options);
      }
      close(forceClosed, callback) {
        ["timeout", "error", "close", "joined", "left"].forEach((e) => this.removeAllListeners(e));
        super.close(forceClosed, callback);
      }
    };
    Object.defineProperty(ReplSet.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/url_parser.js
var require_url_parser = __commonJS({
  "node_modules/mongodb/lib/url_parser.js"(exports2, module2) {
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var parser = __require("url");
    var f = __require("util").format;
    var Logger = require_core().Logger;
    var dns = __require("dns");
    var ReadConcern = require_read_concern();
    var qs = __require("querystring");
    var MongoParseError = require_error().MongoParseError;
    module2.exports = function(url, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      let result;
      try {
        result = parser.parse(url, true);
      } catch (e) {
        return callback(new Error("URL malformed, cannot be parsed"));
      }
      if (result.protocol !== "mongodb:" && result.protocol !== "mongodb+srv:") {
        return callback(new Error("Invalid schema, expected `mongodb` or `mongodb+srv`"));
      }
      if (result.protocol === "mongodb:") {
        return parseHandler(url, options, callback);
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new Error("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = url.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new Error("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new Error("Ports not accepted with `mongodb+srv` URIs"));
      }
      let srvAddress = `_mongodb._tcp.${result.host}`;
      dns.resolveSrv(srvAddress, function(err, addresses) {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new Error("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new Error("Server record does not share hostname with parent URI"));
          }
        }
        let base = result.auth ? `mongodb://${result.auth}@` : `mongodb://`;
        let connectionStrings = addresses.map(function(address, i) {
          if (i === 0)
            return `${base}${address.name}:${address.port}`;
          else
            return `${address.name}:${address.port}`;
        });
        let connectionString = connectionStrings.join(",") + "/";
        let connectionStringOptions = [];
        if (result.path) {
          let defaultDb = result.path.slice(1);
          if (defaultDb.indexOf("?") !== -1) {
            defaultDb = defaultDb.slice(0, defaultDb.indexOf("?"));
          }
          connectionString += defaultDb;
        }
        if (!options.ssl && !result.search) {
          connectionStringOptions.push("ssl=true");
        } else if (!options.ssl && result.search && !result.search.match("ssl")) {
          connectionStringOptions.push("ssl=true");
        }
        if (result.search) {
          connectionStringOptions.push(result.search.replace("?", ""));
        }
        dns.resolveTxt(result.host, function(err2, record) {
          if (err2 && err2.code !== "ENODATA" && err2.code !== "ENOTFOUND")
            return callback(err2);
          if (err2 && err2.code === "ENODATA")
            record = null;
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = record[0].join("");
            const parsedRecord = qs.parse(record);
            const items = Object.keys(parsedRecord);
            if (Object.keys(items).some((k) => k.toLowerCase() === "loadbalanced")) {
              return callback(new MongoParseError("Load balancer mode requires driver version 4+"));
            }
            if (items.some((item) => item !== "authSource" && item !== "replicaSet")) {
              return callback(
                new MongoParseError("Text record must only set `authSource` or `replicaSet`")
              );
            }
            if (items.length > 0) {
              connectionStringOptions.push(record);
            }
          }
          if (connectionStringOptions.length) {
            connectionString += `?${connectionStringOptions.join("&")}`;
          }
          parseHandler(connectionString, options, callback);
        });
      });
    };
    function matchesParentDomain(srvAddress, parentDomain) {
      let regex = /^.*?\./;
      let srv = `.${srvAddress.replace(regex, "")}`;
      let parent = `.${parentDomain.replace(regex, "")}`;
      if (srv.endsWith(parent))
        return true;
      else
        return false;
    }
    function parseHandler(address, options, callback) {
      let result, err;
      try {
        result = parseConnectionString(address, options);
      } catch (e) {
        err = e;
      }
      return err ? callback(err, null) : callback(null, result);
    }
    function parseConnectionString(url, options) {
      let connection_part = "";
      let auth_part = "";
      let query_string_part = "";
      let dbName = "admin";
      let result = parser.parse(url, true);
      if ((result.hostname == null || result.hostname === "") && url.indexOf(".sock") === -1) {
        throw new Error("No hostname or hostnames provided in connection string");
      }
      if (result.port === "0") {
        throw new Error("Invalid port (zero) with hostname");
      }
      if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
        throw new Error("Invalid port (larger than 65535) with hostname");
      }
      if (result.path && result.path.length > 0 && result.path[0] !== "/" && url.indexOf(".sock") === -1) {
        throw new Error("Missing delimiting slash between hosts and options");
      }
      if (result.query) {
        for (let name in result.query) {
          if (name.indexOf("::") !== -1) {
            throw new Error("Double colon in host identifier");
          }
          if (result.query[name] === "") {
            throw new Error("Query parameter " + name + " is an incomplete value pair");
          }
        }
      }
      if (result.auth) {
        let parts = result.auth.split(":");
        if (url.indexOf(result.auth) !== -1 && parts.length > 2) {
          throw new Error("Username with password containing an unescaped colon");
        }
        if (url.indexOf(result.auth) !== -1 && result.auth.indexOf("@") !== -1) {
          throw new Error("Username containing an unescaped at-sign");
        }
      }
      let clean = url.split("?").shift();
      let strings = clean.split(",");
      let hosts = [];
      for (let i = 0; i < strings.length; i++) {
        let hostString = strings[i];
        if (hostString.indexOf("mongodb") !== -1) {
          if (hostString.indexOf("@") !== -1) {
            hosts.push(hostString.split("@").pop());
          } else {
            hosts.push(hostString.substr("mongodb://".length));
          }
        } else if (hostString.indexOf("/") !== -1) {
          hosts.push(hostString.split("/").shift());
        } else if (hostString.indexOf("/") === -1) {
          hosts.push(hostString.trim());
        }
      }
      for (let i = 0; i < hosts.length; i++) {
        let r = parser.parse(f("mongodb://%s", hosts[i].trim()));
        if (r.path && r.path.indexOf(".sock") !== -1)
          continue;
        if (r.path && r.path.indexOf(":") !== -1) {
          if (r.path.split("/").length > 1 && r.path.indexOf("::") === -1) {
            throw new Error("Slash in host identifier");
          } else {
            throw new Error("Double colon in host identifier");
          }
        }
      }
      if (url.indexOf("?") !== -1) {
        query_string_part = url.substr(url.indexOf("?") + 1);
        connection_part = url.substring("mongodb://".length, url.indexOf("?"));
      } else {
        connection_part = url.substring("mongodb://".length);
      }
      if (connection_part.indexOf("@") !== -1) {
        auth_part = connection_part.split("@")[0];
        connection_part = connection_part.split("@")[1];
      }
      if (connection_part.split("/").length > 2) {
        throw new Error(
          "Unsupported host '" + connection_part.split("?")[0] + "', hosts must be URL encoded and contain at most one unencoded slash"
        );
      }
      if (connection_part.indexOf(".sock") !== -1) {
        if (connection_part.indexOf(".sock/") !== -1) {
          dbName = connection_part.split(".sock/")[1];
          if (dbName.indexOf("/") !== -1) {
            if (dbName.split("/").length === 2 && dbName.split("/")[1].length === 0) {
              throw new Error("Illegal trailing backslash after database name");
            }
            throw new Error("More than 1 database name in URL");
          }
          connection_part = connection_part.split(
            "/",
            connection_part.indexOf(".sock") + ".sock".length
          );
        }
      } else if (connection_part.indexOf("/") !== -1) {
        if (connection_part.split("/").length > 2) {
          if (connection_part.split("/")[2].length === 0) {
            throw new Error("Illegal trailing backslash after database name");
          }
          throw new Error("More than 1 database name in URL");
        }
        dbName = connection_part.split("/")[1];
        connection_part = connection_part.split("/")[0];
      }
      connection_part = decodeURIComponent(connection_part);
      let object2 = {};
      let authPart = auth_part || "";
      let auth = authPart.split(":", 2);
      let user = decodeURIComponent(auth[0]);
      if (auth[0] !== encodeURIComponent(user)) {
        throw new Error("Username contains an illegal unescaped character");
      }
      auth[0] = user;
      if (auth[1]) {
        let pass = decodeURIComponent(auth[1]);
        if (auth[1] !== encodeURIComponent(pass)) {
          throw new Error("Password contains an illegal unescaped character");
        }
        auth[1] = pass;
      }
      if (auth.length === 2)
        object2.auth = { user: auth[0], password: auth[1] };
      if (options && options.auth != null)
        object2.auth = options.auth;
      let hostPart;
      let urlOptions;
      let servers;
      let compression;
      let serverOptions = { socketOptions: {} };
      let dbOptions = { read_preference_tags: [] };
      let replSetServersOptions = { socketOptions: {} };
      let mongosOptions = { socketOptions: {} };
      object2.server_options = serverOptions;
      object2.db_options = dbOptions;
      object2.rs_options = replSetServersOptions;
      object2.mongos_options = mongosOptions;
      if (url.match(/\.sock/)) {
        let domainSocket = url.substring(
          url.indexOf("mongodb://") + "mongodb://".length,
          url.lastIndexOf(".sock") + ".sock".length
        );
        if (domainSocket.indexOf("@") !== -1)
          domainSocket = domainSocket.split("@")[1];
        domainSocket = decodeURIComponent(domainSocket);
        servers = [{ domain_socket: domainSocket }];
      } else {
        hostPart = connection_part;
        let deduplicatedServers = {};
        servers = hostPart.split(",").map(function(h) {
          let _host, _port, ipv6match;
          if (ipv6match = /\[([^\]]+)\](?::(.+))?/.exec(h)) {
            _host = ipv6match[1];
            _port = parseInt(ipv6match[2], 10) || 27017;
          } else {
            let hostPort = h.split(":", 2);
            _host = hostPort[0] || "localhost";
            _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
            if (_host.indexOf("?") !== -1)
              _host = _host.split(/\?/)[0];
          }
          if (deduplicatedServers[_host + "_" + _port])
            return null;
          deduplicatedServers[_host + "_" + _port] = 1;
          return { host: _host, port: _port };
        }).filter(function(x) {
          return x != null;
        });
      }
      object2.dbName = dbName || "admin";
      urlOptions = (query_string_part || "").split(/[&;]/);
      if (urlOptions.some((k) => k.toLowerCase() === "loadbalanced")) {
        throw new MongoParseError("Load balancer mode requires driver version 4+");
      }
      urlOptions.forEach(function(opt) {
        if (!opt)
          return;
        var splitOpt = opt.split("="), name = splitOpt[0], value2 = splitOpt[1];
        switch (name) {
          case "slaveOk":
          case "slave_ok":
            serverOptions.slave_ok = value2 === "true";
            dbOptions.slaveOk = value2 === "true";
            break;
          case "maxPoolSize":
          case "poolSize":
            serverOptions.poolSize = parseInt(value2, 10);
            replSetServersOptions.poolSize = parseInt(value2, 10);
            break;
          case "appname":
            object2.appname = decodeURIComponent(value2);
            break;
          case "autoReconnect":
          case "auto_reconnect":
            serverOptions.auto_reconnect = value2 === "true";
            break;
          case "ssl":
            if (value2 === "prefer") {
              serverOptions.ssl = value2;
              replSetServersOptions.ssl = value2;
              mongosOptions.ssl = value2;
              break;
            }
            serverOptions.ssl = value2 === "true";
            replSetServersOptions.ssl = value2 === "true";
            mongosOptions.ssl = value2 === "true";
            break;
          case "sslValidate":
            serverOptions.sslValidate = value2 === "true";
            replSetServersOptions.sslValidate = value2 === "true";
            mongosOptions.sslValidate = value2 === "true";
            break;
          case "replicaSet":
          case "rs_name":
            replSetServersOptions.rs_name = value2;
            break;
          case "reconnectWait":
            replSetServersOptions.reconnectWait = parseInt(value2, 10);
            break;
          case "retries":
            replSetServersOptions.retries = parseInt(value2, 10);
            break;
          case "readSecondary":
          case "read_secondary":
            replSetServersOptions.read_secondary = value2 === "true";
            break;
          case "fsync":
            dbOptions.fsync = value2 === "true";
            break;
          case "journal":
            dbOptions.j = value2 === "true";
            break;
          case "safe":
            dbOptions.safe = value2 === "true";
            break;
          case "nativeParser":
          case "native_parser":
            dbOptions.native_parser = value2 === "true";
            break;
          case "readConcernLevel":
            dbOptions.readConcern = new ReadConcern(value2);
            break;
          case "connectTimeoutMS":
            serverOptions.socketOptions.connectTimeoutMS = parseInt(value2, 10);
            replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value2, 10);
            mongosOptions.socketOptions.connectTimeoutMS = parseInt(value2, 10);
            break;
          case "socketTimeoutMS":
            serverOptions.socketOptions.socketTimeoutMS = parseInt(value2, 10);
            replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value2, 10);
            mongosOptions.socketOptions.socketTimeoutMS = parseInt(value2, 10);
            break;
          case "w":
            dbOptions.w = parseInt(value2, 10);
            if (isNaN(dbOptions.w))
              dbOptions.w = value2;
            break;
          case "authSource":
            dbOptions.authSource = value2;
            break;
          case "gssapiServiceName":
            dbOptions.gssapiServiceName = value2;
            break;
          case "authMechanism":
            if (value2 === "GSSAPI") {
              if (object2.auth == null) {
                let urlDecodeAuthPart = decodeURIComponent(authPart);
                if (urlDecodeAuthPart.indexOf("@") === -1)
                  throw new Error("GSSAPI requires a provided principal");
                object2.auth = { user: urlDecodeAuthPart, password: null };
              } else {
                object2.auth.user = decodeURIComponent(object2.auth.user);
              }
            } else if (value2 === "MONGODB-X509") {
              object2.auth = { user: decodeURIComponent(authPart) };
            }
            if (value2 !== "GSSAPI" && value2 !== "MONGODB-X509" && value2 !== "MONGODB-CR" && value2 !== "DEFAULT" && value2 !== "SCRAM-SHA-1" && value2 !== "SCRAM-SHA-256" && value2 !== "PLAIN")
              throw new Error(
                "Only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, or SCRAM-SHA-1 is supported by authMechanism"
              );
            dbOptions.authMechanism = value2;
            break;
          case "authMechanismProperties":
            {
              let values = value2.split(",");
              let o = {};
              values.forEach(function(x) {
                let v = x.split(":");
                o[v[0]] = v[1];
              });
              dbOptions.authMechanismProperties = o;
              if (typeof o.SERVICE_NAME === "string")
                dbOptions.gssapiServiceName = o.SERVICE_NAME;
              if (typeof o.SERVICE_REALM === "string")
                dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
              if (typeof o.CANONICALIZE_HOST_NAME === "string")
                dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME === "true" ? true : false;
            }
            break;
          case "wtimeoutMS":
            dbOptions.wtimeout = parseInt(value2, 10);
            break;
          case "readPreference":
            if (!ReadPreference.isValid(value2))
              throw new Error(
                "readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest"
              );
            dbOptions.readPreference = value2;
            break;
          case "maxStalenessSeconds":
            dbOptions.maxStalenessSeconds = parseInt(value2, 10);
            break;
          case "readPreferenceTags":
            {
              value2 = decodeURIComponent(value2);
              let tagObject = {};
              if (value2 == null || value2 === "") {
                dbOptions.read_preference_tags.push(tagObject);
                break;
              }
              let tags = value2.split(/,/);
              for (let i = 0; i < tags.length; i++) {
                let parts = tags[i].trim().split(/:/);
                tagObject[parts[0]] = parts[1];
              }
              dbOptions.read_preference_tags.push(tagObject);
            }
            break;
          case "compressors":
            {
              compression = serverOptions.compression || {};
              let compressors = value2.split(",");
              if (!compressors.every(function(compressor) {
                return compressor === "snappy" || compressor === "zlib";
              })) {
                throw new Error("Compressors must be at least one of snappy or zlib");
              }
              compression.compressors = compressors;
              serverOptions.compression = compression;
            }
            break;
          case "zlibCompressionLevel":
            {
              compression = serverOptions.compression || {};
              let zlibCompressionLevel = parseInt(value2, 10);
              if (zlibCompressionLevel < -1 || zlibCompressionLevel > 9) {
                throw new Error("zlibCompressionLevel must be an integer between -1 and 9");
              }
              compression.zlibCompressionLevel = zlibCompressionLevel;
              serverOptions.compression = compression;
            }
            break;
          case "retryWrites":
            dbOptions.retryWrites = value2 === "true";
            break;
          case "minSize":
            dbOptions.minSize = parseInt(value2, 10);
            break;
          default:
            {
              let logger = Logger("URL Parser");
              logger.warn(`${name} is not supported as a connection string option`);
            }
            break;
        }
      });
      if (dbOptions.read_preference_tags.length === 0) {
        dbOptions.read_preference_tags = null;
      }
      if ((dbOptions.w === -1 || dbOptions.w === 0) && (dbOptions.journal === true || dbOptions.fsync === true || dbOptions.safe === true))
        throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync");
      if (!dbOptions.readPreference) {
        dbOptions.readPreference = "primary";
      }
      dbOptions = Object.assign(dbOptions, options);
      object2.servers = servers;
      return object2;
    }
  }
});

// node_modules/mongodb/lib/apm.js
var require_apm2 = __commonJS({
  "node_modules/mongodb/lib/apm.js"(exports2, module2) {
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var Instrumentation = class extends EventEmitter {
      constructor() {
        super();
      }
      instrument(MongoClient, callback) {
        this.$MongoClient = MongoClient;
        const $prototypeConnect = this.$prototypeConnect = MongoClient.prototype.connect;
        const instrumentation = this;
        MongoClient.prototype.connect = function(callback2) {
          this.s.options.monitorCommands = true;
          this.on("commandStarted", (event) => instrumentation.emit("started", event));
          this.on("commandSucceeded", (event) => instrumentation.emit("succeeded", event));
          this.on("commandFailed", (event) => instrumentation.emit("failed", event));
          return $prototypeConnect.call(this, callback2);
        };
        if (typeof callback === "function")
          callback(null, this);
      }
      uninstrument() {
        this.$MongoClient.prototype.connect = this.$prototypeConnect;
      }
    };
    module2.exports = Instrumentation;
  }
});

// node_modules/mongodb/lib/gridfs/chunk.js
var require_chunk = __commonJS({
  "node_modules/mongodb/lib/gridfs/chunk.js"(exports2, module2) {
    "use strict";
    var Binary2 = require_core().BSON.Binary;
    var ObjectID2 = require_core().BSON.ObjectID;
    var Buffer2 = require_safe_buffer().Buffer;
    var Chunk = function(file, mongoObject, writeConcern) {
      if (!(this instanceof Chunk))
        return new Chunk(file, mongoObject);
      this.file = file;
      var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
      this.writeConcern = writeConcern || { w: 1 };
      this.objectId = mongoObjectFinal._id == null ? new ObjectID2() : mongoObjectFinal._id;
      this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
      this.data = new Binary2();
      if (typeof mongoObjectFinal.data === "string") {
        var buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (Array.isArray(mongoObjectFinal.data)) {
        buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        var data = mongoObjectFinal.data.join("");
        buffer.write(data, 0, data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === "Binary") {
        this.data = mongoObjectFinal.data;
      } else if (!Buffer2.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
        throw Error("Illegal chunk format");
      }
      this.internalPosition = 0;
    };
    Chunk.prototype.write = function(data, callback) {
      this.data.write(data, this.internalPosition, data.length, "binary");
      this.internalPosition = this.data.length();
      if (callback != null)
        return callback(null, this);
      return this;
    };
    Chunk.prototype.read = function(length) {
      length = length == null || length === 0 ? this.length() : length;
      if (this.length() - this.internalPosition + 1 >= length) {
        var data = this.data.read(this.internalPosition, length);
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return "";
      }
    };
    Chunk.prototype.readSlice = function(length) {
      if (this.length() - this.internalPosition >= length) {
        var data = null;
        if (this.data.buffer != null) {
          data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
        } else {
          data = Buffer2.alloc(length);
          length = this.data.readInto(data, this.internalPosition);
        }
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return null;
      }
    };
    Chunk.prototype.eof = function() {
      return this.internalPosition === this.length() ? true : false;
    };
    Chunk.prototype.getc = function() {
      return this.read(1);
    };
    Chunk.prototype.rewind = function() {
      this.internalPosition = 0;
      this.data = new Binary2();
    };
    Chunk.prototype.save = function(options, callback) {
      var self2 = this;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      self2.file.chunkCollection(function(err, collection) {
        if (err)
          return callback(err);
        var writeOptions = { upsert: true };
        for (var name in options)
          writeOptions[name] = options[name];
        for (name in self2.writeConcern)
          writeOptions[name] = self2.writeConcern[name];
        if (self2.data.length() > 0) {
          self2.buildMongoObject(function(mongoObject) {
            var options2 = { forceServerObjectId: true };
            for (var name2 in self2.writeConcern) {
              options2[name2] = self2.writeConcern[name2];
            }
            collection.replaceOne({ _id: self2.objectId }, mongoObject, writeOptions, function(err2) {
              callback(err2, self2);
            });
          });
        } else {
          callback(null, self2);
        }
      });
    };
    Chunk.prototype.buildMongoObject = function(callback) {
      var mongoObject = {
        files_id: this.file.fileId,
        n: this.chunkNumber,
        data: this.data
      };
      if (this.objectId != null)
        mongoObject._id = this.objectId;
      callback(mongoObject);
    };
    Chunk.prototype.length = function() {
      return this.data.length();
    };
    Object.defineProperty(Chunk.prototype, "position", {
      enumerable: true,
      get: function() {
        return this.internalPosition;
      },
      set: function(value2) {
        this.internalPosition = value2;
      }
    });
    Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
    module2.exports = Chunk;
  }
});

// node_modules/mongodb/lib/gridfs/grid_store.js
var require_grid_store = __commonJS({
  "node_modules/mongodb/lib/gridfs/grid_store.js"(exports2, module2) {
    "use strict";
    var Chunk = require_chunk();
    var ObjectID2 = require_core().BSON.ObjectID;
    var ReadPreference = require_core().ReadPreference;
    var Buffer2 = require_safe_buffer().Buffer;
    var fs2 = __require("fs");
    var f = __require("util").format;
    var util = __require("util");
    var MongoError = require_core().MongoError;
    var inherits = util.inherits;
    var Duplex = __require("stream").Duplex;
    var shallowClone = require_utils().shallowClone;
    var executeLegacyOperation = require_utils().executeLegacyOperation;
    var deprecate = __require("util").deprecate;
    var REFERENCE_BY_FILENAME = 0;
    var REFERENCE_BY_ID = 1;
    var deprecationFn = deprecate(
      () => {
      },
      "GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead"
    );
    var GridStore = function GridStore2(db, id, filename, mode, options) {
      deprecationFn();
      if (!(this instanceof GridStore2))
        return new GridStore2(db, id, filename, mode, options);
      this.db = db;
      if (typeof options === "undefined")
        options = {};
      if (typeof mode === "undefined") {
        mode = filename;
        filename = void 0;
      } else if (typeof mode === "object") {
        options = mode;
        mode = filename;
        filename = void 0;
      }
      if (id && id._bsontype === "ObjectID") {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      } else if (typeof filename === "undefined") {
        this.referenceBy = REFERENCE_BY_FILENAME;
        this.filename = id;
        if (mode.indexOf("w") != null) {
          this.fileId = new ObjectID2();
        }
      } else {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      }
      this.mode = mode == null ? "r" : mode;
      this.options = options || {};
      this.isOpen = false;
      this.root = this.options["root"] == null ? GridStore2.DEFAULT_ROOT_COLLECTION : this.options["root"];
      this.position = 0;
      this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.primary;
      this.writeConcern = _getWriteConcern(db, this.options);
      this.internalChunkSize = this.options["chunkSize"] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options["chunkSize"];
      var promiseLibrary = this.options.promiseLibrary || Promise;
      this.promiseLibrary = promiseLibrary;
      Object.defineProperty(this, "chunkSize", {
        enumerable: true,
        get: function() {
          return this.internalChunkSize;
        },
        set: function(value2) {
          if (!(this.mode[0] === "w" && this.position === 0 && this.uploadDate == null)) {
            this.internalChunkSize = this.internalChunkSize;
          } else {
            this.internalChunkSize = value2;
          }
        }
      });
      Object.defineProperty(this, "md5", {
        enumerable: true,
        get: function() {
          return this.internalMd5;
        }
      });
      Object.defineProperty(this, "chunkNumber", {
        enumerable: true,
        get: function() {
          return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
        }
      });
    };
    GridStore.prototype.open = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.mode !== "w" && this.mode !== "w+" && this.mode !== "r") {
        throw MongoError.create({ message: "Illegal mode " + this.mode, driver: true });
      }
      return executeLegacyOperation(this.db.s.topology, open, [this, options, callback], {
        skipSessions: true
      });
    };
    var open = function(self2, options, callback) {
      var writeConcern = _getWriteConcern(self2.db, self2.options);
      if (self2.mode === "w" || self2.mode === "w+") {
        var collection = self2.collection();
        collection.ensureIndex([["filename", 1]], writeConcern, function() {
          var chunkCollection = self2.chunkCollection();
          var chunkIndexOptions = shallowClone(writeConcern);
          chunkIndexOptions.unique = true;
          chunkCollection.ensureIndex(
            [
              ["files_id", 1],
              ["n", 1]
            ],
            chunkIndexOptions,
            function() {
              _open(self2, writeConcern, function(err, r) {
                if (err)
                  return callback(err);
                self2.isOpen = true;
                callback(err, r);
              });
            }
          );
        });
      } else {
        _open(self2, writeConcern, function(err, r) {
          if (err)
            return callback(err);
          self2.isOpen = true;
          callback(err, r);
        });
      }
    };
    GridStore.prototype.eof = function() {
      return this.position === this.length ? true : false;
    };
    GridStore.prototype.getc = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, getc, [this, options, callback], {
        skipSessions: true
      });
    };
    var getc = function(self2, options, callback) {
      if (self2.eof()) {
        callback(null, null);
      } else if (self2.currentChunk.eof()) {
        nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
          self2.currentChunk = chunk;
          self2.position = self2.position + 1;
          callback(err, self2.currentChunk.getc());
        });
      } else {
        self2.position = self2.position + 1;
        callback(null, self2.currentChunk.getc());
      }
    };
    GridStore.prototype.puts = function(string, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      var finalString = string.match(/\n$/) == null ? string + "\n" : string;
      return executeLegacyOperation(
        this.db.s.topology,
        this.write.bind(this),
        [finalString, options, callback],
        { skipSessions: true }
      );
    };
    GridStore.prototype.stream = function() {
      return new GridStoreStream(this);
    };
    GridStore.prototype.write = function write(data, close2, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(
        this.db.s.topology,
        _writeNormal,
        [this, data, close2, options, callback],
        { skipSessions: true }
      );
    };
    GridStore.prototype.destroy = function destroy() {
      if (!this.writable)
        return;
      this.readable = false;
      if (this.writable) {
        this.writable = false;
        this._q.length = 0;
        this.emit("close");
      }
    };
    GridStore.prototype.writeFile = function(file, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options, callback], {
        skipSessions: true
      });
    };
    var writeFile = function(self2, file, options, callback) {
      if (typeof file === "string") {
        fs2.open(file, "r", function(err, fd) {
          if (err)
            return callback(err);
          self2.writeFile(fd, callback);
        });
        return;
      }
      self2.open(function(err, self3) {
        if (err)
          return callback(err, self3);
        fs2.fstat(file, function(err2, stats) {
          if (err2)
            return callback(err2, self3);
          var offset = 0;
          var index = 0;
          var writeChunk = function() {
            var _buffer = Buffer2.alloc(self3.chunkSize);
            fs2.read(file, _buffer, 0, _buffer.length, offset, function(err3, bytesRead, data) {
              if (err3)
                return callback(err3, self3);
              offset = offset + bytesRead;
              var chunk = new Chunk(self3, { n: index++ }, self3.writeConcern);
              chunk.write(data.slice(0, bytesRead), function(err4, chunk2) {
                if (err4)
                  return callback(err4, self3);
                chunk2.save({}, function(err5) {
                  if (err5)
                    return callback(err5, self3);
                  self3.position = self3.position + bytesRead;
                  self3.currentChunk = chunk2;
                  if (offset >= stats.size) {
                    fs2.close(file, function(err6) {
                      if (err6)
                        return callback(err6);
                      self3.close(function(err7) {
                        if (err7)
                          return callback(err7, self3);
                        return callback(null, self3);
                      });
                    });
                  } else {
                    return process.nextTick(writeChunk);
                  }
                });
              });
            });
          };
          process.nextTick(writeChunk);
        });
      });
    };
    GridStore.prototype.close = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, close, [this, options, callback], {
        skipSessions: true
      });
    };
    var close = function(self2, options, callback) {
      if (self2.mode[0] === "w") {
        options = Object.assign({}, self2.writeConcern, options);
        if (self2.currentChunk != null && self2.currentChunk.position > 0) {
          self2.currentChunk.save({}, function(err) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.collection(function(err2, files) {
              if (err2 && typeof callback === "function")
                return callback(err2);
              if (self2.uploadDate != null) {
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              } else {
                self2.uploadDate = /* @__PURE__ */ new Date();
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              }
            });
          });
        } else {
          self2.collection(function(err, files) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.uploadDate = /* @__PURE__ */ new Date();
            buildMongoObject(self2, function(err2, mongoObject) {
              if (err2) {
                if (typeof callback === "function")
                  return callback(err2);
                else
                  throw err2;
              }
              files.save(mongoObject, options, function(err3) {
                if (typeof callback === "function")
                  callback(err3, mongoObject);
              });
            });
          });
        }
      } else if (self2.mode[0] === "r") {
        if (typeof callback === "function")
          callback(null, null);
      } else {
        if (typeof callback === "function")
          callback(MongoError.create({ message: f("Illegal mode %s", self2.mode), driver: true }));
      }
    };
    GridStore.prototype.chunkCollection = function(callback) {
      if (typeof callback === "function")
        return this.db.collection(this.root + ".chunks", callback);
      return this.db.collection(this.root + ".chunks");
    };
    GridStore.prototype.unlink = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, unlink, [this, options, callback], {
        skipSessions: true
      });
    };
    var unlink = function(self2, options, callback) {
      deleteChunks(self2, function(err) {
        if (err !== null) {
          err.message = "at deleteChunks: " + err.message;
          return callback(err);
        }
        self2.collection(function(err2, collection) {
          if (err2 !== null) {
            err2.message = "at collection: " + err2.message;
            return callback(err2);
          }
          collection.remove({ _id: self2.fileId }, self2.writeConcern, function(err3) {
            callback(err3, self2);
          });
        });
      });
    };
    GridStore.prototype.collection = function(callback) {
      if (typeof callback === "function")
        this.db.collection(this.root + ".files", callback);
      return this.db.collection(this.root + ".files");
    };
    GridStore.prototype.readlines = function(separator, options, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : "\n";
      separator = separator || "\n";
      options = args.length ? args.shift() : {};
      return executeLegacyOperation(
        this.db.s.topology,
        readlines,
        [this, separator, options, callback],
        { skipSessions: true }
      );
    };
    var readlines = function(self2, separator, options, callback) {
      self2.read(function(err, data) {
        if (err)
          return callback(err);
        var items = data.toString().split(separator);
        items = items.length > 0 ? items.splice(0, items.length - 1) : [];
        for (var i = 0; i < items.length; i++) {
          items[i] = items[i] + separator;
        }
        callback(null, items);
      });
    };
    GridStore.prototype.rewind = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.db.s.topology, rewind, [this, options, callback], {
        skipSessions: true
      });
    };
    var rewind = function(self2, options, callback) {
      if (self2.currentChunk.chunkNumber !== 0) {
        if (self2.mode[0] === "w") {
          deleteChunks(self2, function(err) {
            if (err)
              return callback(err);
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.position = 0;
            callback(null, self2);
          });
        } else {
          self2.currentChunk(0, function(err, chunk) {
            if (err)
              return callback(err);
            self2.currentChunk = chunk;
            self2.currentChunk.rewind();
            self2.position = 0;
            callback(null, self2);
          });
        }
      } else {
        self2.currentChunk.rewind();
        self2.position = 0;
        callback(null, self2);
      }
    };
    GridStore.prototype.read = function(length, buffer, options, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      buffer = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      return executeLegacyOperation(
        this.db.s.topology,
        read,
        [this, length, buffer, options, callback],
        { skipSessions: true }
      );
    };
    var read = function(self2, length, buffer, options, callback) {
      var finalLength = length == null ? self2.length - self2.position : length;
      var finalBuffer = buffer == null ? Buffer2.alloc(finalLength) : buffer;
      finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
      if (self2.currentChunk.length() - self2.currentChunk.position + finalBuffer._index >= finalLength) {
        var slice = self2.currentChunk.readSlice(finalLength - finalBuffer._index);
        slice.copy(finalBuffer, finalBuffer._index);
        self2.position = self2.position + finalBuffer.length;
        if (finalLength === 0 && finalBuffer.length === 0)
          return callback(MongoError.create({ message: "File does not exist", driver: true }), null);
        return callback(null, finalBuffer);
      }
      slice = self2.currentChunk.readSlice(self2.currentChunk.length() - self2.currentChunk.position);
      slice.copy(finalBuffer, finalBuffer._index);
      finalBuffer._index += slice.length;
      nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
        if (err)
          return callback(err);
        if (chunk.length() > 0) {
          self2.currentChunk = chunk;
          self2.read(length, finalBuffer, callback);
        } else {
          if (finalBuffer._index > 0) {
            callback(null, finalBuffer);
          } else {
            callback(
              MongoError.create({
                message: "no chunks found for file, possibly corrupt",
                driver: true
              }),
              null
            );
          }
        }
      });
    };
    GridStore.prototype.tell = function(callback) {
      var self2 = this;
      if (typeof callback === "function")
        return callback(null, this.position);
      return new self2.promiseLibrary(function(resolve) {
        resolve(self2.position);
      });
    };
    GridStore.prototype.seek = function(position, seekLocation, options, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      seekLocation = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      return executeLegacyOperation(
        this.db.s.topology,
        seek,
        [this, position, seekLocation, options, callback],
        { skipSessions: true }
      );
    };
    var seek = function(self2, position, seekLocation, options, callback) {
      if (self2.mode !== "r") {
        return callback(
          MongoError.create({ message: "seek is only supported for mode r", driver: true })
        );
      }
      var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
      var finalPosition = position;
      var targetPosition = 0;
      if (seekLocationFinal === GridStore.IO_SEEK_CUR) {
        targetPosition = self2.position + finalPosition;
      } else if (seekLocationFinal === GridStore.IO_SEEK_END) {
        targetPosition = self2.length + finalPosition;
      } else {
        targetPosition = finalPosition;
      }
      var newChunkNumber = Math.floor(targetPosition / self2.chunkSize);
      var seekChunk = function() {
        nthChunk(self2, newChunkNumber, function(err, chunk) {
          if (err)
            return callback(err, null);
          if (chunk == null)
            return callback(new Error("no chunk found"));
          self2.currentChunk = chunk;
          self2.position = targetPosition;
          self2.currentChunk.position = self2.position % self2.chunkSize;
          callback(err, self2);
        });
      };
      seekChunk();
    };
    var _open = function(self2, options, callback) {
      var collection = self2.collection();
      var query = self2.referenceBy === REFERENCE_BY_ID ? { _id: self2.fileId } : { filename: self2.filename };
      query = null == self2.fileId && self2.filename == null ? null : query;
      options.readPreference = self2.readPreference;
      if (query != null) {
        collection.findOne(query, options, function(err, doc) {
          if (err) {
            return error(err);
          }
          if (doc != null) {
            self2.fileId = doc._id;
            self2.filename = self2.mode === "r" || self2.filename === void 0 ? doc.filename : self2.filename;
            self2.contentType = doc.contentType;
            self2.internalChunkSize = doc.chunkSize;
            self2.uploadDate = doc.uploadDate;
            self2.aliases = doc.aliases;
            self2.length = doc.length;
            self2.metadata = doc.metadata;
            self2.internalMd5 = doc.md5;
          } else if (self2.mode !== "r") {
            self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
            self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
            self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
            self2.length = 0;
          } else {
            self2.length = 0;
            var txtId = self2.fileId._bsontype === "ObjectID" ? self2.fileId.toHexString() : self2.fileId;
            return error(
              MongoError.create({
                message: f(
                  "file with id %s not opened for writing",
                  self2.referenceBy === REFERENCE_BY_ID ? txtId : self2.filename
                ),
                driver: true
              }),
              self2
            );
          }
          if (self2.mode === "r") {
            nthChunk(self2, 0, options, function(err2, chunk) {
              if (err2)
                return error(err2);
              self2.currentChunk = chunk;
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w" && doc) {
            deleteChunks(self2, options, function(err2) {
              if (err2)
                return error(err2);
              self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
              self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
              self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w") {
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          } else if (self2.mode === "w+") {
            nthChunk(self2, lastChunkNumber(self2), options, function(err2, chunk) {
              if (err2)
                return error(err2);
              self2.currentChunk = chunk == null ? new Chunk(self2, { n: 0 }, self2.writeConcern) : chunk;
              self2.currentChunk.position = self2.currentChunk.data.length();
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = self2.length;
              callback(null, self2);
            });
          }
        });
      } else {
        self2.fileId = null == self2.fileId ? new ObjectID2() : self2.fileId;
        self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
        self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
        self2.length = 0;
        if (self2.mode === "w") {
          deleteChunks(self2, options, function(err) {
            if (err)
              return error(err);
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          });
        } else if (self2.mode === "w+") {
          nthChunk(self2, lastChunkNumber(self2), options, function(err, chunk) {
            if (err)
              return error(err);
            self2.currentChunk = chunk == null ? new Chunk(self2, { n: 0 }, self2.writeConcern) : chunk;
            self2.currentChunk.position = self2.currentChunk.data.length();
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = self2.length;
            callback(null, self2);
          });
        }
      }
      function error(err) {
        if (error.err)
          return;
        callback(error.err = err);
      }
    };
    var writeBuffer = function(self2, buffer, close2, callback) {
      if (typeof close2 === "function") {
        callback = close2;
        close2 = null;
      }
      var finalClose = typeof close2 === "boolean" ? close2 : false;
      if (self2.mode !== "w") {
        callback(
          MongoError.create({
            message: f(
              "file with id %s not opened for writing",
              self2.referenceBy === REFERENCE_BY_ID ? self2.referenceBy : self2.filename
            ),
            driver: true
          }),
          null
        );
      } else {
        if (self2.currentChunk.position + buffer.length >= self2.chunkSize) {
          var previousChunkNumber = self2.currentChunk.chunkNumber;
          var leftOverDataSize = self2.chunkSize - self2.currentChunk.position;
          var firstChunkData = buffer.slice(0, leftOverDataSize);
          var leftOverData = buffer.slice(leftOverDataSize);
          var chunksToWrite = [self2.currentChunk.write(firstChunkData)];
          while (leftOverData.length >= self2.chunkSize) {
            var newChunk = new Chunk(self2, { n: previousChunkNumber + 1 }, self2.writeConcern);
            firstChunkData = leftOverData.slice(0, self2.chunkSize);
            leftOverData = leftOverData.slice(self2.chunkSize);
            previousChunkNumber = previousChunkNumber + 1;
            newChunk.write(firstChunkData);
            chunksToWrite.push(newChunk);
          }
          self2.currentChunk = new Chunk(self2, { n: previousChunkNumber + 1 }, self2.writeConcern);
          if (leftOverData.length > 0)
            self2.currentChunk.write(leftOverData);
          self2.position = self2.position + buffer.length;
          var numberOfChunksToWrite = chunksToWrite.length;
          for (var i = 0; i < chunksToWrite.length; i++) {
            chunksToWrite[i].save({}, function(err) {
              if (err)
                return callback(err);
              numberOfChunksToWrite = numberOfChunksToWrite - 1;
              if (numberOfChunksToWrite <= 0) {
                if (finalClose) {
                  return self2.close(function(err2) {
                    callback(err2, self2);
                  });
                }
                return callback(null, self2);
              }
            });
          }
        } else {
          self2.position = self2.position + buffer.length;
          self2.currentChunk.write(buffer);
          if (finalClose) {
            return self2.close(function(err) {
              callback(err, self2);
            });
          }
          return callback(null, self2);
        }
      }
    };
    var buildMongoObject = function(self2, callback) {
      var mongoObject = {
        _id: self2.fileId,
        filename: self2.filename,
        contentType: self2.contentType,
        length: self2.position ? self2.position : 0,
        chunkSize: self2.chunkSize,
        uploadDate: self2.uploadDate,
        aliases: self2.aliases,
        metadata: self2.metadata
      };
      var md5Command = { filemd5: self2.fileId, root: self2.root };
      self2.db.command(md5Command, function(err, results) {
        if (err)
          return callback(err);
        mongoObject.md5 = results.md5;
        callback(null, mongoObject);
      });
    };
    var nthChunk = function(self2, chunkNumber, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || self2.writeConcern;
      options.readPreference = self2.readPreference;
      self2.chunkCollection().findOne({ files_id: self2.fileId, n: chunkNumber }, options, function(err, chunk) {
        if (err)
          return callback(err);
        var finalChunk = chunk == null ? {} : chunk;
        callback(null, new Chunk(self2, finalChunk, self2.writeConcern));
      });
    };
    var lastChunkNumber = function(self2) {
      return Math.floor((self2.length ? self2.length - 1 : 0) / self2.chunkSize);
    };
    var deleteChunks = function(self2, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || self2.writeConcern;
      if (self2.fileId != null) {
        self2.chunkCollection().remove({ files_id: self2.fileId }, options, function(err) {
          if (err)
            return callback(err, false);
          callback(null, true);
        });
      } else {
        callback(null, true);
      }
    };
    GridStore.DEFAULT_ROOT_COLLECTION = "fs";
    GridStore.DEFAULT_CONTENT_TYPE = "binary/octet-stream";
    GridStore.IO_SEEK_SET = 0;
    GridStore.IO_SEEK_CUR = 1;
    GridStore.IO_SEEK_END = 2;
    GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      options = options || {};
      return executeLegacyOperation(
        db.s.topology,
        exists,
        [db, fileIdObject, rootCollection, options, callback],
        { skipSessions: true }
      );
    };
    var exists = function(db, fileIdObject, rootCollection, options, callback) {
      var readPreference = options.readPreference || ReadPreference.PRIMARY;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        var query = typeof fileIdObject === "string" || Object.prototype.toString.call(fileIdObject) === "[object RegExp]" ? { filename: fileIdObject } : { _id: fileIdObject };
        if (fileIdObject != null && typeof fileIdObject === "object" && Object.prototype.toString.call(fileIdObject) !== "[object RegExp]") {
          query = fileIdObject;
        }
        collection.findOne(query, { readPreference }, function(err2, item) {
          if (err2)
            return callback(err2);
          callback(null, item == null ? false : true);
        });
      });
    };
    GridStore.list = function(db, rootCollection, options, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      options = options || {};
      return executeLegacyOperation(db.s.topology, list, [db, rootCollection, options, callback], {
        skipSessions: true
      });
    };
    var list = function(db, rootCollection, options, callback) {
      if (rootCollection != null && typeof rootCollection === "object") {
        options = rootCollection;
        rootCollection = null;
      }
      var readPreference = options.readPreference || ReadPreference.primary;
      var byId = options["id"] != null ? options["id"] : false;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      var items = [];
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        collection.find({}, { readPreference }, function(err2, cursor) {
          if (err2)
            return callback(err2);
          cursor.each(function(err3, item) {
            if (item != null) {
              items.push(byId ? item._id : item.filename);
            } else {
              callback(err3, items);
            }
          });
        });
      });
    };
    GridStore.read = function(db, name, length, offset, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      offset = args.length ? args.shift() : null;
      options = args.length ? args.shift() : null;
      options = options || {};
      return executeLegacyOperation(
        db.s.topology,
        readStatic,
        [db, name, length, offset, options, callback],
        { skipSessions: true }
      );
    };
    var readStatic = function(db, name, length, offset, options, callback) {
      new GridStore(db, name, "r", options).open(function(err, gridStore) {
        if (err)
          return callback(err);
        if (offset && offset >= gridStore.length)
          return callback("offset larger than size of file", null);
        if (length && length > gridStore.length)
          return callback("length is larger than the size of the file", null);
        if (offset && length && offset + length > gridStore.length)
          return callback("offset and length is larger than the size of the file", null);
        if (offset != null) {
          gridStore.seek(offset, function(err2, gridStore2) {
            if (err2)
              return callback(err2);
            gridStore2.read(length, callback);
          });
        } else {
          gridStore.read(length, callback);
        }
      });
    };
    GridStore.readlines = function(db, name, separator, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : null;
      options = args.length ? args.shift() : null;
      options = options || {};
      return executeLegacyOperation(
        db.s.topology,
        readlinesStatic,
        [db, name, separator, options, callback],
        { skipSessions: true }
      );
    };
    var readlinesStatic = function(db, name, separator, options, callback) {
      var finalSeperator = separator == null ? "\n" : separator;
      new GridStore(db, name, "r", options).open(function(err, gridStore) {
        if (err)
          return callback(err);
        gridStore.readlines(finalSeperator, callback);
      });
    };
    GridStore.unlink = function(db, names, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() : {};
      options = options || {};
      return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options, callback], {
        skipSessions: true
      });
    };
    var unlinkStatic = function(self2, db, names, options, callback) {
      var writeConcern = _getWriteConcern(db, options);
      if (names.constructor === Array) {
        var tc = 0;
        for (var i = 0; i < names.length; i++) {
          ++tc;
          GridStore.unlink(db, names[i], options, function() {
            if (--tc === 0) {
              callback(null, self2);
            }
          });
        }
      } else {
        new GridStore(db, names, "w", options).open(function(err, gridStore) {
          if (err)
            return callback(err);
          deleteChunks(gridStore, function(err2) {
            if (err2)
              return callback(err2);
            gridStore.collection(function(err3, collection) {
              if (err3)
                return callback(err3);
              collection.remove({ _id: gridStore.fileId }, writeConcern, function(err4) {
                callback(err4, self2);
              });
            });
          });
        });
      }
    };
    var _writeNormal = function(self2, data, close2, options, callback) {
      if (Buffer2.isBuffer(data)) {
        return writeBuffer(self2, data, close2, callback);
      } else {
        return writeBuffer(self2, Buffer2.from(data, "binary"), close2, callback);
      }
    };
    var _setWriteConcernHash = function(options) {
      const baseOptions = Object.assign(options, options.writeConcern);
      var finalOptions = {};
      if (baseOptions.w != null)
        finalOptions.w = baseOptions.w;
      if (baseOptions.journal === true)
        finalOptions.j = baseOptions.journal;
      if (baseOptions.j === true)
        finalOptions.j = baseOptions.j;
      if (baseOptions.fsync === true)
        finalOptions.fsync = baseOptions.fsync;
      if (baseOptions.wtimeout != null)
        finalOptions.wtimeout = baseOptions.wtimeout;
      return finalOptions;
    };
    var _getWriteConcern = function(self2, options) {
      var finalOptions = { w: 1 };
      options = options || {};
      if (options.writeConcern != null || options.w != null || typeof options.j === "boolean" || typeof options.journal === "boolean" || typeof options.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(options);
      } else if (options.safe != null && typeof options.safe === "object") {
        finalOptions = _setWriteConcernHash(options.safe);
      } else if (typeof options.safe === "boolean") {
        finalOptions = { w: options.safe ? 1 : 0 };
      } else if (self2.options.writeConcern != null || self2.options.w != null || typeof self2.options.j === "boolean" || typeof self2.options.journal === "boolean" || typeof self2.options.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(self2.options);
      } else if (self2.safe && (self2.safe.w != null || typeof self2.safe.j === "boolean" || typeof self2.safe.journal === "boolean" || typeof self2.safe.fsync === "boolean")) {
        finalOptions = _setWriteConcernHash(self2.safe);
      } else if (typeof self2.safe === "boolean") {
        finalOptions = { w: self2.safe ? 1 : 0 };
      }
      if (finalOptions.w < 1 && (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true))
        throw MongoError.create({
          message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true",
          driver: true
        });
      return finalOptions;
    };
    var GridStoreStream = function(gs) {
      Duplex.call(this);
      this.gs = gs;
      this.endCalled = false;
      this.totalBytesToRead = this.gs.length - this.gs.position;
      this.seekPosition = this.gs.position;
    };
    inherits(GridStoreStream, Duplex);
    GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
    GridStoreStream.prototype.pipe = function(destination) {
      var self2 = this;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          if (err)
            return self2.emit("error", err);
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          self2._pipe.apply(self2, [destination]);
        });
      } else {
        self2.totalBytesToRead = self2.gs.length - self2.gs.position;
        self2._pipe.apply(self2, [destination]);
      }
      return destination;
    };
    GridStoreStream.prototype._read = function() {
      var self2 = this;
      var read2 = function() {
        self2.gs.read(length, function(err, buffer) {
          if (err && !self2.endCalled)
            return self2.emit("error", err);
          if (self2.endCalled || buffer == null)
            return self2.push(null);
          if (buffer.length <= self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer.length;
            self2.push(buffer);
          } else if (buffer.length > self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer._index;
            self2.push(buffer.slice(0, buffer._index));
          }
          if (self2.totalBytesToRead <= 0) {
            self2.endCalled = true;
          }
        });
      };
      var length = self2.gs.length < self2.gs.chunkSize ? self2.gs.length - self2.seekPosition : self2.gs.chunkSize;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          if (err)
            return self2.emit("error", err);
          read2();
        });
      } else {
        read2();
      }
    };
    GridStoreStream.prototype.destroy = function() {
      this.pause();
      this.endCalled = true;
      this.gs.close();
      this.emit("end");
    };
    GridStoreStream.prototype.write = function(chunk) {
      var self2 = this;
      if (self2.endCalled)
        return self2.emit(
          "error",
          MongoError.create({ message: "attempting to write to stream after end called", driver: true })
        );
      if (!self2.gs.isOpen) {
        self2.gs.open(function() {
          self2.gs.isOpen = true;
          self2.gs.write(chunk, function() {
            process.nextTick(function() {
              self2.emit("drain");
            });
          });
        });
        return false;
      } else {
        self2.gs.write(chunk, function() {
          self2.emit("drain");
        });
        return true;
      }
    };
    GridStoreStream.prototype.end = function(chunk, encoding, callback) {
      var self2 = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      chunk = args.length ? args.shift() : null;
      encoding = args.length ? args.shift() : null;
      self2.endCalled = true;
      if (chunk) {
        self2.gs.write(chunk, function() {
          self2.gs.close(function() {
            if (typeof callback === "function")
              callback();
            self2.emit("end");
          });
        });
      }
      self2.gs.close(function() {
        if (typeof callback === "function")
          callback();
        self2.emit("end");
      });
    };
    module2.exports = GridStore;
  }
});

// node_modules/mongodb/lib/gridfs-stream/download.js
var require_download = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/download.js"(exports2, module2) {
    "use strict";
    var stream = __require("stream");
    var util = __require("util");
    module2.exports = GridFSBucketReadStream;
    function GridFSBucketReadStream(chunks, files, readPreference, filter, options) {
      this.s = {
        bytesRead: 0,
        chunks,
        cursor: null,
        expected: 0,
        files,
        filter,
        init: false,
        expectedEnd: 0,
        file: null,
        options,
        readPreference
      };
      stream.Readable.call(this);
    }
    util.inherits(GridFSBucketReadStream, stream.Readable);
    GridFSBucketReadStream.prototype._read = function() {
      var _this = this;
      if (this.destroyed) {
        return;
      }
      waitForFile(_this, function() {
        doRead(_this);
      });
    };
    GridFSBucketReadStream.prototype.start = function(start) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    };
    GridFSBucketReadStream.prototype.end = function(end) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    };
    GridFSBucketReadStream.prototype.abort = function(callback) {
      var _this = this;
      this.push(null);
      this.destroyed = true;
      if (this.s.cursor) {
        this.s.cursor.close(function(error) {
          _this.emit("close");
          callback && callback(error);
        });
      } else {
        if (!this.s.init) {
          _this.emit("close");
        }
        callback && callback();
      }
    };
    function throwIfInitialized(self2) {
      if (self2.s.init) {
        throw new Error("You cannot change options after the stream has enteredflowing mode!");
      }
    }
    function doRead(_this) {
      if (_this.destroyed) {
        return;
      }
      _this.s.cursor.next(function(error, doc) {
        if (_this.destroyed) {
          return;
        }
        if (error) {
          return __handleError(_this, error);
        }
        if (!doc) {
          _this.push(null);
          process.nextTick(() => {
            _this.s.cursor.close(function(error2) {
              if (error2) {
                __handleError(_this, error2);
                return;
              }
              _this.emit("close");
            });
          });
          return;
        }
        var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
        var expectedN = _this.s.expected++;
        var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);
        if (doc.n > expectedN) {
          var errmsg = "ChunkIsMissing: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        if (doc.n < expectedN) {
          errmsg = "ExtraChunk: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
        if (buf.length !== expectedLength) {
          if (bytesRemaining <= 0) {
            errmsg = "ExtraChunk: Got unexpected n: " + doc.n;
            return __handleError(_this, new Error(errmsg));
          }
          errmsg = "ChunkIsWrongSize: Got unexpected length: " + buf.length + ", expected: " + expectedLength;
          return __handleError(_this, new Error(errmsg));
        }
        _this.s.bytesRead += buf.length;
        if (buf.length === 0) {
          return _this.push(null);
        }
        var sliceStart = null;
        var sliceEnd = null;
        if (_this.s.bytesToSkip != null) {
          sliceStart = _this.s.bytesToSkip;
          _this.s.bytesToSkip = 0;
        }
        const atEndOfStream = expectedN === _this.s.expectedEnd - 1;
        const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;
        if (atEndOfStream && _this.s.bytesToTrim != null) {
          sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;
        } else if (_this.s.options.end && bytesLeftToRead < doc.data.length()) {
          sliceEnd = bytesLeftToRead;
        }
        if (sliceStart != null || sliceEnd != null) {
          buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
        }
        _this.push(buf);
      });
    }
    function init(self2) {
      var findOneOptions = {};
      if (self2.s.readPreference) {
        findOneOptions.readPreference = self2.s.readPreference;
      }
      if (self2.s.options && self2.s.options.sort) {
        findOneOptions.sort = self2.s.options.sort;
      }
      if (self2.s.options && self2.s.options.skip) {
        findOneOptions.skip = self2.s.options.skip;
      }
      self2.s.files.findOne(self2.s.filter, findOneOptions, function(error, doc) {
        if (error) {
          return __handleError(self2, error);
        }
        if (!doc) {
          var identifier = self2.s.filter._id ? self2.s.filter._id.toString() : self2.s.filter.filename;
          var errmsg = "FileNotFound: file " + identifier + " was not found";
          var err = new Error(errmsg);
          err.code = "ENOENT";
          return __handleError(self2, err);
        }
        if (doc.length <= 0) {
          self2.push(null);
          return;
        }
        if (self2.destroyed) {
          self2.emit("close");
          return;
        }
        try {
          self2.s.bytesToSkip = handleStartOption(self2, doc, self2.s.options);
        } catch (error2) {
          return __handleError(self2, error2);
        }
        var filter = { files_id: doc._id };
        if (self2.s.options && self2.s.options.start != null) {
          var skip = Math.floor(self2.s.options.start / doc.chunkSize);
          if (skip > 0) {
            filter["n"] = { $gte: skip };
          }
        }
        self2.s.cursor = self2.s.chunks.find(filter).sort({ n: 1 });
        if (self2.s.readPreference) {
          self2.s.cursor.setReadPreference(self2.s.readPreference);
        }
        self2.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
        self2.s.file = doc;
        try {
          self2.s.bytesToTrim = handleEndOption(self2, doc, self2.s.cursor, self2.s.options);
        } catch (error2) {
          return __handleError(self2, error2);
        }
        self2.emit("file", doc);
      });
    }
    function waitForFile(_this, callback) {
      if (_this.s.file) {
        return callback();
      }
      if (!_this.s.init) {
        init(_this);
        _this.s.init = true;
      }
      _this.once("file", function() {
        callback();
      });
    }
    function handleStartOption(stream2, doc, options) {
      if (options && options.start != null) {
        if (options.start > doc.length) {
          throw new Error(
            "Stream start (" + options.start + ") must not be more than the length of the file (" + doc.length + ")"
          );
        }
        if (options.start < 0) {
          throw new Error("Stream start (" + options.start + ") must not be negative");
        }
        if (options.end != null && options.end < options.start) {
          throw new Error(
            "Stream start (" + options.start + ") must not be greater than stream end (" + options.end + ")"
          );
        }
        stream2.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
        stream2.s.expected = Math.floor(options.start / doc.chunkSize);
        return options.start - stream2.s.bytesRead;
      }
    }
    function handleEndOption(stream2, doc, cursor, options) {
      if (options && options.end != null) {
        if (options.end > doc.length) {
          throw new Error(
            "Stream end (" + options.end + ") must not be more than the length of the file (" + doc.length + ")"
          );
        }
        if (options.start < 0) {
          throw new Error("Stream end (" + options.end + ") must not be negative");
        }
        var start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
        cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
        stream2.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
        return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
      }
    }
    function __handleError(_this, error) {
      _this.emit("error", error);
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/upload.js
var require_upload = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/upload.js"(exports2, module2) {
    "use strict";
    var MONGODB_ERROR_CODES = require_error_codes().MONGODB_ERROR_CODES;
    var core = require_core();
    var crypto = __require("crypto");
    var stream = __require("stream");
    var util = __require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    var deprecateOptions = require_utils().deprecateOptions;
    var GridFSBucketWriteStream = deprecateOptions(
      {
        name: "GridFSBucketWriteStream",
        deprecatedOptions: ["disableMD5"],
        optionsIndex: 2
      },
      function(bucket, filename, options) {
        options = options || {};
        stream.Writable.call(this, options);
        this.bucket = bucket;
        this.chunks = bucket.s._chunksCollection;
        this.filename = filename;
        this.files = bucket.s._filesCollection;
        this.options = options;
        this.done = false;
        this.id = options.id ? options.id : core.BSON.ObjectId();
        this.chunkSizeBytes = this.options.chunkSizeBytes;
        this.bufToStore = Buffer2.alloc(this.chunkSizeBytes);
        this.length = 0;
        this.md5 = !options.disableMD5 && crypto.createHash("md5");
        this.n = 0;
        this.pos = 0;
        this.state = {
          streamEnd: false,
          outstandingRequests: 0,
          errored: false,
          aborted: false,
          promiseLibrary: this.bucket.s.promiseLibrary
        };
        if (!this.bucket.s.calledOpenUploadStream) {
          this.bucket.s.calledOpenUploadStream = true;
          var _this = this;
          checkIndexes(this, function() {
            _this.bucket.s.checkedIndexes = true;
            _this.bucket.emit("index");
          });
        }
      }
    );
    util.inherits(GridFSBucketWriteStream, stream.Writable);
    GridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {
      var _this = this;
      return waitForIndexes(this, function() {
        return doWrite(_this, chunk, encoding, callback);
      });
    };
    GridFSBucketWriteStream.prototype.abort = function(callback) {
      if (this.state.streamEnd) {
        var error = new Error("Cannot abort a stream that has already completed");
        if (typeof callback === "function") {
          return callback(error);
        }
        return this.state.promiseLibrary.reject(error);
      }
      if (this.state.aborted) {
        error = new Error("Cannot call abort() on a stream twice");
        if (typeof callback === "function") {
          return callback(error);
        }
        return this.state.promiseLibrary.reject(error);
      }
      this.state.aborted = true;
      this.chunks.deleteMany({ files_id: this.id }, function(error2) {
        if (typeof callback === "function")
          callback(error2);
      });
    };
    GridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {
      var _this = this;
      if (typeof chunk === "function") {
        callback = chunk, chunk = null, encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding, encoding = null;
      }
      if (checkAborted(this, callback)) {
        return;
      }
      this.state.streamEnd = true;
      if (callback) {
        this.once("finish", function(result) {
          callback(null, result);
        });
      }
      if (!chunk) {
        waitForIndexes(this, function() {
          writeRemnant(_this);
        });
        return;
      }
      this.write(chunk, encoding, function() {
        writeRemnant(_this);
      });
    };
    function __handleError(_this, error, callback) {
      if (_this.state.errored) {
        return;
      }
      _this.state.errored = true;
      if (callback) {
        return callback(error);
      }
      _this.emit("error", error);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: core.BSON.ObjectId(),
        files_id: filesId,
        n,
        data
      };
    }
    function checkChunksIndex(_this, callback) {
      _this.chunks.listIndexes().toArray(function(error, indexes) {
        if (error) {
          if (error.code === MONGODB_ERROR_CODES.NamespaceNotFound) {
            var index = { files_id: 1, n: 1 };
            _this.chunks.createIndex(index, { background: false, unique: true }, function(error2) {
              if (error2) {
                return callback(error2);
              }
              callback();
            });
            return;
          }
          return callback(error);
        }
        var hasChunksIndex = false;
        indexes.forEach(function(index2) {
          if (index2.key) {
            var keys = Object.keys(index2.key);
            if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
              hasChunksIndex = true;
            }
          }
        });
        if (hasChunksIndex) {
          callback();
        } else {
          index = { files_id: 1, n: 1 };
          var indexOptions = getWriteOptions(_this);
          indexOptions.background = false;
          indexOptions.unique = true;
          _this.chunks.createIndex(index, indexOptions, function(error2) {
            if (error2) {
              return callback(error2);
            }
            callback();
          });
        }
      });
    }
    function checkDone(_this, callback) {
      if (_this.done)
        return true;
      if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {
        _this.done = true;
        var filesDoc = createFilesDoc(
          _this.id,
          _this.length,
          _this.chunkSizeBytes,
          _this.md5 && _this.md5.digest("hex"),
          _this.filename,
          _this.options.contentType,
          _this.options.aliases,
          _this.options.metadata
        );
        if (checkAborted(_this, callback)) {
          return false;
        }
        _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error) {
          if (error) {
            return __handleError(_this, error, callback);
          }
          _this.emit("finish", filesDoc);
          _this.emit("close");
        });
        return true;
      }
      return false;
    }
    function checkIndexes(_this, callback) {
      _this.files.findOne({}, { _id: 1 }, function(error, doc) {
        if (error) {
          return callback(error);
        }
        if (doc) {
          return callback();
        }
        _this.files.listIndexes().toArray(function(error2, indexes) {
          if (error2) {
            if (error2.code === MONGODB_ERROR_CODES.NamespaceNotFound) {
              var index = { filename: 1, uploadDate: 1 };
              _this.files.createIndex(index, { background: false }, function(error3) {
                if (error3) {
                  return callback(error3);
                }
                checkChunksIndex(_this, callback);
              });
              return;
            }
            return callback(error2);
          }
          var hasFileIndex = false;
          indexes.forEach(function(index2) {
            var keys = Object.keys(index2.key);
            if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
              hasFileIndex = true;
            }
          });
          if (hasFileIndex) {
            checkChunksIndex(_this, callback);
          } else {
            index = { filename: 1, uploadDate: 1 };
            var indexOptions = getWriteOptions(_this);
            indexOptions.background = false;
            _this.files.createIndex(index, indexOptions, function(error3) {
              if (error3) {
                return callback(error3);
              }
              checkChunksIndex(_this, callback);
            });
          }
        });
      });
    }
    function createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {
      var ret = {
        _id,
        length,
        chunkSize,
        uploadDate: /* @__PURE__ */ new Date(),
        filename
      };
      if (md5) {
        ret.md5 = md5;
      }
      if (contentType) {
        ret.contentType = contentType;
      }
      if (aliases) {
        ret.aliases = aliases;
      }
      if (metadata) {
        ret.metadata = metadata;
      }
      return ret;
    }
    function doWrite(_this, chunk, encoding, callback) {
      if (checkAborted(_this, callback)) {
        return false;
      }
      var inputBuf = Buffer2.isBuffer(chunk) ? chunk : Buffer2.from(chunk, encoding);
      _this.length += inputBuf.length;
      if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
        inputBuf.copy(_this.bufToStore, _this.pos);
        _this.pos += inputBuf.length;
        callback && callback();
        return true;
      }
      var inputBufRemaining = inputBuf.length;
      var spaceRemaining = _this.chunkSizeBytes - _this.pos;
      var numToCopy = Math.min(spaceRemaining, inputBuf.length);
      var outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        var inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);
        _this.pos += numToCopy;
        spaceRemaining -= numToCopy;
        if (spaceRemaining === 0) {
          if (_this.md5) {
            _this.md5.update(_this.bufToStore);
          }
          var doc = createChunkDoc(_this.id, _this.n, Buffer2.from(_this.bufToStore));
          ++_this.state.outstandingRequests;
          ++outstandingRequests;
          if (checkAborted(_this, callback)) {
            return false;
          }
          _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {
            if (error) {
              return __handleError(_this, error);
            }
            --_this.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              _this.emit("drain", doc);
              callback && callback();
              checkDone(_this);
            }
          });
          spaceRemaining = _this.chunkSizeBytes;
          _this.pos = 0;
          ++_this.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
      return false;
    }
    function getWriteOptions(_this) {
      var obj = {};
      if (_this.options.writeConcern) {
        obj.w = _this.options.writeConcern.w;
        obj.wtimeout = _this.options.writeConcern.wtimeout;
        obj.j = _this.options.writeConcern.j;
      }
      return obj;
    }
    function waitForIndexes(_this, callback) {
      if (_this.bucket.s.checkedIndexes) {
        return callback(false);
      }
      _this.bucket.once("index", function() {
        callback(true);
      });
      return true;
    }
    function writeRemnant(_this, callback) {
      if (_this.pos === 0) {
        return checkDone(_this, callback);
      }
      ++_this.state.outstandingRequests;
      var remnant = Buffer2.alloc(_this.pos);
      _this.bufToStore.copy(remnant, 0, 0, _this.pos);
      if (_this.md5) {
        _this.md5.update(remnant);
      }
      var doc = createChunkDoc(_this.id, _this.n, remnant);
      if (checkAborted(_this, callback)) {
        return false;
      }
      _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {
        if (error) {
          return __handleError(_this, error);
        }
        --_this.state.outstandingRequests;
        checkDone(_this);
      });
    }
    function checkAborted(_this, callback) {
      if (_this.state.aborted) {
        if (typeof callback === "function") {
          callback(new Error("this stream has been aborted"));
        }
        return true;
      }
      return false;
    }
    module2.exports = GridFSBucketWriteStream;
  }
});

// node_modules/mongodb/lib/gridfs-stream/index.js
var require_gridfs_stream = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/index.js"(exports2, module2) {
    "use strict";
    var Emitter = __require("events").EventEmitter;
    var GridFSBucketReadStream = require_download();
    var GridFSBucketWriteStream = require_upload();
    var shallowClone = require_utils().shallowClone;
    var toError = require_utils().toError;
    var util = __require("util");
    var executeLegacyOperation = require_utils().executeLegacyOperation;
    var deprecateOptions = require_utils().deprecateOptions;
    var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
      bucketName: "fs",
      chunkSizeBytes: 255 * 1024
    };
    module2.exports = GridFSBucket;
    function GridFSBucket(db, options) {
      Emitter.apply(this);
      this.setMaxListeners(0);
      if (options && typeof options === "object") {
        options = shallowClone(options);
        var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
        for (var i = 0; i < keys.length; ++i) {
          if (!options[keys[i]]) {
            options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
          }
        }
      } else {
        options = DEFAULT_GRIDFS_BUCKET_OPTIONS;
      }
      this.s = {
        db,
        options,
        _chunksCollection: db.collection(options.bucketName + ".chunks"),
        _filesCollection: db.collection(options.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false,
        promiseLibrary: db.s.promiseLibrary || Promise
      };
    }
    util.inherits(GridFSBucket, Emitter);
    GridFSBucket.prototype.openUploadStream = deprecateOptions(
      {
        name: "GridFSBucket.openUploadStream",
        deprecatedOptions: ["disableMD5"],
        optionsIndex: 1
      },
      function(filename, options) {
        if (options) {
          options = shallowClone(options);
        } else {
          options = {};
        }
        if (!options.chunkSizeBytes) {
          options.chunkSizeBytes = this.s.options.chunkSizeBytes;
        }
        return new GridFSBucketWriteStream(this, filename, options);
      }
    );
    GridFSBucket.prototype.openUploadStreamWithId = deprecateOptions(
      {
        name: "GridFSBucket.openUploadStreamWithId",
        deprecatedOptions: ["disableMD5"],
        optionsIndex: 2
      },
      function(id, filename, options) {
        if (options) {
          options = shallowClone(options);
        } else {
          options = {};
        }
        if (!options.chunkSizeBytes) {
          options.chunkSizeBytes = this.s.options.chunkSizeBytes;
        }
        options.id = id;
        return new GridFSBucketWriteStream(this, filename, options);
      }
    );
    GridFSBucket.prototype.openDownloadStream = function(id, options) {
      var filter = { _id: id };
      options = {
        start: options && options.start,
        end: options && options.end
      };
      return new GridFSBucketReadStream(
        this.s._chunksCollection,
        this.s._filesCollection,
        this.s.options.readPreference,
        filter,
        options
      );
    };
    GridFSBucket.prototype.delete = function(id, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {
        skipSessions: true
      });
    };
    function _delete(_this, id, callback) {
      _this.s._filesCollection.deleteOne({ _id: id }, function(error, res) {
        if (error) {
          return callback(error);
        }
        _this.s._chunksCollection.deleteMany({ files_id: id }, function(error2) {
          if (error2) {
            return callback(error2);
          }
          if (!res.result.n) {
            var errmsg = "FileNotFound: no file with id " + id + " found";
            return callback(new Error(errmsg));
          }
          callback();
        });
      });
    }
    GridFSBucket.prototype.find = function(filter, options) {
      filter = filter || {};
      options = options || {};
      var cursor = this.s._filesCollection.find(filter);
      if (options.batchSize != null) {
        cursor.batchSize(options.batchSize);
      }
      if (options.limit != null) {
        cursor.limit(options.limit);
      }
      if (options.maxTimeMS != null) {
        cursor.maxTimeMS(options.maxTimeMS);
      }
      if (options.noCursorTimeout != null) {
        cursor.addCursorFlag("noCursorTimeout", options.noCursorTimeout);
      }
      if (options.skip != null) {
        cursor.skip(options.skip);
      }
      if (options.sort != null) {
        cursor.sort(options.sort);
      }
      return cursor;
    };
    GridFSBucket.prototype.openDownloadStreamByName = function(filename, options) {
      var sort = { uploadDate: -1 };
      var skip = null;
      if (options && options.revision != null) {
        if (options.revision >= 0) {
          sort = { uploadDate: 1 };
          skip = options.revision;
        } else {
          skip = -options.revision - 1;
        }
      }
      var filter = { filename };
      options = {
        sort,
        skip,
        start: options && options.start,
        end: options && options.end
      };
      return new GridFSBucketReadStream(
        this.s._chunksCollection,
        this.s._filesCollection,
        this.s.options.readPreference,
        filter,
        options
      );
    };
    GridFSBucket.prototype.rename = function(id, filename, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {
        skipSessions: true
      });
    };
    function _rename(_this, id, filename, callback) {
      var filter = { _id: id };
      var update = { $set: { filename } };
      _this.s._filesCollection.updateOne(filter, update, function(error, res) {
        if (error) {
          return callback(error);
        }
        if (!res.result.n) {
          return callback(toError("File with id " + id + " not found"));
        }
        callback();
      });
    }
    GridFSBucket.prototype.drop = function(callback) {
      return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {
        skipSessions: true
      });
    };
    GridFSBucket.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    function _drop(_this, callback) {
      _this.s._filesCollection.drop(function(error) {
        if (error) {
          return callback(error);
        }
        _this.s._chunksCollection.drop(function(error2) {
          if (error2) {
            return callback(error2);
          }
          return callback();
        });
      });
    }
  }
});

// node_modules/mongodb/index.js
var require_mongodb = __commonJS({
  "node_modules/mongodb/index.js"(exports2, module2) {
    "use strict";
    var core = require_core();
    var Instrumentation = require_apm2();
    var connect = require_mongo_client().connect;
    connect.MongoError = core.MongoError;
    connect.MongoNetworkError = core.MongoNetworkError;
    connect.MongoTimeoutError = core.MongoTimeoutError;
    connect.MongoServerSelectionError = core.MongoServerSelectionError;
    connect.MongoParseError = core.MongoParseError;
    connect.MongoWriteConcernError = core.MongoWriteConcernError;
    connect.MongoBulkWriteError = require_common2().BulkWriteError;
    connect.BulkWriteError = connect.MongoBulkWriteError;
    connect.ServerApiVersion = core.ServerApiVersion;
    connect.Admin = require_admin();
    connect.MongoClient = require_mongo_client();
    connect.Db = require_db();
    connect.Collection = require_collection();
    connect.Server = require_server3();
    connect.ReplSet = require_replset2();
    connect.Mongos = require_mongos2();
    connect.ReadPreference = core.ReadPreference;
    connect.GridStore = require_grid_store();
    connect.Chunk = require_chunk();
    connect.Logger = core.Logger;
    connect.AggregationCursor = require_aggregation_cursor();
    connect.CommandCursor = require_command_cursor();
    connect.Cursor = require_cursor2();
    connect.GridFSBucket = require_gridfs_stream();
    connect.CoreServer = core.Server;
    connect.CoreConnection = core.Connection;
    connect.Binary = core.BSON.Binary;
    connect.Code = core.BSON.Code;
    connect.Map = core.BSON.Map;
    connect.DBRef = core.BSON.DBRef;
    connect.Double = core.BSON.Double;
    connect.Int32 = core.BSON.Int32;
    connect.Long = core.BSON.Long;
    connect.MinKey = core.BSON.MinKey;
    connect.MaxKey = core.BSON.MaxKey;
    connect.ObjectID = core.BSON.ObjectID;
    connect.ObjectId = core.BSON.ObjectID;
    connect.Symbol = core.BSON.Symbol;
    connect.Timestamp = core.BSON.Timestamp;
    connect.BSONRegExp = core.BSON.BSONRegExp;
    connect.Decimal128 = core.BSON.Decimal128;
    connect.connect = connect;
    connect.instrument = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      const instrumentation = new Instrumentation();
      instrumentation.instrument(connect.MongoClient, callback);
      return instrumentation;
    };
    module2.exports = connect;
  }
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/mongodb/lib/encrypter.js"(exports2, module2) {
    "use strict";
    var MongoClient = require_mongo_client();
    var BSON2 = require_utils4().retrieveBSON();
    var MongoError = require_error().MongoError;
    var mongodbClientEncryption = void 0;
    try {
      mongodbClientEncryption = __require("mongodb-client-encryption");
    } catch (err) {
      throw new MongoError(
        "Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project"
      );
    }
    if (mongodbClientEncryption === void 0 || typeof mongodbClientEncryption.extension !== "function") {
      throw new MongoError(
        "loaded version of `mongodb-client-encryption` does not have property `extension`. Please make sure you are loading the correct version of `mongodb-client-encryption`"
      );
    }
    var AutoEncrypter = mongodbClientEncryption.extension(require_mongodb()).AutoEncrypter;
    var kInternalClient = Symbol("internalClient");
    var Encrypter = class _Encrypter {
      /**
       * @param {MongoClient} client
       * @param {{autoEncryption: import('./mongo_client').AutoEncryptionOptions, bson: object}} options
       */
      constructor(client, options) {
        this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
          options.autoEncryption.keyVaultClient = client;
        } else if (options.autoEncryption.keyVaultClient == null) {
          options.autoEncryption.keyVaultClient = this.getInternalClient(client);
        }
        if (this.bypassAutoEncryption) {
          options.autoEncryption.metadataClient = void 0;
        } else if (options.maxPoolSize === 0) {
          options.autoEncryption.metadataClient = client;
        } else {
          options.autoEncryption.metadataClient = this.getInternalClient(client);
        }
        options.autoEncryption.bson = _Encrypter.makeBSON(options);
        this.autoEncrypter = new AutoEncrypter(client, options.autoEncryption);
      }
      getInternalClient(client) {
        if (!this[kInternalClient]) {
          const clonedOptions = {};
          for (const key of Object.keys(client.s.options)) {
            if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].indexOf(key) !== -1)
              continue;
            clonedOptions[key] = client.s.options[key];
          }
          clonedOptions.minPoolSize = 0;
          const allEvents = [
            // APM
            "commandStarted",
            "commandSucceeded",
            "commandFailed",
            // SDAM
            "serverOpening",
            "serverClosed",
            "serverDescriptionChanged",
            "serverHeartbeatStarted",
            "serverHeartbeatSucceeded",
            "serverHeartbeatFailed",
            "topologyOpening",
            "topologyClosed",
            "topologyDescriptionChanged",
            // Legacy
            "joined",
            "left",
            "ping",
            "ha",
            // CMAP
            "connectionPoolCreated",
            "connectionPoolClosed",
            "connectionCreated",
            "connectionReady",
            "connectionClosed",
            "connectionCheckOutStarted",
            "connectionCheckOutFailed",
            "connectionCheckedOut",
            "connectionCheckedIn",
            "connectionPoolCleared"
          ];
          this[kInternalClient] = new MongoClient(client.s.url, clonedOptions);
          for (const eventName of allEvents) {
            for (const listener of client.listeners(eventName)) {
              this[kInternalClient].on(eventName, listener);
            }
          }
          client.on("newListener", (eventName, listener) => {
            this[kInternalClient].on(eventName, listener);
          });
          this.needsConnecting = true;
        }
        return this[kInternalClient];
      }
      connectInternalClient(callback) {
        if (this.needsConnecting) {
          this.needsConnecting = false;
          return this[kInternalClient].connect(callback);
        }
        return callback();
      }
      close(client, force, callback) {
        this.autoEncrypter.teardown((e) => {
          if (this[kInternalClient] && client !== this[kInternalClient]) {
            return this[kInternalClient].close(force, callback);
          }
          callback(e);
        });
      }
      static makeBSON(options) {
        return (options || {}).bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]);
      }
    };
    module2.exports = { Encrypter };
  }
});

// node_modules/mongodb/lib/operations/connect.js
var require_connect2 = __commonJS({
  "node_modules/mongodb/lib/operations/connect.js"(exports2, module2) {
    "use strict";
    var deprecate = __require("util").deprecate;
    var Logger = require_core().Logger;
    var MongoCredentials = require_core().MongoCredentials;
    var MongoError = require_core().MongoError;
    var Mongos = require_mongos2();
    var NativeTopology = require_native_topology();
    var parse = require_core().parseConnectionString;
    var ReadConcern = require_read_concern();
    var ReadPreference = require_core().ReadPreference;
    var ReplSet = require_replset2();
    var Server = require_server3();
    var ServerSessionPool = require_core().Sessions.ServerSessionPool;
    var emitDeprecationWarning = require_utils().emitDeprecationWarning;
    var emitWarningOnce = require_utils().emitWarningOnce;
    var fs2 = __require("fs");
    var WriteConcern = require_write_concern();
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var client;
    function loadClient() {
      if (!client) {
        client = require_mongo_client();
      }
      return client;
    }
    var legacyParse = deprecate(
      require_url_parser(),
      "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect."
    );
    var AUTH_MECHANISM_INTERNAL_MAP = {
      DEFAULT: "default",
      PLAIN: "plain",
      GSSAPI: "gssapi",
      "MONGODB-CR": "mongocr",
      "MONGODB-X509": "x509",
      "MONGODB-AWS": "mongodb-aws",
      "SCRAM-SHA-1": "scram-sha-1",
      "SCRAM-SHA-256": "scram-sha-256"
    };
    var monitoringEvents = [
      "timeout",
      "close",
      "serverOpening",
      "serverDescriptionChanged",
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "serverClosed",
      "topologyOpening",
      "topologyClosed",
      "topologyDescriptionChanged",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ];
    var VALID_AUTH_MECHANISMS = /* @__PURE__ */ new Set([
      "DEFAULT",
      "PLAIN",
      "GSSAPI",
      "MONGODB-CR",
      "MONGODB-X509",
      "MONGODB-AWS",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    var validOptionNames = [
      "poolSize",
      "ssl",
      "sslValidate",
      "sslCA",
      "sslCert",
      "sslKey",
      "sslPass",
      "sslCRL",
      "autoReconnect",
      "noDelay",
      "keepAlive",
      "keepAliveInitialDelay",
      "connectTimeoutMS",
      "family",
      "socketTimeoutMS",
      "reconnectTries",
      "reconnectInterval",
      "ha",
      "haInterval",
      "replicaSet",
      "secondaryAcceptableLatencyMS",
      "acceptableLatencyMS",
      "connectWithNoPrimary",
      "authSource",
      "w",
      "wtimeout",
      "j",
      "writeConcern",
      "forceServerObjectId",
      "serializeFunctions",
      "ignoreUndefined",
      "raw",
      "bufferMaxEntries",
      "readPreference",
      "pkFactory",
      "promiseLibrary",
      "readConcern",
      "maxStalenessSeconds",
      "loggerLevel",
      "logger",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs",
      "bsonRegExp",
      "domainsEnabled",
      "checkServerIdentity",
      "validateOptions",
      "appname",
      "auth",
      "user",
      "password",
      "authMechanism",
      "compression",
      "fsync",
      "readPreferenceTags",
      "numberOfRetries",
      "auto_reconnect",
      "minSize",
      "monitorCommands",
      "serverApi",
      "retryWrites",
      "retryReads",
      "useNewUrlParser",
      "useUnifiedTopology",
      "serverSelectionTimeoutMS",
      "useRecoveryToken",
      "autoEncryption",
      "driverInfo",
      "tls",
      "tlsInsecure",
      "tlsinsecure",
      "tlsAllowInvalidCertificates",
      "tlsAllowInvalidHostnames",
      "tlsCAFile",
      "tlsCertificateFile",
      "tlsCertificateKeyFile",
      "tlsCertificateKeyFilePassword",
      "minHeartbeatFrequencyMS",
      "heartbeatFrequencyMS",
      "directConnection",
      "appName",
      // CMAP options
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ];
    var ignoreOptionNames = ["native_parser"];
    var legacyOptionNames = ["server", "replset", "replSet", "mongos", "db"];
    function validOptions(options) {
      const _validOptions = validOptionNames.concat(legacyOptionNames);
      for (const name in options) {
        if (ignoreOptionNames.indexOf(name) !== -1) {
          continue;
        }
        if (_validOptions.indexOf(name) === -1) {
          if (options.validateOptions) {
            return new MongoError(`option ${name} is not supported`);
          } else {
            emitWarningOnce(`the options [${name}] is not supported`);
          }
        }
        if (legacyOptionNames.indexOf(name) !== -1) {
          emitWarningOnce(
            `the server/replset/mongos/db options are deprecated, all their options are supported at the top level of the options object [${validOptionNames}]`
          );
        }
      }
    }
    var LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {
      obj[name.toLowerCase()] = name;
      return obj;
    }, {});
    function addListeners(mongoClient, topology) {
      topology.on("authenticated", createListener(mongoClient, "authenticated"));
      topology.on("error", createListener(mongoClient, "error"));
      topology.on("timeout", createListener(mongoClient, "timeout"));
      topology.on("close", createListener(mongoClient, "close"));
      topology.on("parseError", createListener(mongoClient, "parseError"));
      topology.once("open", createListener(mongoClient, "open"));
      topology.once("fullsetup", createListener(mongoClient, "fullsetup"));
      topology.once("all", createListener(mongoClient, "all"));
      topology.on("reconnect", createListener(mongoClient, "reconnect"));
    }
    function assignTopology(client2, topology) {
      client2.topology = topology;
      if (!(topology instanceof NativeTopology)) {
        topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);
      }
    }
    function clearAllEvents(topology) {
      monitoringEvents.forEach((event) => topology.removeAllListeners(event));
    }
    function collectEvents(mongoClient, topology) {
      let MongoClient = loadClient();
      const collectedEvents = [];
      if (mongoClient instanceof MongoClient) {
        monitoringEvents.forEach((event) => {
          topology.on(event, (object1, object2) => {
            if (event === "open") {
              collectedEvents.push({ event, object1: mongoClient });
            } else {
              collectedEvents.push({ event, object1, object2 });
            }
          });
        });
      }
      return collectedEvents;
    }
    function resolveTLSOptions(options) {
      if (options.tls == null) {
        return;
      }
      ["sslCA", "sslKey", "sslCert"].forEach((optionName) => {
        if (options[optionName]) {
          options[optionName] = fs2.readFileSync(options[optionName]);
        }
      });
    }
    function connect(mongoClient, url, options, callback) {
      options = Object.assign({}, options);
      if (callback == null) {
        throw new Error("no callback function provided");
      }
      let didRequestAuthentication = false;
      const logger = Logger("MongoClient", options);
      if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {
        return connectWithUrl(mongoClient, url, options, connectCallback);
      }
      const useNewUrlParser = options.useNewUrlParser !== false;
      const parseFn = useNewUrlParser ? parse : legacyParse;
      const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;
      parseFn(url, options, (err, _object) => {
        if (err)
          return callback(err);
        const object2 = transform(_object);
        const _finalOptions = createUnifiedOptions(object2, options);
        if (_finalOptions.socketTimeoutMS == null)
          _finalOptions.socketTimeoutMS = 0;
        if (_finalOptions.connectTimeoutMS == null)
          _finalOptions.connectTimeoutMS = 1e4;
        if (_finalOptions.retryWrites == null)
          _finalOptions.retryWrites = true;
        if (_finalOptions.useRecoveryToken == null)
          _finalOptions.useRecoveryToken = true;
        if (_finalOptions.readPreference == null)
          _finalOptions.readPreference = "primary";
        if (_finalOptions.db_options && _finalOptions.db_options.auth) {
          delete _finalOptions.db_options.auth;
        }
        resolveTLSOptions(_finalOptions);
        mongoClient.s.options = _finalOptions;
        mongoClient.s.readPreference = ReadPreference.fromOptions(_finalOptions);
        mongoClient.s.writeConcern = WriteConcern.fromOptions(_finalOptions);
        if (object2.servers.length === 0) {
          return callback(new Error("connection string must contain at least one seed host"));
        }
        if (_finalOptions.auth && !_finalOptions.credentials) {
          try {
            didRequestAuthentication = true;
            _finalOptions.credentials = generateCredentials(
              mongoClient,
              _finalOptions.auth.user,
              _finalOptions.auth.password,
              _finalOptions
            );
          } catch (err2) {
            return callback(err2);
          }
        }
        if (_finalOptions.useUnifiedTopology) {
          return createTopology(mongoClient, "unified", _finalOptions, connectCallback);
        }
        emitWarningOnce(
          "Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor."
        );
        if (_finalOptions.replicaSet || _finalOptions.rs_name) {
          return createTopology(mongoClient, "replicaset", _finalOptions, connectCallback);
        } else if (object2.servers.length > 1) {
          return createTopology(mongoClient, "mongos", _finalOptions, connectCallback);
        } else {
          return createServer(mongoClient, _finalOptions, connectCallback);
        }
      });
      function connectCallback(err, topology) {
        const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;
        if (err && err.message === "no mongos proxies found in seed list") {
          if (logger.isWarn()) {
            logger.warn(warningMessage);
          }
          return callback(new MongoError(warningMessage));
        }
        if (didRequestAuthentication) {
          mongoClient.emit("authenticated", null, true);
        }
        callback(err, topology);
      }
    }
    function connectWithUrl(mongoClient, url, options, connectCallback) {
      assignTopology(mongoClient, url);
      addListeners(mongoClient, url);
      relayEvents(mongoClient, url);
      let finalOptions = Object.assign({}, options);
      if (typeof options.readPreference === "string" || typeof options.read_preference === "string") {
        finalOptions.readPreference = new ReadPreference(
          options.readPreference || options.read_preference
        );
      }
      const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;
      if (isDoingAuth && !finalOptions.credentials) {
        try {
          finalOptions.credentials = generateCredentials(
            mongoClient,
            finalOptions.user,
            finalOptions.password,
            finalOptions
          );
        } catch (err) {
          return connectCallback(err, url);
        }
      }
      return url.connect(finalOptions, connectCallback);
    }
    function createListener(mongoClient, event) {
      const eventSet = /* @__PURE__ */ new Set(["all", "fullsetup", "open", "reconnect"]);
      return (v1, v2) => {
        if (eventSet.has(event)) {
          return mongoClient.emit(event, mongoClient);
        }
        mongoClient.emit(event, v1, v2);
      };
    }
    function createServer(mongoClient, options, callback) {
      options.promiseLibrary = mongoClient.s.promiseLibrary;
      const servers = translateOptions(options);
      const server = servers[0];
      const collectedEvents = collectEvents(mongoClient, server);
      server.connect(options, (err, topology) => {
        if (err) {
          server.close(true);
          return callback(err);
        }
        clearAllEvents(server);
        relayEvents(mongoClient, server);
        addListeners(mongoClient, server);
        const ismaster = topology.lastIsMaster();
        assignTopology(mongoClient, topology);
        if (ismaster && ismaster.msg === "isdbgrid") {
          topology.close();
          return createTopology(mongoClient, "mongos", options, callback);
        }
        replayEvents(mongoClient, collectedEvents);
        callback(err, topology);
      });
    }
    var DEPRECATED_UNIFIED_EVENTS = /* @__PURE__ */ new Set([
      "reconnect",
      "reconnectFailed",
      "attemptReconnect",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ]);
    function registerDeprecatedEventNotifiers(client2) {
      client2.on("newListener", (eventName) => {
        if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {
          emitDeprecationWarning(
            `The \`${eventName}\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`,
            "DeprecationWarning"
          );
        }
      });
    }
    function createTopology(mongoClient, topologyType, options, callback) {
      options.promiseLibrary = mongoClient.s.promiseLibrary;
      const translationOptions = {};
      if (topologyType === "unified")
        translationOptions.createServers = false;
      const servers = translateOptions(options, translationOptions);
      if (options.autoEncryption != null) {
        const Encrypter = require_encrypter().Encrypter;
        options.encrypter = new Encrypter(mongoClient, options);
        options.autoEncrypter = options.encrypter.autoEncrypter;
      }
      let topology;
      if (topologyType === "mongos") {
        topology = new Mongos(servers, options);
      } else if (topologyType === "replicaset") {
        topology = new ReplSet(servers, options);
      } else if (topologyType === "unified") {
        topology = new NativeTopology(options.servers, options);
        registerDeprecatedEventNotifiers(mongoClient);
      }
      addListeners(mongoClient, topology);
      relayEvents(mongoClient, topology);
      assignTopology(mongoClient, topology);
      if (options.autoEncrypter) {
        options.autoEncrypter.init((err) => {
          if (err) {
            callback(err);
            return;
          }
          topology.connect(options, (err2) => {
            if (err2) {
              topology.close(true);
              callback(err2);
              return;
            }
            options.encrypter.connectInternalClient((error) => {
              if (error)
                return callback(error);
              callback(void 0, topology);
            });
          });
        });
        return;
      }
      topology.connect(options, (err) => {
        if (err) {
          topology.close(true);
          return callback(err);
        }
        callback(void 0, topology);
        return;
      });
    }
    function createUnifiedOptions(finalOptions, options) {
      const childOptions = [
        "mongos",
        "server",
        "db",
        "replset",
        "db_options",
        "server_options",
        "rs_options",
        "mongos_options"
      ];
      const noMerge = ["readconcern", "compression", "autoencryption"];
      const skip = ["w", "wtimeout", "j", "journal", "fsync", "writeconcern"];
      for (const name in options) {
        if (skip.indexOf(name.toLowerCase()) !== -1) {
          continue;
        } else if (noMerge.indexOf(name.toLowerCase()) !== -1) {
          finalOptions[name] = options[name];
        } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {
          finalOptions = mergeOptions(finalOptions, options[name], false);
        } else {
          if (options[name] && typeof options[name] === "object" && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {
            finalOptions = mergeOptions(finalOptions, options[name], true);
          } else {
            finalOptions[name] = options[name];
          }
        }
      }
      const optionsWriteConcern = WriteConcern.fromOptions(options);
      if (optionsWriteConcern) {
        finalOptions.writeConcern = Object.assign({}, finalOptions.writeConcern, optionsWriteConcern);
      }
      return finalOptions;
    }
    function generateCredentials(client2, username, password, options) {
      options = Object.assign({}, options);
      const source = options.authSource || options.authdb || options.dbName;
      const authMechanismRaw = options.authMechanism || "DEFAULT";
      const authMechanism = authMechanismRaw.toUpperCase();
      const mechanismProperties = options.authMechanismProperties;
      if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {
        throw MongoError.create({
          message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,
          driver: true
        });
      }
      return new MongoCredentials({
        mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],
        mechanismProperties,
        source,
        username,
        password
      });
    }
    function legacyTransformUrlOptions(object2) {
      return mergeOptions(createUnifiedOptions({}, object2), object2, false);
    }
    function mergeOptions(target, source, flatten) {
      for (const name in source) {
        if (source[name] && typeof source[name] === "object" && flatten) {
          target = mergeOptions(target, source[name], flatten);
        } else {
          target[name] = source[name];
        }
      }
      return target;
    }
    function relayEvents(mongoClient, topology) {
      const serverOrCommandEvents = [
        // APM
        "commandStarted",
        "commandSucceeded",
        "commandFailed",
        // SDAM
        "serverOpening",
        "serverClosed",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        // Legacy
        "joined",
        "left",
        "ping",
        "ha"
      ].concat(CMAP_EVENT_NAMES);
      serverOrCommandEvents.forEach((event) => {
        topology.on(event, (object1, object2) => {
          mongoClient.emit(event, object1, object2);
        });
      });
    }
    function replayEvents(mongoClient, events) {
      for (let i = 0; i < events.length; i++) {
        mongoClient.emit(events[i].event, events[i].object1, events[i].object2);
      }
    }
    function transformUrlOptions(_object) {
      let object2 = Object.assign({ servers: _object.hosts }, _object.options);
      for (let name in object2) {
        const camelCaseName = LEGACY_OPTIONS_MAP[name];
        if (camelCaseName) {
          object2[camelCaseName] = object2[name];
        }
      }
      const hasUsername = _object.auth && _object.auth.username;
      const hasAuthMechanism = _object.options && _object.options.authMechanism;
      if (hasUsername || hasAuthMechanism) {
        object2.auth = Object.assign({}, _object.auth);
        if (object2.auth.db) {
          object2.authSource = object2.authSource || object2.auth.db;
        }
        if (object2.auth.username) {
          object2.auth.user = object2.auth.username;
        }
      }
      if (_object.defaultDatabase) {
        object2.dbName = _object.defaultDatabase;
      }
      if (object2.maxPoolSize) {
        object2.poolSize = object2.maxPoolSize;
      }
      if (object2.readConcernLevel) {
        object2.readConcern = new ReadConcern(object2.readConcernLevel);
      }
      if (object2.wTimeoutMS) {
        object2.wtimeout = object2.wTimeoutMS;
        object2.wTimeoutMS = void 0;
      }
      if (_object.srvHost) {
        object2.srvHost = _object.srvHost;
      }
      const wcKeys = ["w", "wtimeout", "j", "journal", "fsync"];
      for (const key of wcKeys) {
        if (object2[key] !== void 0) {
          if (object2.writeConcern === void 0)
            object2.writeConcern = {};
          object2.writeConcern[key] = object2[key];
          object2[key] = void 0;
        }
      }
      return object2;
    }
    function translateOptions(options, translationOptions) {
      translationOptions = Object.assign({}, { createServers: true }, translationOptions);
      if (typeof options.readPreference === "string" || typeof options.read_preference === "string") {
        options.readPreference = new ReadPreference(options.readPreference || options.read_preference);
      }
      if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {
        options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;
      }
      if (options.maxStalenessSeconds) {
        options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;
      }
      if (options.socketTimeoutMS == null)
        options.socketTimeoutMS = 0;
      if (options.connectTimeoutMS == null)
        options.connectTimeoutMS = 1e4;
      if (!translationOptions.createServers) {
        return;
      }
      return options.servers.map((serverObj) => {
        return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);
      });
    }
    module2.exports = { validOptions, connect };
  }
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS({
  "node_modules/mongodb/lib/mongo_client.js"(exports2, module2) {
    "use strict";
    var ChangeStream = require_change_stream();
    var Db2 = require_db();
    var EventEmitter = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    var MongoError = require_core().MongoError;
    var ValidServerApiVersions = require_core().ValidServerApiVersions;
    var deprecate = __require("util").deprecate;
    var WriteConcern = require_write_concern();
    var MongoDBNamespace = require_utils().MongoDBNamespace;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils().maybePromise;
    var NativeTopology = require_native_topology();
    var connect = require_connect2().connect;
    var validOptions = require_connect2().validOptions;
    function MongoClient(url, options) {
      options = options || {};
      if (!(this instanceof MongoClient))
        return new MongoClient(url, options);
      EventEmitter.call(this);
      if (options.autoEncryption)
        require_encrypter();
      if (options.serverApi) {
        const serverApiToValidate = typeof options.serverApi === "string" ? { version: options.serverApi } : options.serverApi;
        const versionToValidate = serverApiToValidate && serverApiToValidate.version;
        if (!versionToValidate) {
          throw new MongoError(
            `Invalid \`serverApi\` property; must specify a version from the following enum: ["${ValidServerApiVersions.join(
              '", "'
            )}"]`
          );
        }
        if (!ValidServerApiVersions.some((v) => v === versionToValidate)) {
          throw new MongoError(
            `Invalid server API version=${versionToValidate}; must be in the following enum: ["${ValidServerApiVersions.join(
              '", "'
            )}"]`
          );
        }
        options.serverApi = serverApiToValidate;
      }
      this.s = {
        url,
        options,
        promiseLibrary: options && options.promiseLibrary || Promise,
        dbCache: /* @__PURE__ */ new Map(),
        sessions: /* @__PURE__ */ new Set(),
        writeConcern: WriteConcern.fromOptions(options),
        readPreference: ReadPreference.fromOptions(options) || ReadPreference.primary,
        namespace: new MongoDBNamespace("admin")
      };
    }
    inherits(MongoClient, EventEmitter);
    Object.defineProperty(MongoClient.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(MongoClient.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        return this.s.readPreference;
      }
    });
    MongoClient.prototype.connect = function(callback) {
      if (typeof callback === "string") {
        throw new TypeError("`connect` only accepts a callback");
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const err = validOptions(client.s.options);
        if (err)
          return cb(err);
        connect(client, client.s.url, client.s.options, (err2) => {
          if (err2)
            return cb(err2);
          cb(null, client);
        });
      });
    };
    MongoClient.prototype.logout = deprecate(function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      if (typeof callback === "function")
        callback(null, true);
    }, "Multiple authentication is prohibited on a connected client, please only authenticate once per MongoClient");
    MongoClient.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const completeClose = (err) => {
          client.emit("close", client);
          if (!(client.topology instanceof NativeTopology)) {
            for (const item of client.s.dbCache) {
              item[1].emit("close", client);
            }
          }
          client.removeAllListeners("close");
          cb(err);
        };
        if (client.topology == null) {
          completeClose();
          return;
        }
        client.topology.close(force, (err) => {
          const encrypter = client.topology.s.options.encrypter;
          if (encrypter) {
            return encrypter.close(client, force, (err2) => {
              completeClose(err || err2);
            });
          }
          completeClose(err);
        });
      });
    };
    MongoClient.prototype.db = function(dbName, options) {
      options = options || {};
      if (!dbName) {
        dbName = this.s.options.dbName;
      }
      const finalOptions = Object.assign({}, this.s.options, options);
      if (this.s.dbCache.has(dbName) && finalOptions.returnNonCachedInstance !== true) {
        return this.s.dbCache.get(dbName);
      }
      finalOptions.promiseLibrary = this.s.promiseLibrary;
      if (!this.topology) {
        throw new MongoError("MongoClient must be connected before calling MongoClient.prototype.db");
      }
      const db = new Db2(dbName, this.topology, finalOptions);
      this.s.dbCache.set(dbName, db);
      return db;
    };
    MongoClient.prototype.isConnected = deprecate(function(options) {
      options = options || {};
      if (!this.topology)
        return false;
      return this.topology.isConnected(options);
    }, "isConnected is deprecated and will be removed in the next major version");
    MongoClient.connect = function(url, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() : null;
      options = options || {};
      const mongoClient = new MongoClient(url, options);
      return mongoClient.connect(callback);
    };
    MongoClient.prototype.startSession = function(options) {
      options = Object.assign({ explicit: true }, options);
      if (!this.topology) {
        throw new MongoError("Must connect to a server before calling this method");
      }
      return this.topology.startSession(options, this.s.options);
    };
    MongoClient.prototype.withSession = function(options, operation) {
      if (typeof options === "function")
        operation = options, options = void 0;
      const session = this.startSession(options);
      let cleanupHandler = (err, result, opts) => {
        cleanupHandler = () => {
          throw new ReferenceError("cleanupHandler was called too many times");
        };
        opts = Object.assign({ throw: true }, opts);
        session.endSession();
        if (err) {
          if (opts.throw)
            throw err;
          return Promise.reject(err);
        }
      };
      try {
        const result = operation(session);
        return Promise.resolve(result).then((result2) => cleanupHandler(null, result2)).catch((err) => cleanupHandler(err, null, { throw: true }));
      } catch (err) {
        return cleanupHandler(err, null, { throw: false });
      }
    };
    MongoClient.prototype.watch = function(pipeline, options) {
      pipeline = pipeline || [];
      options = options || {};
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new ChangeStream(this, pipeline, options);
    };
    MongoClient.prototype.getLogger = function() {
      return this.s.options.logger;
    };
    module2.exports = MongoClient;
  }
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS({
  "node_modules/mongodb/lib/change_stream.js"(exports2, module2) {
    "use strict";
    var Denque = require_denque();
    var EventEmitter = __require("events");
    var isResumableError = require_error2().isResumableError;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var relayEvents = require_utils3().relayEvents;
    var maxWireVersion = require_utils3().maxWireVersion;
    var maybePromise = require_utils().maybePromise;
    var now = require_utils().now;
    var calculateDurationInMs = require_utils().calculateDurationInMs;
    var AggregateOperation = require_aggregate();
    var kResumeQueue = Symbol("resumeQueue");
    var CHANGE_STREAM_OPTIONS = ["resumeAfter", "startAfter", "startAtOperationTime", "fullDocument"];
    var CURSOR_OPTIONS = ["batchSize", "maxAwaitTimeMS", "collation", "readPreference"].concat(
      CHANGE_STREAM_OPTIONS
    );
    var CHANGE_DOMAIN_TYPES = {
      COLLECTION: Symbol("Collection"),
      DATABASE: Symbol("Database"),
      CLUSTER: Symbol("Cluster")
    };
    var ChangeStream = class extends EventEmitter {
      constructor(parent, pipeline, options) {
        super();
        const Collection = require_collection();
        const Db2 = require_db();
        const MongoClient = require_mongo_client();
        this.pipeline = pipeline || [];
        this.options = options || {};
        this.parent = parent;
        this.namespace = parent.s.namespace;
        if (parent instanceof Collection) {
          this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
          this.topology = parent.s.db.serverConfig;
        } else if (parent instanceof Db2) {
          this.type = CHANGE_DOMAIN_TYPES.DATABASE;
          this.topology = parent.serverConfig;
        } else if (parent instanceof MongoClient) {
          this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
          this.topology = parent.topology;
        } else {
          throw new TypeError(
            "parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient"
          );
        }
        this.promiseLibrary = parent.s.promiseLibrary;
        if (!this.options.readPreference && parent.s.readPreference) {
          this.options.readPreference = parent.s.readPreference;
        }
        this[kResumeQueue] = new Denque();
        this.cursor = createChangeStreamCursor(this, options);
        this.closed = false;
        this.on("newListener", (eventName) => {
          if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
            this.cursor.on("data", (change) => processNewChange(this, change));
          }
        });
        this.on("removeListener", (eventName) => {
          if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
            this.cursor.removeAllListeners("data");
          }
        });
      }
      /**
       * @property {ResumeToken} resumeToken
       * The cached resume token that will be used to resume
       * after the most recently returned change.
       */
      get resumeToken() {
        return this.cursor.resumeToken;
      }
      /**
       * Check if there is any document still available in the Change Stream
       * @function ChangeStream.prototype.hasNext
       * @param {ChangeStream~resultCallback} [callback] The result callback.
       * @throws {MongoError}
       * @returns {Promise|void} returns Promise if no callback passed
       */
      hasNext(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.hasNext(cb);
          });
        });
      }
      /**
       * Get the next available document from the Change Stream, returns null if no more documents are available.
       * @function ChangeStream.prototype.next
       * @param {ChangeStream~resultCallback} [callback] The result callback.
       * @throws {MongoError}
       * @returns {Promise|void} returns Promise if no callback passed
       */
      next(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.next((error, change) => {
              if (error) {
                this[kResumeQueue].push(() => this.next(cb));
                processError(this, error, cb);
                return;
              }
              processNewChange(this, change, cb);
            });
          });
        });
      }
      /**
       * Is the change stream closed
       * @method ChangeStream.prototype.isClosed
       * @return {boolean}
       */
      isClosed() {
        return this.closed || this.cursor && this.cursor.isClosed();
      }
      /**
       * Close the Change Stream
       * @method ChangeStream.prototype.close
       * @param {ChangeStream~resultCallback} [callback] The result callback.
       * @return {Promise} returns Promise if no callback passed
       */
      close(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          if (this.closed)
            return cb();
          this.closed = true;
          if (!this.cursor)
            return cb();
          const cursor = this.cursor;
          return cursor.close((err) => {
            ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
            this.cursor = void 0;
            return cb(err);
          });
        });
      }
      /**
       * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
       * @method
       * @param {Writable} destination The destination for writing data
       * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}
       * @return {null}
       */
      pipe(destination, options) {
        if (!this.pipeDestinations) {
          this.pipeDestinations = [];
        }
        this.pipeDestinations.push(destination);
        return this.cursor.pipe(destination, options);
      }
      /**
       * This method will remove the hooks set up for a previous pipe() call.
       * @param {Writable} [destination] The destination for writing data
       * @return {null}
       */
      unpipe(destination) {
        if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {
          this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
        }
        return this.cursor.unpipe(destination);
      }
      /**
       * Return a modified Readable stream including a possible transform method.
       * @method
       * @param {object} [options] Optional settings.
       * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.
       * @return {Cursor}
       */
      stream(options) {
        this.streamOptions = options;
        return this.cursor.stream(options);
      }
      /**
       * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
       * @return {null}
       */
      pause() {
        return this.cursor.pause();
      }
      /**
       * This method will cause the readable stream to resume emitting data events.
       * @return {null}
       */
      resume() {
        return this.cursor.resume();
      }
    };
    var ChangeStreamCursor = class extends Cursor {
      constructor(topology, operation, options) {
        super(topology, operation, options);
        options = options || {};
        this._resumeToken = null;
        this.startAtOperationTime = options.startAtOperationTime;
        if (options.startAfter) {
          this.resumeToken = options.startAfter;
        } else if (options.resumeAfter) {
          this.resumeToken = options.resumeAfter;
        }
      }
      set resumeToken(token) {
        this._resumeToken = token;
        this.emit("resumeTokenChanged", token);
      }
      get resumeToken() {
        return this._resumeToken;
      }
      get resumeOptions() {
        const result = {};
        for (const optionName of CURSOR_OPTIONS) {
          if (this.options[optionName])
            result[optionName] = this.options[optionName];
        }
        if (this.resumeToken || this.startAtOperationTime) {
          ["resumeAfter", "startAfter", "startAtOperationTime"].forEach((key) => delete result[key]);
          if (this.resumeToken) {
            const resumeKey = this.options.startAfter && !this.hasReceived ? "startAfter" : "resumeAfter";
            result[resumeKey] = this.resumeToken;
          } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {
            result.startAtOperationTime = this.startAtOperationTime;
          }
        }
        return result;
      }
      cacheResumeToken(resumeToken) {
        if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {
          this.resumeToken = this.cursorState.postBatchResumeToken;
        } else {
          this.resumeToken = resumeToken;
        }
        this.hasReceived = true;
      }
      _processBatch(batchName, response) {
        const cursor = response.cursor;
        if (cursor.postBatchResumeToken) {
          this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;
          if (cursor[batchName].length === 0) {
            this.resumeToken = cursor.postBatchResumeToken;
          }
        }
      }
      _initializeCursor(callback) {
        super._initializeCursor((err, result) => {
          if (err || result == null) {
            callback(err, result);
            return;
          }
          const response = result.documents[0];
          if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {
            this.startAtOperationTime = response.operationTime;
          }
          this._processBatch("firstBatch", response);
          this.emit("init", result);
          this.emit("response");
          callback(err, result);
        });
      }
      _getMore(callback) {
        super._getMore((err, response) => {
          if (err) {
            callback(err);
            return;
          }
          this._processBatch("nextBatch", response);
          this.emit("more", response);
          this.emit("response");
          callback(err, response);
        });
      }
    };
    function createChangeStreamCursor(self2, options) {
      const changeStreamStageOptions = { fullDocument: options.fullDocument || "default" };
      applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);
      if (self2.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline = [{ $changeStream: changeStreamStageOptions }].concat(self2.pipeline);
      const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);
      const changeStreamCursor = new ChangeStreamCursor(
        self2.topology,
        new AggregateOperation(self2.parent, pipeline, options),
        cursorOptions
      );
      relayEvents(changeStreamCursor, self2, ["resumeTokenChanged", "end", "close"]);
      if (self2.listenerCount("change") > 0) {
        changeStreamCursor.on("data", function(change) {
          processNewChange(self2, change);
        });
      }
      changeStreamCursor.on("error", function(error) {
        processError(self2, error);
      });
      if (self2.pipeDestinations) {
        const cursorStream = changeStreamCursor.stream(self2.streamOptions);
        for (let pipeDestination of self2.pipeDestinations) {
          cursorStream.pipe(pipeDestination);
        }
      }
      return changeStreamCursor;
    }
    function applyKnownOptions(target, source, optionNames) {
      optionNames.forEach((name) => {
        if (source[name]) {
          target[name] = source[name];
        }
      });
      return target;
    }
    var SELECTION_TIMEOUT = 3e4;
    function waitForTopologyConnected(topology, options, callback) {
      setTimeout(() => {
        if (options && options.start == null) {
          options.start = now();
        }
        const start = options.start || now();
        const timeout = options.timeout || SELECTION_TIMEOUT;
        const readPreference = options.readPreference;
        if (topology.isConnected({ readPreference })) {
          return callback();
        }
        if (calculateDurationInMs(start) > timeout) {
          return callback(new MongoError("Timed out waiting for connection"));
        }
        waitForTopologyConnected(topology, options, callback);
      }, 500);
    }
    function processNewChange(changeStream, change, callback) {
      const cursor = changeStream.cursor;
      if (change == null) {
        changeStream.closed = true;
      }
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      if (change && !change._id) {
        const noResumeTokenError = new Error(
          "A change stream document has been received that lacks a resume token (_id)."
        );
        if (!callback)
          return changeStream.emit("error", noResumeTokenError);
        return callback(noResumeTokenError);
      }
      cursor.cacheResumeToken(change._id);
      changeStream.options.startAtOperationTime = void 0;
      if (!callback)
        return changeStream.emit("change", change);
      return callback(void 0, change);
    }
    function processError(changeStream, error, callback) {
      const topology = changeStream.topology;
      const cursor = changeStream.cursor;
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      function resumeWithCursor(newCursor) {
        changeStream.cursor = newCursor;
        processResumeQueue(changeStream);
      }
      function unresumableError(err) {
        if (!callback) {
          changeStream.emit("error", err);
          changeStream.emit("close");
        }
        processResumeQueue(changeStream, err);
        changeStream.closed = true;
      }
      if (cursor && isResumableError(error, maxWireVersion(cursor.server))) {
        changeStream.cursor = void 0;
        ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
        cursor.close();
        waitForTopologyConnected(topology, { readPreference: cursor.options.readPreference }, (err) => {
          if (err)
            return unresumableError(err);
          const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);
          if (!callback)
            return resumeWithCursor(newCursor);
          newCursor.hasNext((err2) => {
            if (err2)
              return unresumableError(err2);
            resumeWithCursor(newCursor);
          });
        });
        return;
      }
      if (!callback)
        return changeStream.emit("error", error);
      return callback(error);
    }
    function getCursor(changeStream, callback) {
      if (changeStream.isClosed()) {
        callback(new MongoError("ChangeStream is closed."));
        return;
      }
      if (changeStream.cursor) {
        callback(void 0, changeStream.cursor);
        return;
      }
      changeStream[kResumeQueue].push(callback);
    }
    function processResumeQueue(changeStream, err) {
      while (changeStream[kResumeQueue].length) {
        const request = changeStream[kResumeQueue].pop();
        if (changeStream.isClosed() && !err) {
          request(new MongoError("Change Stream is not open."));
          return;
        }
        request(err, changeStream.cursor);
      }
    }
    module2.exports = ChangeStream;
  }
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/bulk_write.js"(exports2, module2) {
    "use strict";
    var applyRetryableWrites = require_utils().applyRetryableWrites;
    var applyWriteConcern = require_utils().applyWriteConcern;
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = class extends OperationBase {
      constructor(collection, operations, options) {
        super(options);
        this.collection = collection;
        this.operations = operations;
      }
      execute(callback) {
        const coll = this.collection;
        const operations = this.operations;
        let options = this.options;
        if (coll.s.options.ignoreUndefined) {
          options = Object.assign({}, options);
          options.ignoreUndefined = coll.s.options.ignoreUndefined;
        }
        const bulk = options.ordered === true || options.ordered == null ? coll.initializeOrderedBulkOp(options) : coll.initializeUnorderedBulkOp(options);
        let collation = false;
        try {
          for (let i = 0; i < operations.length; i++) {
            const key = Object.keys(operations[i])[0];
            if (operations[i][key].collation) {
              collation = true;
            }
            bulk.raw(operations[i]);
          }
        } catch (err) {
          return callback(err, null);
        }
        let finalOptions = Object.assign({}, options);
        finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
        finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);
        const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
        const capabilities = coll.s.topology.capabilities();
        if (collation && capabilities && !capabilities.commandsTakeCollation) {
          return callback(new MongoError("server/primary/mongos does not support collation"));
        }
        bulk.execute(writeCon, finalOptions, (err, r) => {
          if (!r && err) {
            return callback(err, null);
          }
          callback(null, r);
        });
      }
    };
    module2.exports = BulkWriteOperation;
  }
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS({
  "node_modules/mongodb/lib/operations/count_documents.js"(exports2, module2) {
    "use strict";
    var AggregateOperation = require_aggregate();
    var CountDocumentsOperation = class extends AggregateOperation {
      constructor(collection, query, options) {
        const pipeline = [{ $match: query }];
        if (typeof options.skip === "number") {
          pipeline.push({ $skip: options.skip });
        }
        if (typeof options.limit === "number") {
          pipeline.push({ $limit: options.limit });
        }
        pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
        super(collection, pipeline, options);
      }
      execute(server, callback) {
        super.execute(server, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          const response = result.result;
          if (response.cursor == null || response.cursor.firstBatch == null) {
            callback(null, 0);
            return;
          }
          const docs = response.cursor.firstBatch;
          callback(null, docs.length ? docs[0].n : 0);
        });
      }
    };
    module2.exports = CountDocumentsOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_many.js
var require_delete_many = __commonJS({
  "node_modules/mongodb/lib/operations/delete_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteManyOperation = class extends OperationBase {
      constructor(collection, filter, options) {
        super(options);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options = this.options;
        options.single = false;
        removeDocuments(coll, filter, options, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteManyOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_one.js
var require_delete_one = __commonJS({
  "node_modules/mongodb/lib/operations/delete_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteOneOperation = class extends OperationBase {
      constructor(collection, filter, options) {
        super(options);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options = this.options;
        options.single = true;
        removeDocuments(coll, filter, options, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteOneOperation;
  }
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS({
  "node_modules/mongodb/lib/operations/distinct.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var decorateWithCollation = require_utils().decorateWithCollation;
    var decorateWithReadConcern = require_utils().decorateWithReadConcern;
    var maxWireVersion = require_utils3().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var DistinctOperation = class extends CommandOperationV2 {
      /**
       * Construct a Distinct operation.
       *
       * @param {Collection} a Collection instance.
       * @param {string} key Field of the document to find distinct values for.
       * @param {object} query The query for filtering the set of documents to which we apply the distinct filter.
       * @param {object} [options] Optional settings. See Collection.prototype.distinct for a list of options.
       */
      constructor(collection, key, query, options) {
        super(collection, options);
        this.collection = collection;
        this.key = key;
        this.query = query;
      }
      /**
       * Execute the operation.
       *
       * @param {Collection~resultCallback} [callback] The command result callback
       */
      execute(server, callback) {
        const coll = this.collection;
        const key = this.key;
        const query = this.query;
        const options = this.options;
        const cmd = {
          distinct: coll.collectionName,
          key,
          query
        };
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        decorateWithReadConcern(cmd, coll, options);
        try {
          decorateWithCollation(cmd, coll, options);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain && maxWireVersion(server) < 4) {
          callback(new MongoError(`server does not support explain on distinct`));
          return;
        }
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.options.full || this.explain ? result : result.values);
        });
      }
    };
    defineAspects(DistinctOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = DistinctOperation;
  }
});

// node_modules/mongodb/lib/operations/drop_index.js
var require_drop_index = __commonJS({
  "node_modules/mongodb/lib/operations/drop_index.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils().applyWriteConcern;
    var handleCallback = require_utils().handleCallback;
    var DropIndexOperation = class extends CommandOperation {
      constructor(collection, indexName, options) {
        super(collection.s.db, options, collection);
        this.collection = collection;
        this.indexName = indexName;
      }
      _buildCommand() {
        const collection = this.collection;
        const indexName = this.indexName;
        const options = this.options;
        let cmd = { dropIndexes: collection.collectionName, index: indexName };
        cmd = applyWriteConcern(cmd, { db: collection.s.db, collection }, options);
        return cmd;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (typeof callback !== "function")
            return;
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(DropIndexOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/drop_indexes.js
var require_drop_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/drop_indexes.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DropIndexOperation = require_drop_index();
    var handleCallback = require_utils().handleCallback;
    var DropIndexesOperation = class extends DropIndexOperation {
      constructor(collection, options) {
        super(collection, "*", options);
      }
      execute(callback) {
        super.execute((err) => {
          if (err)
            return handleCallback(callback, err, false);
          handleCallback(callback, null, true);
        });
      }
    };
    defineAspects(DropIndexesOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS({
  "node_modules/mongodb/lib/operations/estimated_document_count.js"(exports2, module2) {
    "use strict";
    var MONGODB_ERROR_CODES = require_error_codes().MONGODB_ERROR_CODES;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var maxWireVersion = require_utils3().maxWireVersion;
    var CountDocumentsOperation = require_count_documents();
    var EstimatedDocumentCountOperation = class extends CommandOperationV2 {
      constructor(collection, options) {
        super(collection, options);
        this.collection = collection;
        this.collectionName = collection.s.namespace.collection;
      }
      execute(server, callback) {
        if (maxWireVersion(server) < 12) {
          return this.executeLegacy(server, callback);
        }
        if (this.options.query) {
          const op = new CountDocumentsOperation(this.collection, this.options.query, this.options);
          return op.execute(server, callback);
        }
        const pipeline = [{ $collStats: { count: {} } }, { $group: { _id: 1, n: { $sum: "$count" } } }];
        const cmd = { aggregate: this.collectionName, pipeline, cursor: {} };
        if (typeof this.options.maxTimeMS === "number") {
          cmd.maxTimeMS = this.options.maxTimeMS;
        }
        super.executeCommand(server, cmd, (err, response) => {
          if (err && err.code !== MONGODB_ERROR_CODES.NamespaceNotFound) {
            callback(err);
            return;
          }
          callback(
            void 0,
            response && response.cursor && response.cursor.firstBatch && response.cursor.firstBatch[0].n || 0
          );
        });
      }
      executeLegacy(server, callback) {
        const cmd = { count: this.collectionName };
        const options = this.options;
        if (options.query) {
          cmd.query = options.query;
        }
        if (options.hint) {
          cmd.hint = options.hint;
        }
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        if (typeof options.skip === "number") {
          cmd.skip = options.skip;
        }
        if (typeof options.limit === "number") {
          cmd.limit = options.limit;
        }
        super.executeCommand(server, cmd, (err, response) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, response.n);
        });
      }
    };
    defineAspects(EstimatedDocumentCountOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = EstimatedDocumentCountOperation;
  }
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS({
  "node_modules/mongodb/lib/operations/find.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils3().maxWireVersion;
    var MongoError = require_error().MongoError;
    var FindOperation = class extends OperationBase {
      constructor(collection, ns, command, options) {
        super(options);
        this.ns = ns;
        this.cmd = command;
        this.readPreference = ReadPreference.resolve(collection, this.options);
      }
      execute(server, callback) {
        this.server = server;
        this.readPreference = ReadPreference.resolve(this, this.options);
        if (typeof this.cmd.allowDiskUse !== "undefined" && maxWireVersion(server) < 4) {
          callback(new MongoError("The `allowDiskUse` option is not supported on MongoDB < 3.2"));
          return;
        }
        if (this.explain) {
          this.options.explain = this.explain.verbosity;
        }
        const cursorState = this.cursorState || {};
        server.query(this.ns.toString(), this.cmd, cursorState, this.options, callback);
      }
    };
    defineAspects(FindOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = FindOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one.js
var require_find_one = __commonJS({
  "node_modules/mongodb/lib/operations/find_one.js"(exports2, module2) {
    "use strict";
    var handleCallback = require_utils().handleCallback;
    var OperationBase = require_operation().OperationBase;
    var toError = require_utils().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var FindOneOperation = class extends OperationBase {
      constructor(collection, query, options) {
        super(options);
        this.collection = collection;
        this.query = query;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const options = this.options;
        try {
          const cursor = coll.find(query, options).limit(-1).batchSize(1);
          cursor.next((err, item) => {
            if (err != null)
              return handleCallback(callback, toError(err), null);
            handleCallback(callback, null, item);
          });
        } catch (e) {
          callback(e);
        }
      }
    };
    defineAspects(FindOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindOneOperation;
  }
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS({
  "node_modules/mongodb/lib/operations/find_and_modify.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyRetryableWrites = require_utils().applyRetryableWrites;
    var applyWriteConcern = require_utils().applyWriteConcern;
    var decorateWithCollation = require_utils().decorateWithCollation;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils().formattedOrderClause;
    var handleCallback = require_utils().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils3().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils().decorateWithExplain;
    var FindAndModifyOperation = class extends OperationBase {
      constructor(collection, query, sort, doc, options) {
        super(options);
        this.collection = collection;
        this.query = query;
        this.sort = sort;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const sort = formattedOrderClause(this.sort);
        const doc = this.doc;
        let options = this.options;
        let queryObject = {
          findAndModify: coll.collectionName,
          query
        };
        if (sort) {
          queryObject.sort = sort;
        }
        queryObject.new = options.new ? true : false;
        queryObject.remove = options.remove ? true : false;
        queryObject.upsert = options.upsert ? true : false;
        const projection = options.projection || options.fields;
        if (projection) {
          queryObject.fields = projection;
        }
        if (options.arrayFilters) {
          queryObject.arrayFilters = options.arrayFilters;
        }
        if (doc && !options.remove) {
          queryObject.update = doc;
        }
        if (options.maxTimeMS)
          queryObject.maxTimeMS = options.maxTimeMS;
        options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;
        options.checkKeys = false;
        options = applyRetryableWrites(options, coll.s.db);
        options = applyWriteConcern(options, { db: coll.s.db, collection: coll }, options);
        if (options.writeConcern) {
          queryObject.writeConcern = options.writeConcern;
        }
        if (options.bypassDocumentValidation === true) {
          queryObject.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        options.readPreference = ReadPreference.primary;
        try {
          decorateWithCollation(queryObject, coll, options);
        } catch (err) {
          return callback(err, null);
        }
        if (options.hint) {
          const unacknowledgedWrite = options.writeConcern && options.writeConcern.w === 0;
          if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {
            callback(
              new MongoError("The current topology does not support a hint on findAndModify commands")
            );
            return;
          }
          queryObject.hint = options.hint;
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 4) {
            callback(new MongoError(`server does not support explain on findAndModify`));
            return;
          }
          queryObject = decorateWithExplain(queryObject, this.explain);
        }
        executeCommand(coll.s.db, queryObject, options, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          return handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(FindAndModifyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindAndModifyOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_delete.js
var require_find_one_and_delete = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_delete.js"(exports2, module2) {
    "use strict";
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, options) {
        const finalOptions = Object.assign({}, options);
        finalOptions.fields = options.projection;
        finalOptions.remove = true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        super(collection, filter, finalOptions.sort, null, finalOptions);
      }
    };
    module2.exports = FindOneAndDeleteOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_replace.js
var require_find_one_and_replace = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_replace.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils().hasAtomicOperators;
    var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, replacement, options) {
        if ("returnDocument" in options && "returnOriginal" in options) {
          throw new MongoError(
            "findOneAndReplace option returnOriginal is deprecated in favor of returnDocument and cannot be combined"
          );
        }
        const finalOptions = Object.assign({}, options);
        finalOptions.fields = options.projection;
        finalOptions.update = true;
        finalOptions.new = options.returnDocument === "after" || options.returnOriginal === false;
        finalOptions.upsert = options.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (replacement == null || typeof replacement !== "object") {
          throw new TypeError("Replacement parameter must be an object");
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        super(collection, filter, finalOptions.sort, replacement, finalOptions);
      }
    };
    module2.exports = FindOneAndReplaceOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_update.js
var require_find_one_and_update = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_update.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils().hasAtomicOperators;
    var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, update, options) {
        if ("returnDocument" in options && "returnOriginal" in options) {
          throw new MongoError(
            "findOneAndUpdate option returnOriginal is deprecated in favor of returnDocument and cannot be combined"
          );
        }
        const finalOptions = Object.assign({}, options);
        finalOptions.fields = options.projection;
        finalOptions.update = true;
        finalOptions.new = options.returnDocument === "after" || options.returnOriginal === false;
        finalOptions.upsert = options.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (update == null || typeof update !== "object") {
          throw new TypeError("Update parameter must be an object");
        }
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        super(collection, filter, finalOptions.sort, update, finalOptions);
      }
    };
    module2.exports = FindOneAndUpdateOperation;
  }
});

// node_modules/mongodb/lib/operations/geo_haystack_search.js
var require_geo_haystack_search = __commonJS({
  "node_modules/mongodb/lib/operations/geo_haystack_search.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var OperationBase = require_operation().OperationBase;
    var decorateCommand = require_utils().decorateCommand;
    var decorateWithReadConcern = require_utils().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils().toError;
    var GeoHaystackSearchOperation = class extends OperationBase {
      /**
       * Construct a GeoHaystackSearch operation.
       *
       * @param {Collection} a Collection instance.
       * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.
       * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.
       * @param {object} [options] Optional settings. See Collection.prototype.geoHaystackSearch for a list of options.
       */
      constructor(collection, x, y, options) {
        super(options);
        this.collection = collection;
        this.x = x;
        this.y = y;
      }
      /**
       * Execute the operation.
       *
       * @param {Collection~resultCallback} [callback] The command result callback
       */
      execute(callback) {
        const coll = this.collection;
        const x = this.x;
        const y = this.y;
        let options = this.options;
        let commandObject = {
          geoSearch: coll.collectionName,
          near: [x, y]
        };
        commandObject = decorateCommand(commandObject, options, ["readPreference", "session"]);
        options = Object.assign({}, options);
        options.readPreference = ReadPreference.resolve(coll, options);
        decorateWithReadConcern(commandObject, coll, options);
        executeCommand(coll.s.db, commandObject, options, (err, res) => {
          if (err)
            return handleCallback(callback, err);
          if (res.err || res.errmsg)
            handleCallback(callback, toError(res));
          handleCallback(callback, null, res);
        });
      }
    };
    defineAspects(GeoHaystackSearchOperation, Aspect.READ_OPERATION);
    module2.exports = GeoHaystackSearchOperation;
  }
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/indexes.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexesOperation = class extends OperationBase {
      constructor(collection, options) {
        super(options);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        let options = this.options;
        options = Object.assign({}, { full: true }, options);
        indexInformation(coll.s.db, coll.collectionName, options, callback);
      }
    };
    module2.exports = IndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/index_exists.js
var require_index_exists = __commonJS({
  "node_modules/mongodb/lib/operations/index_exists.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var IndexExistsOperation = class extends OperationBase {
      constructor(collection, indexes, options) {
        super(options);
        this.collection = collection;
        this.indexes = indexes;
      }
      execute(callback) {
        const coll = this.collection;
        const indexes = this.indexes;
        const options = this.options;
        indexInformationDb(coll.s.db, coll.collectionName, options, (err, indexInformation) => {
          if (err != null)
            return handleCallback(callback, err, null);
          if (!Array.isArray(indexes))
            return handleCallback(callback, null, indexInformation[indexes] != null);
          for (let i = 0; i < indexes.length; i++) {
            if (indexInformation[indexes[i]] == null) {
              return handleCallback(callback, null, false);
            }
          }
          return handleCallback(callback, null, true);
        });
      }
    };
    module2.exports = IndexExistsOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_many.js
var require_insert_many = __commonJS({
  "node_modules/mongodb/lib/operations/insert_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = require_bulk_write();
    var MongoError = require_core().MongoError;
    var prepareDocs = require_common_functions().prepareDocs;
    var InsertManyOperation = class extends OperationBase {
      constructor(collection, docs, options) {
        super(options);
        this.collection = collection;
        this.docs = docs;
      }
      execute(callback) {
        const coll = this.collection;
        let docs = this.docs;
        const options = this.options;
        if (!Array.isArray(docs)) {
          return callback(
            MongoError.create({ message: "docs parameter must be an array of documents", driver: true })
          );
        }
        options["serializeFunctions"] = options["serializeFunctions"] || coll.s.serializeFunctions;
        docs = prepareDocs(coll, docs, options);
        const operations = docs.map((document) => ({ insertOne: { document } }));
        const bulkWriteOperation = new BulkWriteOperation(coll, operations, options);
        bulkWriteOperation.execute((err, result) => {
          if (err)
            return callback(err, null);
          callback(null, mapInsertManyResults(docs, result));
        });
      }
    };
    function mapInsertManyResults(docs, r) {
      const finalResult = {
        result: { ok: 1, n: r.insertedCount },
        ops: docs,
        insertedCount: r.insertedCount,
        insertedIds: r.insertedIds
      };
      if (r.getLastOp()) {
        finalResult.result.opTime = r.getLastOp();
      }
      return finalResult;
    }
    module2.exports = InsertManyOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_one.js
var require_insert_one = __commonJS({
  "node_modules/mongodb/lib/operations/insert_one.js"(exports2, module2) {
    "use strict";
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var insertDocuments = require_common_functions().insertDocuments;
    var InsertOneOperation = class extends OperationBase {
      constructor(collection, doc, options) {
        super(options);
        this.collection = collection;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const doc = this.doc;
        const options = this.options;
        if (Array.isArray(doc)) {
          return callback(
            MongoError.create({ message: "doc parameter must be an object", driver: true })
          );
        }
        insertDocuments(coll, [doc], options, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          r.insertedCount = r.result.n;
          r.insertedId = doc._id;
          if (callback)
            callback(null, r);
        });
      }
    };
    module2.exports = InsertOneOperation;
  }
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS({
  "node_modules/mongodb/lib/operations/options_operation.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils().handleCallback;
    var MongoError = require_core().MongoError;
    var OptionsOperation = class extends OperationBase {
      constructor(collection, options) {
        super(options);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        const opts = this.options;
        coll.s.db.listCollections({ name: coll.collectionName }, opts).toArray((err, collections) => {
          if (err)
            return handleCallback(callback, err);
          if (collections.length === 0) {
            return handleCallback(
              callback,
              MongoError.create({ message: `collection ${coll.namespace} not found`, driver: true })
            );
          }
          handleCallback(callback, err, collections[0].options || null);
        });
      }
    };
    module2.exports = OptionsOperation;
  }
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS({
  "node_modules/mongodb/lib/operations/is_capped.js"(exports2, module2) {
    "use strict";
    var OptionsOperation = require_options_operation();
    var handleCallback = require_utils().handleCallback;
    var IsCappedOperation = class extends OptionsOperation {
      constructor(collection, options) {
        super(collection, options);
      }
      execute(callback) {
        super.execute((err, document) => {
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, !!(document && document.capped));
        });
      }
    };
    module2.exports = IsCappedOperation;
  }
});

// node_modules/mongodb/lib/operations/list_indexes.js
var require_list_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/list_indexes.js"(exports2, module2) {
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils3().maxWireVersion;
    var LIST_INDEXES_WIRE_VERSION = 3;
    var ListIndexesOperation = class extends CommandOperationV2 {
      constructor(collection, options) {
        super(collection, options, { fullResponse: true });
        this.collectionNamespace = collection.s.namespace;
      }
      execute(server, callback) {
        const serverWireVersion = maxWireVersion(server);
        if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {
          const systemIndexesNS = this.collectionNamespace.withCollection("system.indexes").toString();
          const collectionNS = this.collectionNamespace.toString();
          server.query(systemIndexesNS, { query: { ns: collectionNS } }, {}, this.options, callback);
          return;
        }
        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
        super.executeCommand(
          server,
          { listIndexes: this.collectionNamespace.collection, cursor },
          callback
        );
      }
    };
    defineAspects(ListIndexesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/map_reduce.js
var require_map_reduce = __commonJS({
  "node_modules/mongodb/lib/operations/map_reduce.js"(exports2, module2) {
    "use strict";
    var applyWriteConcern = require_utils().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var decorateWithCollation = require_utils().decorateWithCollation;
    var decorateWithReadConcern = require_utils().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils().handleCallback;
    var isObject = require_utils().isObject;
    var loadDb = require_dynamic_loaders().loadDb;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils().decorateWithExplain;
    var maxWireVersion = require_utils3().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var exclusionList = [
      "explain",
      "readPreference",
      "session",
      "bypassDocumentValidation",
      "w",
      "wtimeout",
      "j",
      "writeConcern"
    ];
    var MapReduceOperation = class extends OperationBase {
      /**
       * Constructs a MapReduce operation.
       *
       * @param {Collection} a Collection instance.
       * @param {(function|string)} map The mapping function.
       * @param {(function|string)} reduce The reduce function.
       * @param {object} [options] Optional settings. See Collection.prototype.mapReduce for a list of options.
       */
      constructor(collection, map, reduce, options) {
        super(options);
        this.collection = collection;
        this.map = map;
        this.reduce = reduce;
      }
      /**
       * Execute the operation.
       *
       * @param {Collection~resultCallback} [callback] The command result callback
       */
      execute(callback) {
        const coll = this.collection;
        const map = this.map;
        const reduce = this.reduce;
        let options = this.options;
        let mapCommandHash = {
          mapReduce: coll.collectionName,
          map,
          reduce
        };
        for (let n in options) {
          if ("scope" === n) {
            mapCommandHash[n] = processScope(options[n]);
          } else {
            if (exclusionList.indexOf(n) === -1) {
              mapCommandHash[n] = options[n];
            }
          }
        }
        options = Object.assign({}, options);
        options.readPreference = ReadPreference.resolve(coll, options);
        if (options.readPreference !== false && options.readPreference !== "primary" && options["out"] && options["out"].inline !== 1 && options["out"] !== "inline") {
          options.readPreference = "primary";
          applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options);
        } else {
          decorateWithReadConcern(mapCommandHash, coll, options);
        }
        if (options.bypassDocumentValidation === true) {
          mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        try {
          decorateWithCollation(mapCommandHash, coll, options);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 9) {
            callback(new MongoError(`server does not support explain on mapReduce`));
            return;
          }
          mapCommandHash = decorateWithExplain(mapCommandHash, this.explain);
        }
        executeCommand(coll.s.db, mapCommandHash, options, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (1 !== result.ok || result.err || result.errmsg) {
            return handleCallback(callback, toError(result));
          }
          if (this.explain)
            return callback(void 0, result);
          const stats = {};
          if (result.timeMillis)
            stats["processtime"] = result.timeMillis;
          if (result.counts)
            stats["counts"] = result.counts;
          if (result.timing)
            stats["timing"] = result.timing;
          if (result.results) {
            if (options["verbose"] == null || !options["verbose"]) {
              return handleCallback(callback, null, result.results);
            }
            return handleCallback(callback, null, { results: result.results, stats });
          }
          let collection = null;
          if (result.result != null && typeof result.result === "object") {
            const doc = result.result;
            let Db2 = loadDb();
            collection = new Db2(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(
              doc.collection
            );
          } else {
            collection = coll.s.db.collection(result.result);
          }
          if (options["verbose"] == null || !options["verbose"]) {
            return handleCallback(callback, err, collection);
          }
          handleCallback(callback, err, { collection, stats });
        });
      }
    };
    function processScope(scope) {
      if (!isObject(scope) || scope._bsontype === "ObjectID") {
        return scope;
      }
      const keys = Object.keys(scope);
      let key;
      const new_scope = {};
      for (let i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        if ("function" === typeof scope[key]) {
          new_scope[key] = new Code2(String(scope[key]));
        } else {
          new_scope[key] = processScope(scope[key]);
        }
      }
      return new_scope;
    }
    defineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);
    module2.exports = MapReduceOperation;
  }
});

// node_modules/mongodb/lib/operations/re_index.js
var require_re_index = __commonJS({
  "node_modules/mongodb/lib/operations/re_index.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var serverType = require_common().serverType;
    var ServerType = require_common().ServerType;
    var MongoError = require_core().MongoError;
    var ReIndexOperation = class extends CommandOperationV2 {
      constructor(collection, options) {
        super(collection, options);
        this.collectionName = collection.collectionName;
      }
      execute(server, callback) {
        if (serverType(server) !== ServerType.Standalone) {
          callback(new MongoError(`reIndex can only be executed on standalone servers.`));
          return;
        }
        super.executeCommand(server, { reIndex: this.collectionName }, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, !!result.ok);
        });
      }
    };
    defineAspects(ReIndexOperation, [Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = ReIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/replace_one.js
var require_replace_one = __commonJS({
  "node_modules/mongodb/lib/operations/replace_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils().hasAtomicOperators;
    var ReplaceOneOperation = class extends OperationBase {
      constructor(collection, filter, replacement, options) {
        super(options);
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.replacement = replacement;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const replacement = this.replacement;
        const options = this.options;
        options.multi = false;
        updateDocuments(
          coll,
          filter,
          replacement,
          options,
          (err, r) => replaceCallback(err, r, replacement, callback)
        );
      }
    };
    function replaceCallback(err, r, doc, callback) {
      if (callback == null)
        return;
      if (err && callback)
        return callback(err);
      if (r == null)
        return callback(null, { result: { ok: 1 } });
      r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
      r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
      r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
      r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
      r.ops = [doc];
      if (callback)
        callback(null, r);
    }
    module2.exports = ReplaceOneOperation;
  }
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS({
  "node_modules/mongodb/lib/operations/stats.js"(exports2, module2) {
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var StatsOperation = class extends CommandOperation {
      /**
       * Construct a Stats operation.
       *
       * @param {Collection} a Collection instance.
       * @param {object} [options] Optional settings. See Collection.prototype.stats for a list of options.
       */
      constructor(collection, options) {
        super(collection.s.db, options, collection);
      }
      _buildCommand() {
        const collection = this.collection;
        const options = this.options;
        const command = {
          collStats: collection.collectionName
        };
        if (options["scale"] != null) {
          command["scale"] = options["scale"];
        }
        return command;
      }
    };
    defineAspects(StatsOperation, Aspect.READ_OPERATION);
    module2.exports = StatsOperation;
  }
});

// node_modules/mongodb/lib/operations/update_many.js
var require_update_many = __commonJS({
  "node_modules/mongodb/lib/operations/update_many.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateManyOperation = class extends OperationBase {
      constructor(collection, filter, update, options) {
        super(options);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options = this.options;
        options.multi = true;
        updateDocuments(coll, filter, update, options, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateManyOperation;
  }
});

// node_modules/mongodb/lib/operations/update_one.js
var require_update_one = __commonJS({
  "node_modules/mongodb/lib/operations/update_one.js"(exports2, module2) {
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateOneOperation = class extends OperationBase {
      constructor(collection, filter, update, options) {
        super(options);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options = this.options;
        options.multi = false;
        updateDocuments(coll, filter, update, options, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateOneOperation;
  }
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS({
  "node_modules/mongodb/lib/collection.js"(exports2, module2) {
    "use strict";
    var deprecate = __require("util").deprecate;
    var deprecateOptions = require_utils().deprecateOptions;
    var emitWarningOnce = require_utils().emitWarningOnce;
    var checkCollectionName = require_utils().checkCollectionName;
    var ObjectID2 = require_core().BSON.ObjectID;
    var MongoError = require_core().MongoError;
    var normalizeHintField = require_utils().normalizeHintField;
    var decorateCommand = require_utils().decorateCommand;
    var decorateWithCollation = require_utils().decorateWithCollation;
    var decorateWithReadConcern = require_utils().decorateWithReadConcern;
    var formattedOrderClause = require_utils().formattedOrderClause;
    var ReadPreference = require_core().ReadPreference;
    var unordered = require_unordered();
    var ordered = require_ordered();
    var ChangeStream = require_change_stream();
    var executeLegacyOperation = require_utils().executeLegacyOperation;
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var MongoDBNamespace = require_utils().MongoDBNamespace;
    var AggregationCursor = require_aggregation_cursor();
    var CommandCursor = require_command_cursor();
    var ensureIndex = require_collection_ops().ensureIndex;
    var group = require_collection_ops().group;
    var parallelCollectionScan = require_collection_ops().parallelCollectionScan;
    var removeDocuments = require_common_functions().removeDocuments;
    var save = require_collection_ops().save;
    var updateDocuments = require_common_functions().updateDocuments;
    var AggregateOperation = require_aggregate();
    var BulkWriteOperation = require_bulk_write();
    var CountDocumentsOperation = require_count_documents();
    var CreateIndexesOperation = require_create_indexes();
    var DeleteManyOperation = require_delete_many();
    var DeleteOneOperation = require_delete_one();
    var DistinctOperation = require_distinct();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropIndexOperation = require_drop_index();
    var DropIndexesOperation = require_drop_indexes();
    var EstimatedDocumentCountOperation = require_estimated_document_count();
    var FindOperation = require_find();
    var FindOneOperation = require_find_one();
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = require_find_one_and_delete();
    var FindOneAndReplaceOperation = require_find_one_and_replace();
    var FindOneAndUpdateOperation = require_find_one_and_update();
    var GeoHaystackSearchOperation = require_geo_haystack_search();
    var IndexesOperation = require_indexes();
    var IndexExistsOperation = require_index_exists();
    var IndexInformationOperation = require_index_information();
    var InsertManyOperation = require_insert_many();
    var InsertOneOperation = require_insert_one();
    var IsCappedOperation = require_is_capped();
    var ListIndexesOperation = require_list_indexes();
    var MapReduceOperation = require_map_reduce();
    var OptionsOperation = require_options_operation();
    var RenameOperation = require_rename();
    var ReIndexOperation = require_re_index();
    var ReplaceOneOperation = require_replace_one();
    var StatsOperation = require_stats();
    var UpdateManyOperation = require_update_many();
    var UpdateOneOperation = require_update_one();
    var executeOperation = require_execute_operation();
    var mergeKeys = ["ignoreUndefined"];
    function Collection(db, topology, dbName, name, pkFactory, options) {
      checkCollectionName(name);
      const internalHint = null;
      const slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
      const serializeFunctions = options == null || options.serializeFunctions == null ? db.s.options.serializeFunctions : options.serializeFunctions;
      const raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
      const promoteLongs = options == null || options.promoteLongs == null ? db.s.options.promoteLongs : options.promoteLongs;
      const promoteValues = options == null || options.promoteValues == null ? db.s.options.promoteValues : options.promoteValues;
      const promoteBuffers = options == null || options.promoteBuffers == null ? db.s.options.promoteBuffers : options.promoteBuffers;
      const bsonRegExp = options == null || options.bsonRegExp == null ? db.s.options.bsonRegExp : options.bsonRegExp;
      const collectionHint = null;
      const namespace = new MongoDBNamespace(dbName, name);
      const promiseLibrary = options.promiseLibrary || Promise;
      pkFactory = pkFactory == null ? ObjectID2 : pkFactory;
      this.s = {
        // Set custom primary key factory if provided
        pkFactory,
        // Db
        db,
        // Topology
        topology,
        // Options
        options,
        // Namespace
        namespace,
        // Read preference
        readPreference: ReadPreference.fromOptions(options),
        // SlaveOK
        slaveOk,
        // Serialize functions
        serializeFunctions,
        // Raw
        raw,
        // promoteLongs
        promoteLongs,
        // promoteValues
        promoteValues,
        // promoteBuffers
        promoteBuffers,
        // bsonRegExp
        bsonRegExp,
        // internalHint
        internalHint,
        // collectionHint
        collectionHint,
        // Promise library
        promiseLibrary,
        // Read Concern
        readConcern: ReadConcern.fromOptions(options),
        // Write Concern
        writeConcern: WriteConcern.fromOptions(options)
      };
    }
    Object.defineProperty(Collection.prototype, "dbName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.db;
      }
    });
    Object.defineProperty(Collection.prototype, "collectionName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.collection;
      }
    });
    Object.defineProperty(Collection.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Object.defineProperty(Collection.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        if (this.s.readConcern == null) {
          return this.s.db.readConcern;
        }
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return this.s.db.readPreference;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Collection.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        if (this.s.writeConcern == null) {
          return this.s.db.writeConcern;
        }
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "hint", {
      enumerable: true,
      get: function() {
        return this.s.collectionHint;
      },
      set: function(v) {
        this.s.collectionHint = normalizeHintField(v);
      }
    });
    var DEPRECATED_FIND_OPTIONS = ["maxScan", "fields", "snapshot", "oplogReplay"];
    Collection.prototype.find = deprecateOptions(
      {
        name: "collection.find",
        deprecatedOptions: DEPRECATED_FIND_OPTIONS,
        optionsIndex: 1
      },
      function(query, options, callback) {
        if (typeof callback === "object") {
          emitWarningOnce("Third parameter to `find()` must be a callback or undefined");
        }
        let selector = query;
        if (typeof callback !== "function") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          } else if (options == null) {
            callback = typeof selector === "function" ? selector : void 0;
            selector = typeof selector === "object" ? selector : void 0;
          }
        }
        selector = selector == null ? {} : selector;
        const object2 = selector;
        if (Buffer.isBuffer(object2)) {
          const object_size = object2[0] | object2[1] << 8 | object2[2] << 16 | object2[3] << 24;
          if (object_size !== object2.length) {
            const error = new Error(
              "query selector raw message size does not match message header size [" + object2.length + "] != [" + object_size + "]"
            );
            error.name = "MongoError";
            throw error;
          }
        }
        if (selector != null && selector._bsontype === "ObjectID") {
          selector = { _id: selector };
        }
        if (!options)
          options = {};
        let projection = options.projection || options.fields;
        if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
          projection = projection.length ? projection.reduce((result, field) => {
            result[field] = 1;
            return result;
          }, {}) : { _id: 1 };
        }
        let newOptions = Object.assign({}, options);
        for (let key in this.s.options) {
          if (mergeKeys.indexOf(key) !== -1) {
            newOptions[key] = this.s.options[key];
          }
        }
        newOptions.skip = options.skip ? options.skip : 0;
        newOptions.limit = options.limit ? options.limit : 0;
        newOptions.raw = typeof options.raw === "boolean" ? options.raw : this.s.raw;
        newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
        newOptions.timeout = typeof options.timeout === "undefined" ? void 0 : options.timeout;
        newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;
        newOptions.readPreference = ReadPreference.resolve(this, newOptions);
        if (newOptions.readPreference != null && (newOptions.readPreference !== "primary" || newOptions.readPreference.mode !== "primary")) {
          newOptions.slaveOk = true;
        }
        if (selector != null && typeof selector !== "object") {
          throw MongoError.create({ message: "query selector must be an object", driver: true });
        }
        const findCommand = {
          find: this.s.namespace.toString(),
          limit: newOptions.limit,
          skip: newOptions.skip,
          query: selector
        };
        if (typeof options.allowDiskUse === "boolean") {
          findCommand.allowDiskUse = options.allowDiskUse;
        }
        if (typeof newOptions.awaitdata === "boolean") {
          newOptions.awaitData = newOptions.awaitdata;
        }
        if (typeof newOptions.timeout === "boolean")
          newOptions.noCursorTimeout = !newOptions.timeout;
        decorateCommand(findCommand, newOptions, ["session", "collation"]);
        if (projection)
          findCommand.fields = projection;
        newOptions.db = this.s.db;
        newOptions.promiseLibrary = this.s.promiseLibrary;
        if (newOptions.raw == null && typeof this.s.raw === "boolean")
          newOptions.raw = this.s.raw;
        if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === "boolean")
          newOptions.promoteLongs = this.s.promoteLongs;
        if (newOptions.promoteValues == null && typeof this.s.promoteValues === "boolean")
          newOptions.promoteValues = this.s.promoteValues;
        if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === "boolean")
          newOptions.promoteBuffers = this.s.promoteBuffers;
        if (newOptions.bsonRegExp == null && typeof this.s.bsonRegExp === "boolean")
          newOptions.bsonRegExp = this.s.bsonRegExp;
        if (findCommand.sort) {
          findCommand.sort = formattedOrderClause(findCommand.sort);
        }
        decorateWithReadConcern(findCommand, this, options);
        try {
          decorateWithCollation(findCommand, this, options);
        } catch (err) {
          if (typeof callback === "function")
            return callback(err, null);
          throw err;
        }
        const cursor = this.s.topology.cursor(
          new FindOperation(this, this.s.namespace, findCommand, newOptions),
          newOptions
        );
        if (typeof callback === "function") {
          callback(null, cursor);
          return;
        }
        return cursor;
      }
    );
    Collection.prototype.insertOne = function(doc, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const insertOneOperation = new InsertOneOperation(this, doc, options);
      return executeOperation(this.s.topology, insertOneOperation, callback);
    };
    Collection.prototype.insertMany = function(docs, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options ? Object.assign({}, options) : { ordered: true };
      const insertManyOperation = new InsertManyOperation(this, docs, options);
      return executeOperation(this.s.topology, insertManyOperation, callback);
    };
    Collection.prototype.bulkWrite = function(operations, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || { ordered: true };
      if (!Array.isArray(operations)) {
        throw MongoError.create({ message: "operations must be an array of documents", driver: true });
      }
      const bulkWriteOperation = new BulkWriteOperation(this, operations, options);
      return executeOperation(this.s.topology, bulkWriteOperation, callback);
    };
    Collection.prototype.insert = deprecate(function(docs, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || { ordered: false };
      docs = !Array.isArray(docs) ? [docs] : docs;
      if (options.keepGoing === true) {
        options.ordered = false;
      }
      return this.insertMany(docs, options, callback);
    }, "collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.");
    Collection.prototype.updateOne = function(filter, update, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(
        this.s.topology,
        new UpdateOneOperation(this, filter, update, options),
        callback
      );
    };
    Collection.prototype.replaceOne = function(filter, doc, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(
        this.s.topology,
        new ReplaceOneOperation(this, filter, doc, options),
        callback
      );
    };
    Collection.prototype.updateMany = function(filter, update, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(
        this.s.topology,
        new UpdateManyOperation(this, filter, update, options),
        callback
      );
    };
    Collection.prototype.update = deprecate(function(selector, update, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, updateDocuments, [
        this,
        selector,
        update,
        options,
        callback
      ]);
    }, "collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.");
    Collection.prototype.deleteOne = function(filter, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteOneOperation = new DeleteOneOperation(this, filter, options);
      return executeOperation(this.s.topology, deleteOneOperation, callback);
    };
    Collection.prototype.removeOne = Collection.prototype.deleteOne;
    Collection.prototype.deleteMany = function(filter, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options);
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteManyOperation = new DeleteManyOperation(this, filter, options);
      return executeOperation(this.s.topology, deleteManyOperation, callback);
    };
    Collection.prototype.removeMany = Collection.prototype.deleteMany;
    Collection.prototype.remove = deprecate(function(selector, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, removeDocuments, [
        this,
        selector,
        options,
        callback
      ]);
    }, "collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.");
    Collection.prototype.save = deprecate(function(doc, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, save, [this, doc, options, callback]);
    }, "collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.");
    Collection.prototype.findOne = deprecateOptions(
      {
        name: "collection.find",
        deprecatedOptions: DEPRECATED_FIND_OPTIONS,
        optionsIndex: 1
      },
      function(query, options, callback) {
        if (typeof callback === "object") {
          emitWarningOnce("Third parameter to `findOne()` must be a callback or undefined");
        }
        if (typeof query === "function")
          callback = query, query = {}, options = {};
        if (typeof options === "function")
          callback = options, options = {};
        query = query || {};
        options = options || {};
        const findOneOperation = new FindOneOperation(this, query, options);
        return executeOperation(this.s.topology, findOneOperation, callback);
      }
    );
    Collection.prototype.rename = function(newName, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });
      const renameOperation = new RenameOperation(this, newName, options);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Collection.prototype.drop = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const dropCollectionOperation = new DropCollectionOperation(
        this.s.db,
        this.collectionName,
        options
      );
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Collection.prototype.options = function(opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      opts = opts || {};
      const optionsOperation = new OptionsOperation(this, opts);
      return executeOperation(this.s.topology, optionsOperation, callback);
    };
    Collection.prototype.isCapped = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const isCappedOperation = new IsCappedOperation(this, options);
      return executeOperation(this.s.topology, isCappedOperation, callback);
    };
    Collection.prototype.createIndex = function(fieldOrSpec, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const createIndexesOperation = new CreateIndexesOperation(
        this,
        this.collectionName,
        fieldOrSpec,
        options
      );
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.createIndexes = function(indexSpecs, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options ? Object.assign({}, options) : {};
      if (typeof options.maxTimeMS !== "number")
        delete options.maxTimeMS;
      const createIndexesOperation = new CreateIndexesOperation(
        this,
        this.collectionName,
        indexSpecs,
        options
      );
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.dropIndex = function(indexName, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() || {} : {};
      options.readPreference = ReadPreference.PRIMARY;
      const dropIndexOperation = new DropIndexOperation(this, indexName, options);
      return executeOperation(this.s.topology, dropIndexOperation, callback);
    };
    Collection.prototype.dropIndexes = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options ? Object.assign({}, options) : {};
      if (typeof options.maxTimeMS !== "number")
        delete options.maxTimeMS;
      const dropIndexesOperation = new DropIndexesOperation(this, options);
      return executeOperation(this.s.topology, dropIndexesOperation, callback);
    };
    Collection.prototype.dropAllIndexes = deprecate(
      Collection.prototype.dropIndexes,
      "collection.dropAllIndexes is deprecated. Use dropIndexes instead."
    );
    Collection.prototype.reIndex = deprecate(function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const reIndexOperation = new ReIndexOperation(this, options);
      return executeOperation(this.s.topology, reIndexOperation, callback);
    }, "collection.reIndex is deprecated. Use db.command instead.");
    Collection.prototype.listIndexes = function(options) {
      const cursor = new CommandCursor(
        this.s.topology,
        new ListIndexesOperation(this, options),
        options
      );
      return cursor;
    };
    Collection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        fieldOrSpec,
        options,
        callback
      ]);
    }, "collection.ensureIndex is deprecated. Use createIndexes instead.");
    Collection.prototype.indexExists = function(indexes, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const indexExistsOperation = new IndexExistsOperation(this, indexes, options);
      return executeOperation(this.s.topology, indexExistsOperation, callback);
    };
    Collection.prototype.indexInformation = function(options, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() || {} : {};
      const indexInformationOperation = new IndexInformationOperation(
        this.s.db,
        this.collectionName,
        options
      );
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Collection.prototype.count = deprecate(function(query, options, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options = args.length ? args.shift() || {} : {};
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      return executeOperation(
        this.s.topology,
        new EstimatedDocumentCountOperation(this, Object.assign({ query }, options)),
        callback
      );
    }, "collection.count is deprecated, and will be removed in a future version. Use Collection.countDocuments or Collection.estimatedDocumentCount instead");
    Collection.prototype.estimatedDocumentCount = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options);
      return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);
    };
    Collection.prototype.countDocuments = function(query, options, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options = args.length ? args.shift() || {} : {};
      const countDocumentsOperation = new CountDocumentsOperation(this, query, options);
      return executeOperation(this.s.topology, countDocumentsOperation, callback);
    };
    Collection.prototype.distinct = function(key, query, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      const queryOption = args.length ? args.shift() || {} : {};
      const optionsOption = args.length ? args.shift() || {} : {};
      const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);
      return executeOperation(this.s.topology, distinctOperation, callback);
    };
    Collection.prototype.indexes = function(options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      const indexesOperation = new IndexesOperation(this, options);
      return executeOperation(this.s.topology, indexesOperation, callback);
    };
    Collection.prototype.stats = function(options, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() || {} : {};
      const statsOperation = new StatsOperation(this, options);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Collection.prototype.findOneAndDelete = function(filter, options, callback) {
      if (typeof options === "function")
        callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = Object.assign({}, options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(
        this.s.topology,
        new FindOneAndDeleteOperation(this, filter, options),
        callback
      );
    };
    Collection.prototype.findOneAndReplace = deprecateOptions(
      {
        name: "collection.findOneAndReplace",
        deprecatedOptions: ["returnOriginal"],
        optionsIndex: 2
      },
      function(filter, replacement, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options || {};
        if (this.s.options.ignoreUndefined) {
          options = Object.assign({}, options);
          options.ignoreUndefined = this.s.options.ignoreUndefined;
        }
        return executeOperation(
          this.s.topology,
          new FindOneAndReplaceOperation(this, filter, replacement, options),
          callback
        );
      }
    );
    Collection.prototype.findOneAndUpdate = deprecateOptions(
      {
        name: "collection.findOneAndUpdate",
        deprecatedOptions: ["returnOriginal"],
        optionsIndex: 2
      },
      function(filter, update, options, callback) {
        if (typeof options === "function")
          callback = options, options = {};
        options = options || {};
        if (this.s.options.ignoreUndefined) {
          options = Object.assign({}, options);
          options.ignoreUndefined = this.s.options.ignoreUndefined;
        }
        return executeOperation(
          this.s.topology,
          new FindOneAndUpdateOperation(this, filter, update, options),
          callback
        );
      }
    );
    Collection.prototype.findAndModify = deprecate(
      _findAndModify,
      "collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead."
    );
    Collection.prototype._findAndModify = _findAndModify;
    function _findAndModify(query, sort, doc, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      doc = args.length ? args.shift() : null;
      options = args.length ? args.shift() || {} : {};
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.PRIMARY;
      return executeOperation(
        this.s.topology,
        new FindAndModifyOperation(this, query, sort, doc, options),
        callback
      );
    }
    Collection.prototype.findAndRemove = deprecate(function(query, sort, options, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      options = args.length ? args.shift() || {} : {};
      options.remove = true;
      return executeOperation(
        this.s.topology,
        new FindAndModifyOperation(this, query, sort, null, options),
        callback
      );
    }, "collection.findAndRemove is deprecated. Use findOneAndDelete instead.");
    Collection.prototype.aggregate = function(pipeline, options, callback) {
      if (Array.isArray(pipeline)) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (options == null && callback == null) {
          options = {};
        }
      } else {
        const args = Array.prototype.slice.call(arguments, 0);
        callback = args.pop();
        const opts = args[args.length - 1];
        options = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.hint || opts.allowDiskUse) ? args.pop() : {};
        pipeline = args;
      }
      const cursor = new AggregationCursor(
        this.s.topology,
        new AggregateOperation(this, pipeline, options),
        options
      );
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Collection.prototype.watch = function(pipeline, options) {
      pipeline = pipeline || [];
      options = options || {};
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new ChangeStream(this, pipeline, options);
    };
    Collection.prototype.parallelCollectionScan = deprecate(function(options, callback) {
      if (typeof options === "function")
        callback = options, options = { numCursors: 1 };
      options.numCursors = options.numCursors || 1;
      options.batchSize = options.batchSize || 1e3;
      options = Object.assign({}, options);
      options.readPreference = ReadPreference.resolve(this, options);
      options.promiseLibrary = this.s.promiseLibrary;
      if (options.session) {
        options.session = void 0;
      }
      return executeLegacyOperation(
        this.s.topology,
        parallelCollectionScan,
        [this, options, callback],
        { skipSessions: true }
      );
    }, "parallelCollectionScan is deprecated in MongoDB v4.1");
    Collection.prototype.geoHaystackSearch = deprecate(function(x, y, options, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options = args.length ? args.shift() || {} : {};
      const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y, options);
      return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);
    }, "geoHaystackSearch is deprecated, and will be removed in a future version.");
    Collection.prototype.group = deprecate(
      function(keys, condition, initial, reduce, finalize, command, options, callback) {
        const args = Array.prototype.slice.call(arguments, 3);
        callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
        reduce = args.length ? args.shift() : null;
        finalize = args.length ? args.shift() : null;
        command = args.length ? args.shift() : null;
        options = args.length ? args.shift() || {} : {};
        if (!(typeof finalize === "function")) {
          command = finalize;
          finalize = null;
        }
        if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== "function" && !(keys._bsontype === "Code")) {
          keys = Object.keys(keys);
        }
        if (typeof reduce === "function") {
          reduce = reduce.toString();
        }
        if (typeof finalize === "function") {
          finalize = finalize.toString();
        }
        command = command == null ? true : command;
        return executeLegacyOperation(this.s.topology, group, [
          this,
          keys,
          condition,
          initial,
          reduce,
          finalize,
          command,
          options,
          callback
        ]);
      },
      "MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework."
    );
    Collection.prototype.mapReduce = function(map, reduce, options, callback) {
      if ("function" === typeof options)
        callback = options, options = {};
      if (null == options.out) {
        throw new Error(
          "the out option parameter must be defined, see mongodb docs for possible values"
        );
      }
      if ("function" === typeof map) {
        map = map.toString();
      }
      if ("function" === typeof reduce) {
        reduce = reduce.toString();
      }
      if ("function" === typeof options.finalize) {
        options.finalize = options.finalize.toString();
      }
      const mapReduceOperation = new MapReduceOperation(this, map, reduce, options);
      return executeOperation(this.s.topology, mapReduceOperation, callback);
    };
    Collection.prototype.initializeUnorderedBulkOp = function(options) {
      options = options || {};
      if (options.ignoreUndefined == null) {
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options.promiseLibrary = this.s.promiseLibrary;
      return unordered(this.s.topology, this, options);
    };
    Collection.prototype.initializeOrderedBulkOp = function(options) {
      options = options || {};
      if (options.ignoreUndefined == null) {
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options.promiseLibrary = this.s.promiseLibrary;
      return ordered(this.s.topology, this, options);
    };
    Collection.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    module2.exports = Collection;
  }
});

// node_modules/@rakered/mongo/lib/connection/cursor.js
var require_cursor3 = __commonJS({
  "node_modules/@rakered/mongo/lib/connection/cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseCursor = exports2.getCursor = void 0;
    function getCursor(record, sortField) {
      return Buffer.from([record[sortField], record._id].join(":")).toString("base64");
    }
    exports2.getCursor = getCursor;
    function parseCursor(cursor) {
      return Buffer.from(cursor, "base64").toString("ascii").split(":");
    }
    exports2.parseCursor = parseCursor;
  }
});

// node_modules/@rakered/errors/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/@rakered/errors/lib/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotFoundError = exports2.UserInputError = exports2.ForbiddenError = exports2.AuthenticationError = void 0;
    var AuthenticationError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "AuthenticationError";
        this.code = 401;
      }
    };
    exports2.AuthenticationError = AuthenticationError;
    var ForbiddenError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ForbiddenError";
        this.code = 403;
      }
    };
    exports2.ForbiddenError = ForbiddenError;
    var UserInputError = class extends Error {
      constructor(message, data) {
        super(message);
        this.name = "UserInputError";
        this.code = 422;
        this.data = data;
      }
    };
    exports2.UserInputError = UserInputError;
    var NotFoundError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "NotFoundError";
        this.code = 404;
      }
    };
    exports2.NotFoundError = NotFoundError;
  }
});

// node_modules/@rakered/errors/lib/index.js
var require_lib = __commonJS({
  "node_modules/@rakered/errors/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_errors2(), exports2);
  }
});

// node_modules/@rakered/mongo/lib/connection/validatePaginationArgs.js
var require_validatePaginationArgs = __commonJS({
  "node_modules/@rakered/mongo/lib/connection/validatePaginationArgs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validatePaginationArgs = void 0;
    var errors_1 = require_lib();
    function validatePaginationArgs(params) {
      if (!params || typeof params !== "object") {
        throw new errors_1.UserInputError("You must provide arguments to properly paginate the connection.");
      }
      if (!params.first && !params.last) {
        throw new errors_1.UserInputError("You must provide a `first` or `last` value to properly paginate the connection.");
      }
      if (params.first && params.last) {
        throw new errors_1.UserInputError("Passing both `first` and `last` to paginate the connection is not supported.");
      }
      if (params.last && params.last < 0) {
        throw new errors_1.UserInputError("Last should be non negative.");
      }
      if (params.first && params.first < 0) {
        throw new errors_1.UserInputError("First should be non negative.");
      }
      const [field, direction] = params.order || [];
      if (params.order && (!field || direction !== "asc" && direction !== "desc")) {
        throw new errors_1.UserInputError("You must provide an `order` to properly paginate the connection.");
      }
    }
    exports2.validatePaginationArgs = validatePaginationArgs;
  }
});

// node_modules/@rakered/mongo/lib/connection/connection.js
var require_connection3 = __commonJS({
  "node_modules/@rakered/mongo/lib/connection/connection.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getConnection = void 0;
    var cursor_1 = require_cursor3();
    var validatePaginationArgs_1 = require_validatePaginationArgs();
    function getConnection(collection, query, options = {}) {
      var _a, _b, _c, _d, _e;
      return __awaiter(this, void 0, void 0, function* () {
        validatePaginationArgs_1.validatePaginationArgs(options);
        const { projection, after, before, first, last } = options;
        const orderBy = ((_a = options.sort) === null || _a === void 0 ? void 0 : _a[0]) || "_id";
        const orderDir = (((_b = options.sort) === null || _b === void 0 ? void 0 : _b[1]) === "desc" ? -1 : 1) * (last ? -1 : 1);
        const operation = orderDir === 1 ? "$gt" : "$lt";
        const sort = orderBy === "_id" ? [[orderBy, orderDir]] : [
          [orderBy, orderDir],
          ["_id", orderDir]
        ];
        const limit = (_c = first !== null && first !== void 0 ? first : last) !== null && _c !== void 0 ? _c : 100;
        const selector = Object.assign({}, query);
        if (after || before) {
          let [offset, id] = cursor_1.parseCursor(before || after);
          offset = isNaN(offset) ? offset : Number(offset);
          if (orderBy === "_id") {
            selector._id = { [operation]: id };
          } else {
            selector.$or = [
              { [orderBy]: { [operation]: offset } },
              { [orderBy]: { $eq: offset }, _id: { [operation]: id } }
            ];
          }
        }
        let [totalCount, nodes] = yield Promise.all([
          collection.countDocuments(query),
          collection.find(selector, { sort, limit: limit + 1, projection }).toArray()
        ]);
        const hasMore = nodes.length > limit;
        const hasPreviousPage = !!(after || last && hasMore);
        const hasNextPage = !!(before || first && hasMore);
        nodes = last && !before ? nodes.splice(0, limit).reverse() : nodes.splice(0, limit);
        if (before) {
          nodes.reverse();
        }
        const edges = nodes.map((node) => ({
          node,
          cursor: cursor_1.getCursor(node, orderBy)
        }));
        const connection = {
          totalCount,
          pageInfo: {
            startCursor: ((_d = edges[0]) === null || _d === void 0 ? void 0 : _d.cursor) || void 0,
            endCursor: ((_e = edges[edges.length - 1]) === null || _e === void 0 ? void 0 : _e.cursor) || void 0,
            hasPreviousPage,
            hasNextPage
          },
          nodes,
          edges
        };
        if (options.type === "nodes") {
          delete connection.edges;
        }
        if (options.type === "edges") {
          delete connection.nodes;
        }
        return connection;
      });
    }
    exports2.getConnection = getConnection;
  }
});

// node_modules/@rakered/mongo/lib/collection.js
var require_collection2 = __commonJS({
  "node_modules/@rakered/mongo/lib/collection.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCollection = void 0;
    var collection_1 = __importDefault2(require_collection());
    var common_1 = require_common2();
    var connection_1 = require_connection3();
    function isCursor(res) {
      return typeof (res === null || res === void 0 ? void 0 : res.then) !== "function" && typeof (res === null || res === void 0 ? void 0 : res.toArray) === "function";
    }
    function wrapCursor(method, args, res) {
      var _a, _b, _c;
      switch (method) {
        case "find":
          return ((_a = args[1]) === null || _a === void 0 ? void 0 : _a.rawCursor) ? res : res.toArray();
        case "aggregate":
          return ((_b = args[1]) === null || _b === void 0 ? void 0 : _b.rawCursor) ? res : res.toArray();
        case "listIndexes":
          return ((_c = args[0]) === null || _c === void 0 ? void 0 : _c.rawCursor) ? res : res.toArray();
        default:
          return res;
      }
    }
    function getCollection({ getInstance, name }) {
      return new Proxy({ pkPrefix: "" }, {
        get: function(obj, method) {
          if (typeof method !== "string" || typeof obj[method] !== "undefined") {
            return obj[method];
          }
          if (method === "pkPrefix") {
            return obj.pkPrefix;
          }
          return (...args) => __awaiter(this, void 0, void 0, function* () {
            const db = yield getInstance();
            const collection = db.collection(name);
            const res = collection[method](...args);
            return isCursor(res) ? wrapCursor(method, args, res) : res;
          });
        }
      });
    }
    exports2.getCollection = getCollection;
    function forceServerObjectId(instance) {
      var _a;
      if (typeof instance.s.options.forceServerObjectId === "boolean") {
        return instance.s.options.forceServerObjectId;
      }
      if (typeof ((_a = instance.s.db) === null || _a === void 0 ? void 0 : _a.s.options.forceServerObjectId) === "boolean") {
        return instance.s.db.s.options.forceServerObjectId;
      }
      if (instance.s.collection) {
        return instance.s.collection.s.db.options.forceServerObjectId;
      }
      return false;
    }
    function createPk(instance) {
      const collection = instance.s.collection || instance;
      const options = {
        dbName: collection.dbName,
        collectionName: collection.collectionName
      };
      return collection.s.pkFactory.createPk(options);
    }
    collection_1.default.prototype.paginate = function findPage(filter, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return connection_1.getConnection(this, filter, options);
      });
    };
    var _insertOne = collection_1.default.prototype.insertOne;
    collection_1.default.prototype.insertOne = function insertOne(doc, options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
          return _insertOne.apply(this, [doc, options]);
        }
        doc._id = doc._id || createPk(this);
        return _insertOne.apply(this, [doc, options]);
      });
    };
    var _insertMany = collection_1.default.prototype.insertMany;
    collection_1.default.prototype.insertMany = function insertMany(docs, options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
          return _insertMany.apply(this, [docs, options]);
        }
        for (const doc of docs) {
          doc._id = doc._id || createPk(this);
        }
        return _insertMany.apply(this, [docs, options]);
      });
    };
    var _updateOne = collection_1.default.prototype.updateOne;
    collection_1.default.prototype.updateOne = function updateOne(filter, update, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
          return _updateOne.apply(this, [filter, update, options]);
        }
        if (options.upsert && !filter._id) {
          update.$setOnInsert = update.$setOnInsert || {};
          update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        return _updateOne.apply(this, [filter, update, options]);
      });
    };
    var _updateMany = collection_1.default.prototype.updateMany;
    collection_1.default.prototype.updateMany = function updateMany(filter, update, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
          return _updateMany.apply(this, [filter, update, options]);
        }
        if (options.upsert && !filter._id) {
          update.$setOnInsert = update.$setOnInsert || {};
          update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        return _updateMany.apply(this, [filter, update, options]);
      });
    };
    var _findOneAndUpdate = collection_1.default.prototype.findOneAndUpdate;
    collection_1.default.prototype.findOneAndUpdate = function findOneAndUpdate(filter, update, options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
          return _findOneAndUpdate.apply(this, [filter, update, options]);
        }
        if (options.upsert && !filter._id) {
          update.$setOnInsert = update.$setOnInsert || {};
          update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        return _findOneAndUpdate.apply(this, [filter, update, options]);
      });
    };
    var _bulkInsert = common_1.BulkOperationBase.prototype.insert;
    common_1.BulkOperationBase.prototype.insert = function insert(doc) {
      if (forceServerObjectId(this)) {
        return _bulkInsert.apply(this, [doc]);
      }
      doc._id = doc._id || createPk(this);
      return _bulkInsert.apply(this, [doc]);
    };
    var _bulkRaw = common_1.BulkOperationBase.prototype.raw;
    common_1.BulkOperationBase.prototype.raw = function raw(op) {
      var _a, _b, _c, _d, _e;
      return __awaiter(this, void 0, void 0, function* () {
        if (forceServerObjectId(this)) {
          return _bulkRaw.apply(this, [op]);
        }
        if (((_a = op.updateOne) === null || _a === void 0 ? void 0 : _a.upsert) && !((_b = op.updateOne.filter) === null || _b === void 0 ? void 0 : _b._id)) {
          const update = op.updateOne.update;
          update.$setOnInsert = update.$setOnInsert || {};
          update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        if (((_c = op.updateMany) === null || _c === void 0 ? void 0 : _c.upsert) && !((_d = op.updateMany.filter) === null || _d === void 0 ? void 0 : _d._id)) {
          const update = op.updateMany.update;
          update.$setOnInsert = update.$setOnInsert || {};
          update.$setOnInsert._id = update.$setOnInsert._id || createPk(this);
        }
        if ((_e = op.insertOne) === null || _e === void 0 ? void 0 : _e.document) {
          op.insertOne.document._id = op.insertOne.document._id || createPk(this);
        } else if (op.insertOne) {
          op.insertOne._id = op.insertOne._id || createPk(this);
        }
        if (op.insertMany) {
          for (let i = 0; i < op.insertMany.length; i++) {
            op.insertMany[i]._id = op.insertMany[i]._id || createPk(this);
          }
        }
        return _bulkRaw.apply(this, [op]);
      });
    };
    var _bulkFind = common_1.BulkOperationBase.prototype.find;
    common_1.BulkOperationBase.prototype.find = function find(selector) {
      const op = _bulkFind.apply(this, [selector]);
      const _update = op.update;
      op.update = function update(document) {
        return _update.apply(this, [document]);
      };
      const _updateOne2 = op.updateOne;
      op.updateOne = function updateOne(document) {
        if (this.s.currentOp.upsert && !selector._id) {
          document.$setOnInsert = document.$setOnInsert || {};
          document.$setOnInsert._id = document.$setOnInsert._id || createPk(this);
        }
        return _updateOne2.apply(this, [document]);
      };
      return op;
    };
  }
});

// node_modules/nanoid/random.js
var require_random = __commonJS({
  "node_modules/nanoid/random.js"(exports2, module2) {
    var crypto = __require("crypto");
    if (crypto.randomFillSync) {
      buffers = {};
      module2.exports = function(bytes) {
        var buffer = buffers[bytes];
        if (!buffer) {
          buffer = Buffer.allocUnsafe(bytes);
          if (bytes <= 255)
            buffers[bytes] = buffer;
        }
        return crypto.randomFillSync(buffer);
      };
    } else {
      module2.exports = crypto.randomBytes;
    }
    var buffers;
  }
});

// node_modules/nanoid/format.js
var require_format = __commonJS({
  "node_modules/nanoid/format.js"(exports2, module2) {
    module2.exports = function(random, alphabet, size) {
      var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      var step = Math.ceil(1.6 * mask * size / alphabet.length);
      var id = "";
      while (true) {
        var bytes = random(step);
        for (var i = 0; i < step; i++) {
          var byte = bytes[i] & mask;
          if (alphabet[byte]) {
            id += alphabet[byte];
            if (id.length === size)
              return id;
          }
        }
      }
    };
  }
});

// node_modules/nanoid/generate.js
var require_generate = __commonJS({
  "node_modules/nanoid/generate.js"(exports2, module2) {
    var random = require_random();
    var format = require_format();
    module2.exports = function(alphabet, size) {
      return format(random, alphabet, size);
    };
  }
});

// node_modules/picoid/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/picoid/lib/index.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var generate_1 = __importDefault2(require_generate());
    var alphabet = "23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz";
    function picoid(length = 17) {
      return generate_1.default(alphabet, length);
    }
    exports2.default = picoid;
  }
});

// node_modules/@rakered/mongo/lib/db.js
var require_db2 = __commonJS({
  "node_modules/@rakered/mongo/lib/db.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connect = exports2.create = void 0;
    require_collection2();
    var mongodb_1 = require_mongodb();
    var picoid_1 = __importDefault2(require_lib2());
    var collection_1 = require_collection2();
    function create(uri = process.env.MONGO_URL || "mongodb://localhost:27017", options) {
      let client;
      let db;
      const collections = {};
      let instancePromise;
      function createPk({ collectionName }) {
        if (collections[collectionName].pkPrefix) {
          return collections[collectionName].pkPrefix + picoid_1.default();
        }
        return picoid_1.default();
      }
      const clientOptions = Object.assign({
        useNewUrlParser: true,
        useUnifiedTopology: true,
        pkFactory: { createPk }
      }, options);
      function getInstance() {
        return __awaiter(this, void 0, void 0, function* () {
          if (instancePromise) {
            return instancePromise;
          }
          instancePromise = new Promise((resolve) => {
            mongodb_1.MongoClient.connect(uri, clientOptions).then((mongoClient) => {
              client = mongoClient;
              db = client.db();
              resolve(db);
            });
          });
          return instancePromise;
        });
      }
      function connect2() {
        return __awaiter(this, void 0, void 0, function* () {
          yield getInstance();
        });
      }
      function disconnect(force) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!client) {
            return;
          }
          yield client.close(force);
        });
      }
      function transaction(fn, options2) {
        return __awaiter(this, void 0, void 0, function* () {
          yield connect2();
          if (!client) {
            throw new Error("Client is undefined o.O");
          }
          const session = client.startSession();
          try {
            return yield session.withTransaction(() => fn(session), options2);
          } finally {
            yield session.endSession();
          }
        });
      }
      if ((options === null || options === void 0 ? void 0 : options.autoDisconnect) !== false) {
        process.on("exit", () => {
          disconnect(true).catch(() => void 0);
        });
      }
      return new Proxy({}, {
        get: function(obj, name) {
          if (typeof name !== "string" || typeof obj[name] !== "undefined") {
            return obj[name];
          }
          if (db === null || db === void 0 ? void 0 : db.hasOwnProperty(name)) {
            return db[name];
          }
          if (name === "transaction") {
            return transaction;
          }
          if (name === "connect") {
            return connect2;
          }
          if (name === "disconnect") {
            return disconnect;
          }
          if (collections[name]) {
            return collections[name];
          }
          collections[name] = collection_1.getCollection({ name, getInstance });
          return collections[name];
        }
      });
    }
    exports2.create = create;
    function connect(uri, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const db = create(uri, options);
        yield db.connect();
        return db;
      });
    }
    exports2.connect = connect;
  }
});

// node_modules/@rakered/mongo/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@rakered/mongo/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var db_1 = require_db2();
    __exportStar(require_db2(), exports2);
    __exportStar(require_collection2(), exports2);
    var db = db_1.create();
    exports2.default = db;
  }
});

// src/Connection.ts
var import_mongo = __toESM(require_lib3());

// src/Message.ts
var Message = (message, error = false) => {
  const blueColor = "\x1B[36m";
  const redColor = "\x1B[31m";
  const resetColor = "\x1B[0m";
  const boldFont = "\x1B[1m";
  console.log(`${boldFont}${error ? redColor : blueColor}>> MongoORM: ${message}${resetColor}`);
};
var Message_default = Message;

// src/Connection.ts
import fs from "fs";
import path from "path";
var _Connection = class _Connection {
  constructor(uri, modelFolder = "") {
    const useModelPath = modelFolder || path.join(process.cwd(), "./src/models");
    _Connection.$mongoConnection = (0, import_mongo.create)(!uri ? "mongodb://127.0.0.1:27017/newapp" : uri, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    if (_Connection.$mongoConnection) {
      try {
        const getModelsFromFolder = fs.readdirSync(useModelPath);
        getModelsFromFolder.forEach((model) => {
          const modelPath = path.join(useModelPath, model);
          const ModelClass = __require(modelPath).default;
          ModelClass.generateIndexes();
          _Connection.$models.push(ModelClass);
        });
      } catch (e) {
        Message_default(String(e).toString(), true);
      }
      Message_default(`Connection Initialized (${_Connection.$models.length} models)!`);
      return _Connection.$mongoConnection;
    } else
      Message_default("Unable to connect to MongoDB!", true);
  }
  static sanitize(v) {
    if (v instanceof Object) {
      for (const key in v) {
        if (/^\$/.test(key)) {
          delete v[key];
        } else {
          _Connection.sanitize(v[key]);
        }
      }
    }
    return v;
  }
};
_Connection.$models = [];
var Connection = _Connection;
var Connection_default = Connection;

// src/FieldTypes.ts
var FieldTypes_default = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
  Date: "date",
  Array: "array",
  Object: "object",
  ObjectId: "objectId"
};

// src/Model.ts
var Model = class {
  constructor(name, fieldOptions, indexOptions, otherOptions) {
    this.$name = "";
    this.$fieldOptions = [];
    this.$indexOptions = [];
    this.$otherOptions = {
      debug: false,
      log: -1
    };
    this.processDefault = (field) => {
      if (typeof field.default === "undefined")
        return;
      if (field.type === FieldTypes_default.String && typeof field.default !== "string")
        throw new Error(`Field is of type string but the default value is not a string.`);
      else if (field.type === FieldTypes_default.Number && typeof field.default !== "number")
        throw new Error(`Field is of type number but the default value is not a number.`);
      else if (field.type === FieldTypes_default.Boolean && typeof field.default !== "boolean")
        throw new Error(`Field is of type boolean but the default value is not a boolean.`);
      else if (field.type === FieldTypes_default.Date && !(field.default instanceof Date))
        throw new Error(`Field is of type date but the default value is not a date.`);
      else if (field.type === FieldTypes_default.Array && !Array.isArray(field.default))
        throw new Error(`Field is of type array but the default value is not an array.`);
      else if (field.type === FieldTypes_default.Object && typeof field.default !== "object")
        throw new Error(`Field is of type object but the default value is not an object.`);
      else if (field.type === FieldTypes_default.ObjectId && typeof field.default !== "string")
        throw new Error(`Field is of type objectId but the default value is not a string.`);
    };
    this.processDocument = (document, isUpdate = false) => {
      const processedDocument = {};
      const fieldLength = this.$fieldOptions.length;
      for (let i = 0; i < fieldLength; i++) {
        const field = this.$fieldOptions[i];
        if (document[field.name]) {
          if (field.type === FieldTypes_default.Date)
            processedDocument[field.name] = new Date(document[field.name]);
          else if (field.type === FieldTypes_default.Number)
            processedDocument[field.name] = Number(document[field.name]);
          else if (field.type === FieldTypes_default.Boolean)
            processedDocument[field.name] = Boolean(document[field.name]);
          else if (field.type === FieldTypes_default.ObjectId)
            processedDocument[field.name] = String(document[field.name]);
          else if (field.type === FieldTypes_default.Array && !Array.isArray(document[field.name]))
            processedDocument[field.name] = Array(document[field.name]);
          else if (field.type === FieldTypes_default.Object)
            processedDocument[field.name] = Object(document[field.name]);
          else
            processedDocument[field.name] = document[field.name];
        } else if (field.default) {
          if (field.type === FieldTypes_default.Date)
            processedDocument[field.name] = new Date(field.default);
          else if (field.type === FieldTypes_default.Number)
            processedDocument[field.name] = Number(field.default);
          else if (field.type === FieldTypes_default.Boolean)
            processedDocument[field.name] = Boolean(field.default);
          else if (field.type === FieldTypes_default.ObjectId)
            processedDocument[field.name] = String(field.default);
          else if (field.type === FieldTypes_default.Array && !Array.isArray(field.default))
            processedDocument[field.name] = Array(field.default);
          else if (field.type === FieldTypes_default.Object)
            processedDocument[field.name] = Object(field.default);
          else
            processedDocument[field.name] = field.default;
        } else if (field.required) {
          throw new Error(`Field ${field.name} is required but was not provided a value and does not have a default value to back up off.`);
        }
      }
      ;
      if (isUpdate)
        processedDocument.updatedAt = Math.ceil((/* @__PURE__ */ new Date()).getTime() / 1e3);
      else
        processedDocument.createdAt = Math.ceil((/* @__PURE__ */ new Date()).getTime() / 1e3);
      return processedDocument;
    };
    this.$name = String(name).toLowerCase();
    this.$fieldOptions = fieldOptions;
    this.$indexOptions = indexOptions;
    this.$otherOptions = {
      debug: otherOptions?.debug || false,
      log: otherOptions?.log || -1
    };
    this.$fieldOptions.forEach((field) => this.processDefault(field));
  }
  async generateIndexes() {
    this.$indexOptions.forEach(async (index) => {
      const params = {};
      if (index.unique)
        params.unique = true;
      if (index.name)
        params.name = index.name;
      await Connection_default.$mongoConnection[this.$name].createIndex(index.fields, { ...params });
    });
    Message_default(`Generated indexes for ${this.$name} (${this.$indexOptions.length} total).`);
  }
  async dispatchAction(action, query = {}) {
    if (this.$otherOptions.debug) {
      const start = (/* @__PURE__ */ new Date()).getTime();
      const result = await action;
      const end = (/* @__PURE__ */ new Date()).getTime();
      const total = end - start;
      if (this.$otherOptions.log !== -1 && total > this.$otherOptions.log) {
        Connection_default.$mongoConnection["_mongoOrmDebug"].insertOne({
          model: this.$name,
          query: JSON.stringify(query, null, 2),
          time: total,
          date: /* @__PURE__ */ new Date()
        });
      }
      return result;
    } else
      return await action();
  }
  async aggregate(query, options = {}) {
    return await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].aggregate(query, options), query);
  }
  async findOne(query, options = {}) {
    return await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].findOne(query, options), query);
  }
  async find(query, options = {}) {
    return await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].find(query, options), query);
  }
  async count(query) {
    return await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].countDocuments(query), query);
  }
  async findOneAndUpdate(query, update, upsert = false, useModifier = "$set") {
    const result = await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].findOneAndUpdate(query, { [useModifier]: this.processDocument(update) }, { upsert, returnDocument: "after" }), query);
    if (result && result.ok)
      return result.value;
    else
      return null;
  }
  async updateMany(query, document, useModifier = "$set") {
    const result = await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].updateMany(query, { [useModifier]: this.processDocument(document) }), query);
    if (result)
      return true;
    else
      return null;
  }
  async deleteMany(query) {
    const result = await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].deleteMany(query));
    if (result)
      return true;
    else
      return null;
  }
  async deleteOne(query) {
    const result = await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].deleteOne(query));
    if (result)
      return true;
    else
      return null;
  }
  async insertOne(document) {
    const result = await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].insertOne(this.processDocument(document)));
    if (result && result.insertedCount >= 1)
      return result.ops[0];
    else
      return null;
  }
  async insertMany(document) {
    const result = await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].insertMany(this.processDocument(document)));
    if (result && result.insertedCount >= 1)
      return result.ops[0];
    else
      return null;
  }
  /*
  * Custom Methods
  */
  async findOneOrCreate(query, document = null) {
    const findOne = await this.dispatchAction(await Connection_default.$mongoConnection[this.$name].findOne(query), query);
    if (findOne)
      return findOne;
    else {
      const insert = await Connection_default.$mongoConnection[this.$name].insertOne(this.processDocument(document));
      if (insert && insert.insertedCount >= 1)
        return insert.ops[0];
      else
        return null;
    }
  }
};
var Model_default = Model;

// src/index.ts
var exportData = {
  Connection: Connection_default,
  Model: Model_default,
  FieldTypes: FieldTypes_default
};
var src_default = exportData;
export {
  src_default as default
};
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=index.mjs.map